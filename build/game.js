/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./content/content-compiled.json":
/*!***************************************!*\
  !*** ./content/content-compiled.json ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('[{"name":"products","type":"json","args":[[{"id":"a","name":"A","image":"","matches":["a"],"points":10},{"id":"b","name":"B","image":"","matches":["b"],"points":12},{"id":"c","name":"C","image":"","matches":["c"],"points":14},{"id":"d","name":"D","image":"","matches":["d"],"points":16},{"id":"e","name":"E","image":"","matches":["e"],"points":18},{"id":"f","name":"F","image":"","matches":["f"],"points":20}]]},{"name":"test-1-shelf","type":"json","args":[{"id":"test-1-shelf","name":"Test 1: Shelf","description":"","grid":{"width":3,"height":2},"actors":[{"gridPosition":{"x":0,"y":0},"type":"shelf","offset":{"x":-0.1,"y":0.1},"products":[null,"a",null]},{"gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","a",null]}]}]},{"name":"test-2-closing-shelf","type":"json","args":[{"id":"test-2-closing-shelf","name":"Test 2: Closing Shelf","description":"","grid":{"width":3,"height":2},"actors":[{"gridPosition":{"x":0,"y":0},"type":"closing-shelf","offset":{"x":-0.1,"y":0.1},"products":[null,"a",null]},{"gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","a",null]}]}]},{"name":"test-3-deep-shelf","type":"json","args":[{"id":"test-3-deep-shelf","name":"Test 3: Deep Shelf","description":"","grid":{"width":3,"height":2},"lockedProducts":[{"shelfReference":"test-shelf","product":4}],"actors":[{"reference":"test-shelf","gridPosition":{"x":0,"y":0},"type":"deep-shelf","offset":{"x":-0.5,"y":0.3},"layers":[[null,"a",null],["b","c","d"],[null,"a","b"]]},{"gridPosition":{"x":0,"y":1},"type":"shelf","slotCount":6,"products":["a","a",null,null,null,null]}]}]},{"name":"test-4-disappearing-shelf","type":"json","args":[{"id":"test-4-disappearing-shelf","name":"Test 4: Disappearing Shelf","description":"","grid":{"width":3,"height":3},"actors":[{"gridPosition":{"x":0,"y":0},"type":"disappearing-shelf","offset":{"x":-0.1,"y":0.1},"shelf":{"type":"shelf","products":[null,"a",null]}},{"gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","b",null]},{"gridPosition":{"x":0,"y":2},"type":"shelf","products":["a",null,null]}]}]},{"name":"test-5-supply-shelf","type":"json","args":[{"id":"test-5-supply-shelf","name":"Test 5: Supply Shelf","description":"","grid":{"width":3,"height":2},"actors":[{"gridPosition":{"x":0,"y":0},"type":"supply-shelf","offset":{"x":1,"y":-0.1},"shelf":{"type":"deep-shelf","slotCount":1,"layers":[["a"],["b"],["c"]]}},{"gridPosition":{"x":0,"y":1},"type":"shelf","slotCount":6,"products":["a","a",null,null,null,null]}]}]},{"name":"test-6-carousel","type":"json","args":[{"id":"test-6-carousel","name":"Test 6: Carousel","description":"","grid":{"width":3,"height":2},"lockedProducts":[{"shelfReference":"test-shelf","product":2}],"actors":[{"gridPosition":{"x":0,"y":0},"type":"carousel","orientation":"horizontal","speed":0.5,"shelves":[{"type":"closing-shelf","offset":{"x":0,"y":0.5},"products":["a",null,"b"]},{"type":"shelf","products":["c","b","b"]}]},{"reference":"test-shelf","gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","a",null]}]}]},{"name":"test-7-collapse","type":"json","args":[{"id":"test-7-collapse","name":"Test 7: Collapse","description":"","grid":{"width":3,"height":3},"actors":[{"gridPosition":{"x":-3,"y":0},"type":"collapse","grid":{"width":9,"height":4},"orientation":"horizontal","direction":"center","actors":[{"type":"collapse","grid":{"width":3,"height":4},"orientation":"vertical","direction":"positive","actors":[{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["a","a",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["b","b",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["c","c",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["a","b","c"]}}]},{"type":"collapse","grid":{"width":3,"height":4},"orientation":"vertical","direction":"negative","actors":[{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["d","d",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["e","e",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["f","f",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["d","e","f"]}}]},{"type":"collapse","grid":{"width":3,"height":4},"orientation":"vertical","direction":"center","actors":[{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["a","a",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["b","b",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["c","c",null]}},{"type":"disappearing-shelf","shelf":{"type":"shelf","products":["a","b","c"]}}]}]}]}]},{"name":"test-8-display-shelf","type":"json","args":[{"id":"test-8-display-shelf","name":"Test 8: Display Shelf","description":"","grid":{"width":3,"height":3},"actors":[{"gridPosition":{"x":0,"y":0},"offset":{"x":-0.1,"y":0},"type":"display-shelf","allowed":["a","b","c"],"products":[null,null,null]},{"gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","b","c"],"ignore":true},{"gridPosition":{"x":0,"y":2},"type":"shelf","products":["d",null,null],"ignore":true}]}]},{"name":"test-9-locking-shelf","type":"json","args":[{"id":"test-9-locking-shelf","name":"Test 9: Locking Shelf","description":"","grid":{"width":3,"height":5},"actors":[{"gridPosition":{"x":0,"y":0},"offset":{"x":-0.1,"y":0},"type":"locking-shelf","locking":{"mode":"toggle-timer","time":10,"initiallyLocked":true},"shelf":{"type":"shelf","products":[null,null,null]}},{"gridPosition":{"x":0,"y":1},"type":"shelf","products":["a","b","c"]},{"gridPosition":{"x":0,"y":2},"type":"shelf","products":["d",null,null]}]}]}]');

/***/ }),

/***/ "./node_modules/@basementuniverse/camera/build/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@basementuniverse/camera/build/index.js ***!
  \**************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass Camera {\n    constructor(position, options) {\n        this.size = (0, vec_1.vec)();\n        this._actualPosition = (0, vec_1.vec)();\n        this.targetPosition = (0, vec_1.vec)();\n        this._actualScale = 1;\n        this.targetScale = 1;\n        this._actualPosition = position;\n        this.targetPosition = position;\n        this.options = Object.assign({}, Camera.defaultOptions, options !== null && options !== void 0 ? options : {});\n    }\n    get position() {\n        return this.targetPosition;\n    }\n    set position(value) {\n        this.targetPosition = value;\n    }\n    set positionImmediate(value) {\n        this._actualPosition = value;\n        this.targetPosition = value;\n    }\n    get actualPosition() {\n        return this._actualPosition;\n    }\n    get scale() {\n        return this.targetScale;\n    }\n    get actualScale() {\n        return this._actualScale;\n    }\n    set scale(value) {\n        this.targetScale = clamp(value, this.options.minScale, this.options.maxScale);\n    }\n    set scaleImmediate(value) {\n        this._actualScale = clamp(value, this.options.minScale, this.options.maxScale);\n        this.targetScale = this._actualScale;\n    }\n    /**\n     * Get screen bounds based on the current camera position and scale\n     */\n    get bounds() {\n        return {\n            top: this._actualPosition.y - (this.size.y / 2) / this._actualScale,\n            bottom: this._actualPosition.y + (this.size.y / 2) / this._actualScale,\n            left: this._actualPosition.x - (this.size.x / 2) / this._actualScale,\n            right: this._actualPosition.x + (this.size.x / 2) / this._actualScale\n        };\n    }\n    /**\n     * Convert a screen position to a world position\n     */\n    screenToWorld(position) {\n        const bounds = this.bounds;\n        return vec_1.vec.add({ x: bounds.left, y: bounds.top }, vec_1.vec.mul(position, 1 / this.actualScale));\n    }\n    /**\n     * Convert a world position to a screen position\n     */\n    worldToScreen(position) {\n        const bounds = this.bounds;\n        return vec_1.vec.mul(vec_1.vec.sub(position, { x: bounds.left, y: bounds.top }), this.actualScale);\n    }\n    /**\n     * Update the camera\n     */\n    update(screen) {\n        this.size = (0, vec_1.vec)(screen);\n        // Maybe clamp position to bounds\n        if (this.options.bounds) {\n            const screenScaled = vec_1.vec.map(vec_1.vec.mul(this.size, 1 / this._actualScale), Math.ceil);\n            // If the scaled screen size is larger than allowed bounds, we resize\n            // the bounds to prevent jittering\n            const actualBounds = {\n                ...this.options.bounds,\n            };\n            if (screenScaled.x > actualBounds.right - actualBounds.left) {\n                const boundsWidth = actualBounds.right - actualBounds.left;\n                const halfDiff = (screenScaled.x - boundsWidth) / 2;\n                actualBounds.left -= halfDiff;\n                actualBounds.right += halfDiff;\n            }\n            if (screenScaled.y > actualBounds.bottom - actualBounds.top) {\n                const boundsHeight = actualBounds.bottom - actualBounds.top;\n                const halfDiff = (screenScaled.y - boundsHeight) / 2;\n                actualBounds.top -= halfDiff;\n                actualBounds.bottom += halfDiff;\n            }\n            const halfScreenScaled = vec_1.vec.map(vec_1.vec.mul(screenScaled, 1 / 2), Math.ceil);\n            const minPosition = (0, vec_1.vec)(actualBounds.left + halfScreenScaled.x, actualBounds.top + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec)(actualBounds.right - halfScreenScaled.x, actualBounds.bottom - halfScreenScaled.y);\n            this.targetPosition.x = clamp(this.targetPosition.x, minPosition.x, maxPosition.x);\n            this.targetPosition.y = clamp(this.targetPosition.y, minPosition.y, maxPosition.y);\n        }\n        const d = vec_1.vec.sub(this._actualPosition, this.targetPosition);\n        this._actualPosition = vec_1.vec.add(this.position, vec_1.vec.mul(d, this.options.moveEaseAmount));\n        const s = clamp(this.targetScale, this.options.minScale, this.options.maxScale);\n        this._actualScale = s + (this._actualScale - s) * this.options.scaleEaseAmount;\n    }\n    /**\n     * Set the camera transforms on a canvas context\n     */\n    setTransforms(context) {\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.translate((this.size.x / 2) - this._actualPosition.x * this._actualScale, (this.size.y / 2) - this._actualPosition.y * this._actualScale);\n        context.scale(this._actualScale, this._actualScale);\n    }\n    /**\n     * Update the camera and then set transforms on a canvas context\n     */\n    draw(context, screen) {\n        this.update(screen);\n        this.setTransforms(context);\n    }\n}\nexports[\"default\"] = Camera;\nCamera.defaultOptions = {\n    allowScale: true,\n    minScale: 0.5,\n    maxScale: 4,\n    moveEaseAmount: 0.1,\n    scaleEaseAmount: 0.1,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/camera/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_26909__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_26909__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_26909__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/canvas-helpers/build/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@basementuniverse/canvas-helpers/build/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.withContext = withContext;\nexports.line = line;\nexports.cross = cross;\nexports.arrow = arrow;\nexports.circle = circle;\nexports.rectangle = rectangle;\nexports.polygon = polygon;\nexports.path = path;\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nconst DEFAULT_STYLE_OPTIONS = {\n    batch: false,\n    fill: false,\n    fillColor: null,\n    gradient: null,\n    stroke: true,\n    strokeColor: null,\n    lineWidth: 1,\n    lineStyle: 'solid',\n    lineDash: null,\n    crossStyle: 'x',\n    rounded: false,\n    arrow: {\n        type: 'caret',\n        size: 5,\n    },\n};\nconst DEFAULT_LINE_DASHES = {\n    solid: [],\n    dashed: [5, 5],\n    dotted: [1, 3],\n};\nconst BEZIER_MATRICES = {\n    1: (0, vec_1.mat)(2, 2, [-1, 1, 1, 0]),\n    2: (0, vec_1.mat)(3, 3, [1, -2, 1, -2, 2, 0, 1, 0, 0]),\n    3: (0, vec_1.mat)(4, 4, [-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0]),\n};\nconst BEZIER_COEFFICIENTS = (t, order) => ({\n    1: [t, 1],\n    2: [t * t, t, 1],\n    3: [t * t * t, t * t, t, 1],\n}[order]);\nconst CATMULL_ROM_BASIS_FUNCTIONS = [\n    (t, tension) => -tension * Math.pow(t, 3) + 2 * tension * Math.pow(t, 2) - tension * t,\n    (t, tension) => (2 - tension) * Math.pow(t, 3) + (tension - 3) * Math.pow(t, 2) + 1,\n    (t, tension) => (tension - 2) * Math.pow(t, 3) +\n        (3 - 2 * tension) * Math.pow(t, 2) +\n        tension * t,\n    (t, tension) => tension * Math.pow(t, 3) - tension * Math.pow(t, 2),\n];\nconst CATMULL_ROM_BASIS_VECTOR = (t, tension) => CATMULL_ROM_BASIS_FUNCTIONS.map(f => f(t, tension));\n/**\n * Type guard to check if a value is a Color object\n */\nfunction isColorObject(color) {\n    return (typeof color === 'object' &&\n        'r' in color &&\n        'g' in color &&\n        'b' in color &&\n        (typeof color.a === 'number' || !('a' in color)));\n}\n/**\n * Convert a color object to a string in the format \"rgba(r, g, b, a)\"\n */\nfunction colourToString(color) {\n    var _a;\n    return `rgba(${color.r}, ${color.g}, ${color.b}, ${(_a = color.a) !== null && _a !== void 0 ? _a : 1})`;\n}\n/**\n * Prepare a color value (string or Color object) for use in styles\n */\nfunction prepareColor(color) {\n    if (typeof color === 'string') {\n        // Assume it's already a valid CSS color string\n        return color;\n    }\n    else if (isColorObject(color)) {\n        // Convert Color object to CSS color string\n        return colourToString(color);\n    }\n    // If it's neither, default to black\n    return 'black';\n}\n/**\n * Prepare a gradient for use in styles\n *\n * Returns a CanvasGradient object or null if no gradient is specified\n */\nfunction prepareGradient(context, style) {\n    if (!style) {\n        return null;\n    }\n    let gradient;\n    if (style.type === 'linear') {\n        gradient = context.createLinearGradient(style.start.x, style.start.y, style.end.x, style.end.y);\n    }\n    else {\n        gradient = context.createRadialGradient(style.start.x, style.start.y, 0, style.start.x, style.start.y, vec_1.vec2.len(vec_1.vec2.sub(style.end, style.start)) / 2);\n    }\n    for (const stop of style.colorStops) {\n        gradient.addColorStop(stop.position, prepareColor(stop.color));\n    }\n    return gradient;\n}\n/**\n * Get a complete style object with default values filled in\n */\nfunction getStyle(style) {\n    var _a;\n    return Object.assign({}, DEFAULT_STYLE_OPTIONS, {\n        ...(style !== null && style !== void 0 ? style : {}),\n        lineDash: style && style.lineDash !== undefined\n            ? style.lineDash\n            : (style === null || style === void 0 ? void 0 : style.lineStyle) === undefined\n                ? []\n                : DEFAULT_LINE_DASHES[(_a = style.lineStyle) !== null && _a !== void 0 ? _a : 'solid'],\n    });\n}\n/**\n * Pass in a context and some number of functions that take a context as their\n * first argument, and return an array of functions that don't require the\n * context argument\n *\n * If only one function is passed, this will return a single function\n */\nfunction withContext(context, ...functions) {\n    const result = functions.map(f => {\n        return (...args) => {\n            f(context, ...args);\n        };\n    });\n    return result.length === 1 ? result[0] : result;\n}\n/**\n * Draw a straight line segment between two points\n */\nfunction line(context, start, end, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    // Stroke the path if required\n    // Additionally, if this is a batch operation, we don't stroke right away so\n    // that we can add more lines to the same path if we want\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a cross at a given position with a specified size\n */\nfunction cross(context, position, size, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple lines in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the cross\n    const halfSize = size / 2;\n    if (actualStyle.crossStyle === '+') {\n        // Plus sign cross\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n    }\n    else if (actualStyle.crossStyle === 'x') {\n        // X cross\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw an arrow from a start point to an end point with an optional arrowhead\n * at the end\n *\n * This function does not support batch drawing since it requires\n * beginning a new path for the arrowhead\n */\nfunction arrow(context, start, end, style) {\n    var _a;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // Arrows don't support batch drawing since we have to begin a new path\n    // when drawing the arrowhead\n    context.beginPath();\n    // Draw the line segment\n    context.moveTo(start.x, start.y);\n    context.lineTo(end.x, end.y);\n    context.stroke();\n    // Draw the arrowhead if specified\n    if (actualStyle.arrow) {\n        const arrowSize = (_a = actualStyle.arrow.size) !== null && _a !== void 0 ? _a : 10;\n        const halfSize = arrowSize / 2;\n        const angle = vec_1.vec2.rad(vec_1.vec2.sub(end, start));\n        const arrowType = actualStyle.arrow.type;\n        context.save();\n        context.translate(end.x, end.y);\n        context.rotate(angle);\n        if (typeof arrowType === 'function') {\n            arrowType(context, arrowSize);\n        }\n        else if (arrowType === 'caret') {\n            if (actualStyle.strokeColor !== null) {\n                context.fillStyle = prepareColor(actualStyle.strokeColor);\n            }\n            context.beginPath();\n            context.moveTo(0, -halfSize);\n            context.lineTo(arrowSize, 0);\n            context.lineTo(0, halfSize);\n            context.closePath();\n            context.fill();\n        }\n        else if (arrowType === 'chevron') {\n            context.beginPath();\n            context.moveTo(-halfSize, -halfSize);\n            context.lineTo(0, 0);\n            context.lineTo(-halfSize, halfSize);\n            context.stroke();\n        }\n        context.restore();\n    }\n    context.restore();\n}\n/**\n * Draw a circle at a specified center point with a given radius\n */\nfunction circle(context, center, radius, style) {\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the circle\n    context.arc(center.x, center.y, radius, 0, Math.PI * 2);\n    // Fill the circle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the circle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a rectangle at a specified position with a given size\n */\nfunction rectangle(context, position, size, style) {\n    var _a;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the rectangle\n    if (actualStyle.rounded) {\n        context.roundRect(position.x, position.y, size.x, size.y, (_a = actualStyle.borderRadius) !== null && _a !== void 0 ? _a : 1);\n    }\n    else {\n        context.rect(position.x, position.y, size.x, size.y);\n    }\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a polygon defined by an array of vertices\n */\nfunction polygon(context, vertices, style) {\n    if (vertices.length < 3) {\n        return;\n    }\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.fillColor !== null) {\n        context.fillStyle = prepareColor(actualStyle.fillColor);\n    }\n    if (actualStyle.gradient) {\n        const gradient = prepareGradient(context, actualStyle.gradient);\n        if (gradient) {\n            context.fillStyle = gradient;\n        }\n    }\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path so we can add to any\n    // existing path and draw multiple shapes in one go\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Draw the polygon path\n    context.moveTo(vertices[0].x, vertices[0].y);\n    for (let i = 1; i < vertices.length; i++) {\n        context.lineTo(vertices[i].x, vertices[i].y);\n    }\n    context.closePath();\n    // Fill the rectangle if required\n    if (actualStyle.fill && !actualStyle.batch) {\n        context.fill();\n    }\n    // Stroke the rectangle if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n/**\n * Draw a path defined by an array of vertices\n */\nfunction path(context, vertices, style) {\n    var _a, _b, _c;\n    if (vertices.length < 2)\n        return;\n    context.save();\n    // Apply styles\n    const actualStyle = getStyle(style);\n    if (actualStyle.strokeColor !== null) {\n        context.strokeStyle = prepareColor(actualStyle.strokeColor);\n    }\n    if (actualStyle.lineWidth !== null) {\n        context.lineWidth = actualStyle.lineWidth;\n    }\n    if (actualStyle.lineDash !== null) {\n        context.setLineDash(actualStyle.lineDash);\n    }\n    // If this is a batch operation, don't begin a new path\n    if (!actualStyle.batch) {\n        context.beginPath();\n    }\n    // Handle different path types\n    const pathType = (_a = actualStyle.pathType) !== null && _a !== void 0 ? _a : 'linear';\n    if (pathType === 'linear') {\n        // Simple linear path\n        context.moveTo(vertices[0].x, vertices[0].y);\n        for (let i = 1; i < vertices.length; i++) {\n            context.lineTo(vertices[i].x, vertices[i].y);\n        }\n    }\n    else if (pathType === 'bezier') {\n        const order = (0, utils_1.clamp)((_b = actualStyle.bezierOrder) !== null && _b !== void 0 ? _b : 3, 1, 3);\n        // Draw bezier curve segments\n        const segmentSize = order + 1;\n        for (let i = 0; i + segmentSize <= vertices.length; i += order) {\n            const segmentPoints = vertices.slice(i, i + segmentSize);\n            // Draw first point of segment\n            if (i === 0) {\n                context.moveTo(segmentPoints[0].x, segmentPoints[0].y);\n            }\n            // Draw bezier curve through points\n            for (let t = 0; t <= 1; t += 0.01) {\n                const q = vec_1.mat.mulv(BEZIER_MATRICES[order], BEZIER_COEFFICIENTS(t, order));\n                if (q === false) {\n                    context.restore();\n                    return;\n                }\n                let p = (0, vec_1.vec2)();\n                for (let j = 0; j < segmentSize; j++) {\n                    p.x += segmentPoints[j].x * q[j];\n                    p.y += segmentPoints[j].y * q[j];\n                }\n                context.lineTo(p.x, p.y);\n            }\n        }\n    }\n    else if (pathType === 'catmull-rom') {\n        const tension = (_c = actualStyle.catmullRomTension) !== null && _c !== void 0 ? _c : 0.5;\n        // Need at least 4 points for Catmull-Rom\n        if (vertices.length >= 4) {\n            context.moveTo(vertices[1].x, vertices[1].y);\n            // Draw curve segments\n            for (let i = 1; i < vertices.length - 2; i++) {\n                const points = [\n                    vertices[i - 1],\n                    vertices[i],\n                    vertices[i + 1],\n                    vertices[i + 2],\n                ];\n                for (let t = 0; t <= 1; t += 0.01) {\n                    const x = (0, utils_1.dot)(points.map(p => p.x), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    const y = (0, utils_1.dot)(points.map(p => p.y), CATMULL_ROM_BASIS_VECTOR(t, tension));\n                    context.lineTo(x, y);\n                }\n            }\n        }\n        else {\n            // Fall back to linear if not enough points\n            context.moveTo(vertices[0].x, vertices[0].y);\n            for (let i = 1; i < vertices.length; i++) {\n                context.lineTo(vertices[i].x, vertices[i].y);\n            }\n        }\n    }\n    // Stroke the path if required\n    if (actualStyle.stroke && !actualStyle.batch) {\n        context.stroke();\n    }\n    context.restore();\n}\n\n\n//# sourceURL=webpack://@basementuniverse/canvas-helpers/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_60904__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_60904__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_60904__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/content-manager/build/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@basementuniverse/content-manager/build/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content-loaders/audio.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/audio.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AudioLoader = void 0;\nconst AudioLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const audio = new Audio(url);\n        audio.addEventListener('loadeddata', () => {\n            resolve(audio);\n        });\n        audio.addEventListener('error', () => {\n            reject(`Error loading audio \"${url}\"`);\n        });\n    });\n};\nexports.AudioLoader = AudioLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/audio.loader.ts?");

/***/ }),

/***/ "./content-loaders/font.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/font.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FontLoader = void 0;\nconst FontLoader = async (url, family) => {\n    return new Promise((resolve, reject) => {\n        const font = new FontFace(family, `url(${url})`);\n        font.load()\n            .then(font => {\n            document.fonts.add(font);\n            resolve(font);\n        })\n            .catch(() => {\n            reject(`Error loading font \"${url}\"`);\n        });\n    });\n};\nexports.FontLoader = FontLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/font.loader.ts?");

/***/ }),

/***/ "./content-loaders/image.loader.ts":
/*!*****************************************!*\
  !*** ./content-loaders/image.loader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageLoader = void 0;\nconst ImageLoader = async (url) => {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.src = url;\n        image.addEventListener('load', () => {\n            resolve(image);\n        });\n        image.addEventListener('error', () => {\n            reject(`Error loading image \"${url}\"`);\n        });\n    });\n};\nexports.ImageLoader = ImageLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/image.loader.ts?");

/***/ }),

/***/ "./content-loaders/index.ts":
/*!**********************************!*\
  !*** ./content-loaders/index.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./audio.loader */ \"./content-loaders/audio.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./font.loader */ \"./content-loaders/font.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./image.loader */ \"./content-loaders/image.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./json.loader */ \"./content-loaders/json.loader.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./text.loader */ \"./content-loaders/text.loader.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/index.ts?");

/***/ }),

/***/ "./content-loaders/json.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/json.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONLoader = void 0;\nconst JSONLoader = async (urlOrData) => {\n    if (typeof urlOrData === 'string' &&\n        urlOrData.startsWith('http')) {\n        return new Promise((resolve, reject) => {\n            window.fetch(urlOrData, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'application/json;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.json();\n            })\n                .then(json => {\n                resolve(json);\n            })\n                .catch(() => {\n                reject(`Error loading json \"${urlOrData}\"`);\n            });\n        });\n    }\n    return urlOrData;\n};\nexports.JSONLoader = JSONLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/json.loader.ts?");

/***/ }),

/***/ "./content-loaders/text.loader.ts":
/*!****************************************!*\
  !*** ./content-loaders/text.loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextLoader = void 0;\nconst TextLoader = async (urlOrText) => {\n    if (urlOrText.startsWith('http')) {\n        return new Promise((resolve, reject) => {\n            window.fetch(urlOrText, {\n                method: 'GET',\n                headers: {\n                    'content-type': 'text/plain;charset=UTF-8',\n                },\n            })\n                .then(response => {\n                return response.text();\n            })\n                .then(data => {\n                resolve(data);\n            })\n                .catch(() => {\n                reject(`Error loading text \"${urlOrText}\"`);\n            });\n        });\n    }\n    return urlOrText.toString();\n};\nexports.TextLoader = TextLoader;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-loaders/text.loader.ts?");

/***/ }),

/***/ "./content-processors/image-name.processor.ts":
/*!****************************************************!*\
  !*** ./content-processors/image-name.processor.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageNameProcessor = void 0;\nconst defaultOptions = {\n    imageNameFieldName: 'imageName',\n    imageFieldName: 'image',\n};\nconst ImageNameProcessor = async (content, item, options) => {\n    const actualOptions = Object.assign({}, defaultOptions, options !== null && options !== void 0 ? options : {});\n    if (typeof item.content === 'object' &&\n        item.content !== null) {\n        const processObject = (o) => {\n            var _a;\n            for (const key in o) {\n                if (key === actualOptions.imageNameFieldName) {\n                    const imageName = o[key];\n                    const imageItem = (_a = content[imageName]) === null || _a === void 0 ? void 0 : _a.content;\n                    if (imageItem) {\n                        o[actualOptions.imageFieldName] = imageItem;\n                        delete o[key];\n                    }\n                }\n                else if (typeof o[key] === 'object' &&\n                    o[key] !== null) {\n                    processObject(o[key]);\n                }\n            }\n        };\n        processObject(item.content);\n    }\n};\nexports.ImageNameProcessor = ImageNameProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/image-name.processor.ts?");

/***/ }),

/***/ "./content-processors/index.ts":
/*!*************************************!*\
  !*** ./content-processors/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./image-name.processor */ \"./content-processors/image-name.processor.ts\"), exports);\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./content-processors/index.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentItemStatus = exports.ContentManagerStatus = exports.ContentItemType = void 0;\nconst content_loaders_1 = __webpack_require__(/*! ./content-loaders */ \"./content-loaders/index.ts\");\nconst content_processors_1 = __webpack_require__(/*! ./content-processors */ \"./content-processors/index.ts\");\nvar ContentItemType;\n(function (ContentItemType) {\n    ContentItemType[\"JSON\"] = \"json\";\n    ContentItemType[\"Font\"] = \"font\";\n    ContentItemType[\"Image\"] = \"image\";\n    ContentItemType[\"Audio\"] = \"audio\";\n    ContentItemType[\"Text\"] = \"text\";\n})(ContentItemType = exports.ContentItemType || (exports.ContentItemType = {}));\nvar ContentManagerStatus;\n(function (ContentManagerStatus) {\n    ContentManagerStatus[\"Idle\"] = \"idle\";\n    ContentManagerStatus[\"Loading\"] = \"loading\";\n    ContentManagerStatus[\"Processing\"] = \"processing\";\n    ContentManagerStatus[\"Ready\"] = \"ready\";\n})(ContentManagerStatus = exports.ContentManagerStatus || (exports.ContentManagerStatus = {}));\nvar ContentItemStatus;\n(function (ContentItemStatus) {\n    ContentItemStatus[\"Idle\"] = \"idle\";\n    ContentItemStatus[\"Loading\"] = \"loading\";\n    ContentItemStatus[\"Loaded\"] = \"loaded\";\n    ContentItemStatus[\"Processing\"] = \"processing\";\n    ContentItemStatus[\"Processed\"] = \"processed\";\n})(ContentItemStatus = exports.ContentItemStatus || (exports.ContentItemStatus = {}));\nconst defaultContentLoaders = {\n    [ContentItemType.JSON]: content_loaders_1.JSONLoader,\n    [ContentItemType.Font]: content_loaders_1.FontLoader,\n    [ContentItemType.Image]: content_loaders_1.ImageLoader,\n    [ContentItemType.Audio]: content_loaders_1.AudioLoader,\n    [ContentItemType.Text]: content_loaders_1.TextLoader,\n};\nconst defaultContentProcessors = {\n    imageName: content_processors_1.ImageNameProcessor,\n};\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nfunction randomBetween(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst MIN_SLEEP_TIME = 1000;\nconst MAX_SLEEP_TIME = 3000;\nclass ContentManager {\n    constructor(options) {\n        var _a, _b, _c;\n        this.currentContentList = [];\n        this.currentProgress = 0;\n        this.currentTotalProgress = 0;\n        this.content = {};\n        this.status = ContentManagerStatus.Idle;\n        this.options = Object.assign({}, ContentManager.defaultOptions, options !== null && options !== void 0 ? options : {}, {\n            loaders: {\n                ...ContentManager.defaultOptions.loaders,\n                ...((_a = options === null || options === void 0 ? void 0 : options.loaders) !== null && _a !== void 0 ? _a : {}),\n            },\n            processors: {\n                ...((_b = ContentManager.defaultOptions.processors) !== null && _b !== void 0 ? _b : {}),\n                ...((_c = options === null || options === void 0 ? void 0 : options.processors) !== null && _c !== void 0 ? _c : {}),\n            },\n        });\n    }\n    /**\n     * Initialise the content manager and provide configuration options\n     */\n    static initialise(options) {\n        if (ContentManager.instance !== undefined) {\n            throw new Error('Content manager already initialised');\n        }\n        ContentManager.instance = new ContentManager(options);\n    }\n    static dispose() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not initialised');\n        }\n        delete ContentManager.instance;\n    }\n    static getInstance() {\n        if (ContentManager.instance === undefined) {\n            throw new Error('Content manager not properly initialised');\n        }\n        return ContentManager.instance;\n    }\n    /**\n     * Current loading progress, represented as a unit scalar [0, 1]\n     */\n    static get progress() {\n        const instance = ContentManager.getInstance();\n        return instance.getProgress();\n    }\n    /**\n     * Current content manager status\n     */\n    static get status() {\n        const instance = ContentManager.getInstance();\n        return instance.status;\n    }\n    getProgress() {\n        if (!this.currentContentList.length || this.currentTotalProgress === 0) {\n            return 1;\n        }\n        return clamp(this.currentProgress / this.currentTotalProgress);\n    }\n    /**\n     * Load content items\n     *\n     * Existing content items will be retained, and any content items which\n     * already exist will be re-loaded\n     */\n    static async load(items) {\n        var _a, _b, _c, _d, _e;\n        if (!items || items.length === 0) {\n            return;\n        }\n        const instance = ContentManager.getInstance();\n        if (!instance.options.loaders ||\n            Object.keys(instance.options.loaders).length === 0) {\n            throw new Error('No content loaders defined');\n        }\n        instance.currentContentList = items;\n        // Calculate how many tasks we need to perform\n        const countTotalToLoad = items.length;\n        const countTotalToProcess = items.reduce((a, c) => { var _a; return a + ((_a = c.processors) !== null && _a !== void 0 ? _a : []).length; }, 0);\n        instance.currentProgress = 0;\n        instance.currentTotalProgress = countTotalToLoad + countTotalToProcess;\n        // Load items\n        instance.status = ContentManagerStatus.Loading;\n        for (const item of items) {\n            if (!(item.type in instance.options.loaders)) {\n                throw new Error(`No content loader defined for type \"${item.type}\"`);\n            }\n            if (instance.options.simulateSlowLoading) {\n                await sleep(randomBetween((_a = instance.options.slowLoadingTimeMin) !== null && _a !== void 0 ? _a : MIN_SLEEP_TIME, (_b = instance.options.slowLoadingTimeMax) !== null && _b !== void 0 ? _b : MAX_SLEEP_TIME));\n            }\n            const contentItem = {\n                name: item.name,\n                type: item.type,\n                content: null,\n                status: ContentItemStatus.Loading,\n            };\n            instance.content[item.name] = contentItem;\n            contentItem.content = await instance.options.loaders[item.type](...item.args);\n            contentItem.status = ContentItemStatus.Loaded;\n            instance.currentProgress++;\n        }\n        // Process items\n        instance.status = ContentManagerStatus.Processing;\n        for (const item of items) {\n            if (!item.processors || item.processors.length === 0) {\n                continue;\n            }\n            if (!instance.options.processors ||\n                Object.keys(instance.options.processors).length === 0) {\n                throw new Error('No content processors defined');\n            }\n            const contentItem = instance.content[item.name];\n            if (!contentItem) {\n                // We should never reach this point; the item will have been loaded\n                // and added to the instance's content dictionary... but just in case\n                throw new Error(`Cannot find item with name \"${item.name}\"`);\n            }\n            if (instance.options.simulateSlowProcessing) {\n                await sleep(randomBetween((_c = instance.options.slowProcessingTimeMin) !== null && _c !== void 0 ? _c : MIN_SLEEP_TIME, (_d = instance.options.slowProcessingTimeMax) !== null && _d !== void 0 ? _d : MAX_SLEEP_TIME));\n            }\n            contentItem.status = ContentItemStatus.Processing;\n            for (const processor of item.processors) {\n                if (!(processor.name in instance.options.processors)) {\n                    throw new Error(`No content processor defined with name \"${processor.name}\"`);\n                }\n                await instance.options.processors[processor.name](instance.content, contentItem, ...((_e = processor.args) !== null && _e !== void 0 ? _e : []));\n                instance.currentProgress++;\n            }\n            contentItem.status = ContentItemStatus.Processed;\n        }\n        instance.status = ContentManagerStatus.Ready;\n    }\n    /**\n     * Retrieve a content item by name\n     */\n    static get(name) {\n        const instance = ContentManager.getInstance();\n        if (!(name in instance.content)) {\n            if (instance.options.throwOnNotFound) {\n                throw new Error(`Content item \"${name}\" not found`);\n            }\n            return undefined;\n        }\n        return instance.content[name].content;\n    }\n}\nexports[\"default\"] = ContentManager;\nContentManager.defaultOptions = {\n    loaders: defaultContentLoaders,\n    processors: defaultContentProcessors,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/content-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_19914__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_19914__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_19914__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/debug/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@basementuniverse/debug/build/index.js ***!
  \*************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nclass Debug {\n    constructor(options) {\n        if (options === null || options === void 0 ? void 0 : options.defaultValue) {\n            options.defaultValue = Object.assign({}, Debug.defaultOptions.defaultValue, options.defaultValue);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultChart) {\n            options.defaultChart = Object.assign({}, Debug.defaultOptions.defaultChart, options.defaultChart);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultMarker) {\n            options.defaultMarker = Object.assign({}, Debug.defaultOptions.defaultMarker, options.defaultMarker);\n        }\n        if (options === null || options === void 0 ? void 0 : options.defaultBorder) {\n            options.defaultBorder = Object.assign({}, Debug.defaultOptions.defaultBorder, options.defaultBorder);\n        }\n        this.options = Object.assign({}, Debug.defaultOptions, options !== null && options !== void 0 ? options : {});\n        this.values = new Map();\n        this.charts = new Map();\n        this.markers = new Map();\n        this.borders = new Map();\n    }\n    /**\n     * Initialise the debug renderer for displaying values and markers\n     */\n    static initialise(options = {}) {\n        if (Debug.instance !== undefined) {\n            throw new Error('Debug has already been initialised');\n        }\n        Debug.instance = new Debug(options);\n    }\n    static getInstance() {\n        if (Debug.instance === undefined) {\n            throw new Error('Debug not properly initialised');\n        }\n        return Debug.instance;\n    }\n    /**\n     * Show a debug value\n     */\n    static value(label, value, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.values.set(label, Object.assign({}, instance.options.defaultValue, (_a = instance.values.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value }));\n    }\n    /**\n     * Show a debug chart\n     */\n    static chart(label, value, options) {\n        var _a, _b;\n        const instance = Debug.getInstance();\n        const currentChart = instance.charts.get(label);\n        instance.charts.set(label, Object.assign({}, instance.options.defaultChart, currentChart !== null && currentChart !== void 0 ? currentChart : {}, options !== null && options !== void 0 ? options : {}, {\n            label,\n            values: [...(_a = currentChart === null || currentChart === void 0 ? void 0 : currentChart.values) !== null && _a !== void 0 ? _a : [], value].slice(-((_b = options === null || options === void 0 ? void 0 : options.valueBufferSize) !== null && _b !== void 0 ? _b : instance.options.defaultChart.valueBufferSize)),\n        }));\n    }\n    /**\n     * Remove a debug chart\n     */\n    static removeChart(label) {\n        const instance = Debug.getInstance();\n        instance.charts.delete(label);\n    }\n    /**\n     * Show a marker in world or screen space\n     */\n    static marker(label, value, position, options) {\n        var _a;\n        const instance = Debug.getInstance();\n        instance.markers.set(label, Object.assign({}, instance.options.defaultMarker, (_a = instance.markers.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Show a border in world or screen space\n     */\n    static border(label, value, position, options) {\n        var _a;\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) === 'circle' && (options === null || options === void 0 ? void 0 : options.radius) === undefined) {\n            // Don't add the border if it's circular but we don't have a radius\n            return;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.borderShape) !== 'circle' && (options === null || options === void 0 ? void 0 : options.size) === undefined) {\n            // Don't add the border if it's rectangular (default is rectangular) but\n            // we don't have a size\n            return;\n        }\n        const instance = Debug.getInstance();\n        instance.borders.set(label, Object.assign({}, instance.options.defaultBorder, (_a = instance.borders.get(label)) !== null && _a !== void 0 ? _a : {}, options !== null && options !== void 0 ? options : {}, { label, value, position }));\n    }\n    /**\n     * Render the debug values and markers onto a canvas\n     */\n    static draw(context, tags, clear = true) {\n        const instance = Debug.getInstance();\n        // Draw world-space markers & borders\n        context.save();\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'world') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'world') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Draw values, charts and screen-space markers & borders\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        let position;\n        let leftY = instance.options.margin;\n        let rightY = instance.options.margin;\n        const lineHeight = (instance.options.lineHeight +\n            instance.options.padding * 2);\n        instance.values.forEach(value => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (tags && !((_a = value.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (value.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawLabel(context, Debug.prepareLabel((_b = value.label) !== null && _b !== void 0 ? _b : '', (_c = value.value) !== null && _c !== void 0 ? _c : '', value.showLabel, true), position, value.align, (_d = value.padding) !== null && _d !== void 0 ? _d : instance.options.padding, (_e = value.font) !== null && _e !== void 0 ? _e : instance.options.font, (_f = value.foregroundColour) !== null && _f !== void 0 ? _f : instance.options.foregroundColour, (_g = value.backgroundColour) !== null && _g !== void 0 ? _g : instance.options.backgroundColour);\n        });\n        instance.charts.forEach(chart => {\n            var _a, _b, _c, _d, _e, _f;\n            if (tags && !((_a = chart.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            switch (chart.align) {\n                case 'left':\n                    position = (0, vec_1.vec)(instance.options.margin, leftY);\n                    leftY += lineHeight + instance.options.lineMargin;\n                    break;\n                case 'right':\n                    position = (0, vec_1.vec)(context.canvas.clientWidth - instance.options.margin, rightY);\n                    rightY += lineHeight + instance.options.lineMargin;\n                    break;\n            }\n            instance.drawChart(context, Debug.prepareLabel((_b = chart.label) !== null && _b !== void 0 ? _b : '', '', chart.showLabel, false), position, chart.align, (_c = chart.padding) !== null && _c !== void 0 ? _c : instance.options.padding, (_d = chart.font) !== null && _d !== void 0 ? _d : instance.options.font, (_e = chart.foregroundColour) !== null && _e !== void 0 ? _e : instance.options.foregroundColour, (_f = chart.backgroundColour) !== null && _f !== void 0 ? _f : instance.options.backgroundColour, chart.chartBackgroundColour, chart.values, chart.valueBufferSize, chart.valueBufferStride, chart.minValue, chart.maxValue, chart.barWidth, chart.barColours);\n        });\n        instance.markers.forEach(marker => {\n            var _a;\n            if (tags && !((_a = marker.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (marker.space === 'screen') {\n                instance.drawMarker(context, marker);\n            }\n        });\n        instance.borders.forEach(border => {\n            var _a;\n            if (tags && !((_a = border.tags) === null || _a === void 0 ? void 0 : _a.some(tag => tags.includes(tag)))) {\n                return;\n            }\n            if (border.space === 'screen') {\n                instance.drawBorder(context, border);\n            }\n        });\n        context.restore();\n        // Clear values, markers & borders ready for next frame\n        if (clear) {\n            instance.values.clear();\n            instance.markers.clear();\n            instance.borders.clear();\n        }\n    }\n    static clear(clearCharts = false) {\n        const instance = Debug.getInstance();\n        instance.values.clear();\n        instance.markers.clear();\n        if (clearCharts) {\n            instance.charts.clear();\n        }\n        instance.borders.clear();\n    }\n    static prepareLabel(label, value, showLabel, showValue) {\n        const actualLabel = (showLabel && label) ? label : '';\n        const actualValue = (!!showValue && value !== '') ? value.toString() : '';\n        const separator = (actualLabel && actualValue) ? ': ' : '';\n        return `${actualLabel}${separator}${actualValue}`;\n    }\n    drawLabel(context, text, position, align, padding, font, foregroundColour, backgroundColour) {\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const backgroundSize = {\n            width: context.measureText(text).width + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw text\n        context.fillStyle = foregroundColour;\n        context.fillText(text, x, position.y);\n        context.restore();\n    }\n    drawChart(context, label, position, align, padding, font, foregroundColour, backgroundColour, chartBackgroundColour, values, valueBufferSize, valueBufferStride, minValue, maxValue, barWidth, barColours) {\n        var _a, _b;\n        context.save();\n        context.font = font;\n        context.textBaseline = 'top';\n        const chartSize = {\n            width: barWidth * Math.ceil(valueBufferSize / Math.max(valueBufferStride, 1)),\n            height: this.options.lineHeight + padding * 2,\n        };\n        const labelSize = {\n            width: context.measureText(label).width,\n            height: this.options.lineHeight,\n        };\n        const backgroundSize = {\n            width: (labelSize.width +\n                padding +\n                chartSize.width) + padding * 2,\n            height: this.options.lineHeight + padding * 2,\n        };\n        const x = align === 'right'\n            ? (position.x - backgroundSize.width)\n            : position.x;\n        // Draw background\n        context.fillStyle = backgroundColour;\n        context.fillRect(x - padding, position.y - padding, backgroundSize.width, backgroundSize.height);\n        // Draw label\n        if (label) {\n            context.fillStyle = foregroundColour;\n            context.fillText(label, x, position.y);\n        }\n        // Draw chart\n        if (chartBackgroundColour) {\n            context.fillStyle = chartBackgroundColour;\n            context.fillRect(x + padding + labelSize.width + padding, position.y - padding, chartSize.width, chartSize.height);\n        }\n        const range = maxValue - minValue;\n        const barOffset = (0, vec_1.vec)(x + padding + labelSize.width + padding, position.y - padding);\n        for (let i = 0; i < Math.ceil(values.length / Math.max(valueBufferStride, 1)); i++) {\n            let value;\n            if (valueBufferStride <= 1) {\n                value = values[i];\n            }\n            else {\n                value = values\n                    .slice(i * valueBufferStride, (i + 1) * valueBufferStride)\n                    .reduce((a, b) => a + b, 0) / valueBufferStride;\n            }\n            const barSize = (0, vec_1.vec)(barWidth, Math.round(chartSize.height * (value - minValue) / range));\n            const barPosition = vec_1.vec.add(barOffset, (0, vec_1.vec)((values.length < valueBufferSize\n                ? Math.ceil((valueBufferSize - values.length) / valueBufferStride) * barWidth\n                : 0) + i * barWidth, chartSize.height - barSize.y));\n            const barColour = (_b = (barColours\n                ? (_a = [...barColours].reverse().find(c => values[i] >= c.offset)) === null || _a === void 0 ? void 0 : _a.colour\n                : undefined)) !== null && _b !== void 0 ? _b : foregroundColour;\n            context.fillStyle = barColour;\n            context.fillRect(barPosition.x, barPosition.y, barSize.x, barSize.y);\n        }\n        context.restore();\n    }\n    drawMarker(context, marker) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = marker.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (marker.showLabel || marker.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = marker.label) !== null && _b !== void 0 ? _b : '', (_c = marker.value) !== null && _c !== void 0 ? _c : '', marker.showLabel, marker.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), marker.labelOffset), 'left', (_d = marker.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = marker.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = marker.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = marker.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (marker.showMarker) {\n            if (marker.markerImage) {\n                context.drawImage(marker.markerImage, position.x - marker.markerImage.width / 2, position.y - marker.markerImage.height / 2);\n            }\n            else {\n                context.lineWidth = marker.markerLineWidth;\n                context.strokeStyle = context.fillStyle = marker.markerColour;\n                switch (marker.markerStyle) {\n                    case 'x':\n                        this.drawCross(context, position, marker.markerSize);\n                        break;\n                    case '+':\n                        this.drawPlus(context, position, marker.markerSize);\n                        break;\n                    case '.':\n                        this.drawDot(context, position, marker.markerSize);\n                        break;\n                }\n            }\n        }\n        context.restore();\n    }\n    drawCross(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n    }\n    drawPlus(context, position, size) {\n        context.beginPath();\n        const halfSize = size / 2;\n        context.moveTo(position.x, position.y - halfSize);\n        context.lineTo(position.x, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y);\n        context.lineTo(position.x + halfSize, position.y);\n        context.stroke();\n    }\n    drawDot(context, position, size) {\n        context.beginPath();\n        context.arc(position.x, position.y, size / 2, 0, Math.PI * 2);\n        context.fill();\n    }\n    drawBorder(context, border) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        context.save();\n        const position = (_a = border.position) !== null && _a !== void 0 ? _a : (0, vec_1.vec)();\n        if (border.showLabel || border.showValue) {\n            this.drawLabel(context, Debug.prepareLabel((_b = border.label) !== null && _b !== void 0 ? _b : '', (_c = border.value) !== null && _c !== void 0 ? _c : '', border.showLabel, border.showValue), vec_1.vec.add(position !== null && position !== void 0 ? position : (0, vec_1.vec)(), border.labelOffset), 'left', (_d = border.padding) !== null && _d !== void 0 ? _d : this.options.padding, (_e = border.font) !== null && _e !== void 0 ? _e : this.options.font, (_f = border.foregroundColour) !== null && _f !== void 0 ? _f : this.options.foregroundColour, (_g = border.backgroundColour) !== null && _g !== void 0 ? _g : this.options.backgroundColour);\n        }\n        if (border.showBorder) {\n            context.lineWidth = border.borderWidth;\n            context.strokeStyle = context.fillStyle = border.borderColour;\n            switch (border.borderStyle) {\n                case 'solid':\n                    context.setLineDash([]);\n                    break;\n                case 'dashed':\n                    context.setLineDash([border.borderDashSize, border.borderDashSize]);\n                    break;\n                case 'dotted':\n                    context.setLineDash([border.borderWidth, border.borderWidth]);\n                    break;\n            }\n            switch (border.borderShape) {\n                case 'rectangle':\n                    if (border.size) {\n                        this.drawRectangle(context, position, border.size);\n                    }\n                    break;\n                case 'circle':\n                    if (border.radius) {\n                        this.drawCircle(context, position, border.radius);\n                    }\n                    break;\n            }\n        }\n        context.restore();\n    }\n    drawRectangle(context, position, size) {\n        context.beginPath();\n        context.rect(position.x, position.y, size.x, size.y);\n        context.stroke();\n    }\n    drawCircle(context, position, radius) {\n        context.beginPath();\n        context.arc(position.x, position.y, radius, 0, Math.PI * 2);\n        context.stroke();\n    }\n}\nexports[\"default\"] = Debug;\nDebug.defaultOptions = {\n    margin: 10,\n    padding: 4,\n    font: '10pt Lucida Console, monospace',\n    lineHeight: 12,\n    lineMargin: 0,\n    foregroundColour: '#fff',\n    backgroundColour: '#333',\n    defaultValue: {\n        align: 'left',\n        showLabel: true,\n    },\n    defaultChart: {\n        values: [],\n        valueBufferSize: 60,\n        valueBufferStride: 1,\n        minValue: 0,\n        maxValue: 100,\n        barWidth: 2,\n        align: 'left',\n        showLabel: true,\n        chartBackgroundColour: '#222',\n    },\n    defaultMarker: {\n        showLabel: true,\n        showValue: true,\n        showMarker: true,\n        markerSize: 6,\n        markerLineWidth: 2,\n        markerStyle: 'x',\n        markerColour: '#ccc',\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n    defaultBorder: {\n        showLabel: true,\n        showValue: true,\n        showBorder: true,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderShape: 'rectangle',\n        borderColour: '#ccc',\n        borderDashSize: 5,\n        space: 'world',\n        labelOffset: (0, vec_1.vec)(10),\n    },\n};\n\n\n//# sourceURL=webpack://@basementuniverse/debug/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_42206__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_42206__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_42206__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/input-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/input-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback interpolationCallback\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {interpolationCallback} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst permutation = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst combination = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * A function for generating array values\n * @callback timesCallback\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {timesCallback} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    permutation,\n    combination,\n    times,\n    range,\n    zip,\n    at,\n    chunk,\n    shuffle,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MouseButton = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar MouseButton;\n(function (MouseButton) {\n    MouseButton[MouseButton[\"Left\"] = 0] = \"Left\";\n    MouseButton[MouseButton[\"Middle\"] = 1] = \"Middle\";\n    MouseButton[MouseButton[\"Right\"] = 2] = \"Right\";\n})(MouseButton = exports.MouseButton || (exports.MouseButton = {}));\nclass InputManager {\n    constructor(options) {\n        this.keyboardState = InputManager.initialKeyboardState();\n        this.previousKeyboardState = InputManager.initialKeyboardState();\n        this.mouseState = InputManager.initialMouseState();\n        this.previousMouseState = InputManager.initialMouseState();\n        this.options = Object.assign({}, InputManager.defaultOptions, options !== null && options !== void 0 ? options : {});\n        // Set up event handlers\n        if (this.options.mouse) {\n            this.options.element.addEventListener('mousedown', e => {\n                this.mouseState.buttons[e.button] = true;\n            });\n            this.options.element.addEventListener('mouseup', e => {\n                this.mouseState.buttons[e.button] = false;\n            });\n            this.options.element.addEventListener('touchstart', () => {\n                this.mouseState.buttons[0] = true;\n            });\n            this.options.element.addEventListener('touchend', () => {\n                this.mouseState.buttons[0] = false;\n            });\n            this.options.element.addEventListener('mousemove', e => {\n                this.mouseState.position.x = e.offsetX;\n                this.mouseState.position.y = e.offsetY;\n                this.mouseState.hoveredElement = e.target;\n            });\n            if (this.options.mouseWheel) {\n                window.addEventListener('wheel', e => {\n                    this.mouseState.wheel = e.deltaY > 0 ? 1 : -1;\n                });\n            }\n        }\n        if (this.options.keyboard) {\n            window.addEventListener('keydown', e => {\n                this.keyboardState[e.code] = true;\n            });\n            window.addEventListener('keyup', e => {\n                this.keyboardState[e.code] = false;\n            });\n        }\n        // Prevent the context menu from appearing on right-click\n        if (this.options.preventContextMenu) {\n            this.options.element.addEventListener('contextmenu', e => {\n                e.preventDefault();\n            });\n        }\n    }\n    /**\n     * Initialise the input manager for managing mouse and keyboard input\n     */\n    static initialise(options) {\n        if (InputManager.instance !== undefined) {\n            throw new Error('Input manager already initialised');\n        }\n        InputManager.instance = new InputManager(options);\n    }\n    static getInstance() {\n        if (InputManager.instance === undefined) {\n            throw new Error('Input manager not properly initialised');\n        }\n        return InputManager.instance;\n    }\n    static initialKeyboardState() {\n        return {};\n    }\n    static initialMouseState() {\n        return {\n            buttons: {\n                [MouseButton.Left]: false,\n                [MouseButton.Middle]: false,\n                [MouseButton.Right]: false,\n            },\n            position: (0, vec_1.vec)(),\n            wheel: 0,\n            hoveredElement: null,\n        };\n    }\n    static copyKeyboardState(state) {\n        return Object.assign({}, state);\n    }\n    static copyMouseState(state) {\n        return {\n            buttons: Object.assign({}, state.buttons),\n            position: vec_1.vec.cpy(state.position),\n            wheel: state.wheel,\n            hoveredElement: state.hoveredElement,\n        };\n    }\n    /**\n     * Update the state of the input devices\n     */\n    static update() {\n        const instance = InputManager.getInstance();\n        instance.previousKeyboardState = this.copyKeyboardState(instance.keyboardState);\n        instance.previousMouseState = this.copyMouseState(instance.mouseState);\n        instance.mouseState.wheel = 0;\n    }\n    /**\n     * Check if a key is currently pressed down\n     */\n    static keyDown(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key is down\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.keyboardState[code];\n    }\n    /**\n     * Check if a key has been pressed since the last frame\n     */\n    static keyPressed(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was pressed\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (instance.keyboardState[k] &&\n                    (!(k in instance.previousKeyboardState) ||\n                        !instance.previousKeyboardState[k])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.keyboardState[code] &&\n            !instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a key has been released since the last frame\n     */\n    static keyReleased(code) {\n        const instance = InputManager.getInstance();\n        // Check if any key was released\n        if (code === undefined) {\n            for (const k in instance.keyboardState) {\n                if (!instance.keyboardState[k] &&\n                    !!instance.previousKeyboardState[k]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.keyboardState[code] &&\n            !!instance.previousKeyboardState[code]);\n    }\n    /**\n     * Check if a mouse button is currently pressed down\n     */\n    static mouseDown(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button is down\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return !!instance.mouseState.buttons[button];\n    }\n    /**\n     * Check if a mouse button has been pressed since the last frame\n     */\n    static mousePressed(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was pressed\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (instance.mouseState.buttons[currentButton] &&\n                    (!(b in instance.previousMouseState.buttons) ||\n                        !instance.previousMouseState.buttons[currentButton])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!!instance.mouseState.buttons[button] &&\n            !instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if a mouse button has been released since the last frame\n     */\n    static mouseReleased(button) {\n        const instance = InputManager.getInstance();\n        // Check if any button was released\n        if (button === undefined) {\n            for (const b in instance.mouseState.buttons) {\n                const currentButton = +b;\n                if (!instance.mouseState.buttons[currentButton] &&\n                    !!instance.previousMouseState.buttons[currentButton]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return (!instance.mouseState.buttons[button] &&\n            !!instance.previousMouseState.buttons[button]);\n    }\n    /**\n     * Check if the mousewheel is scrolling up\n     */\n    static mouseWheelUp() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel > 0;\n    }\n    /**\n     * Check if the mousewheel is scrolling down\n     */\n    static mouseWheelDown() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.wheel < 0;\n    }\n    /**\n     * Get the current mouse position in screen-space\n     */\n    static get mousePosition() {\n        const instance = InputManager.getInstance();\n        return instance.mouseState.position;\n    }\n    /**\n     * Get the currently hovered element\n     */\n    static get hoveredElement() {\n        var _a;\n        const instance = InputManager.getInstance();\n        return (_a = instance.mouseState.hoveredElement) !== null && _a !== void 0 ? _a : null;\n    }\n}\nexports[\"default\"] = InputManager;\nInputManager.defaultOptions = {\n    element: window,\n    mouse: true,\n    mouseWheel: true,\n    keyboard: true,\n    preventContextMenu: false,\n};\n\n\n//# sourceURL=webpack://@basementuniverse/input-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_30860__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_30860__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_30860__("./index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js ***!
  \*******************************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Memoize a function
 * @param {Function} f The function to memoize
 * @returns {Function} A memoized version of the function
 */
const memoize = f => {
  var cache = {};
  return function(...args) {
    return cache[args] ?? (cache[args] = f.apply(this, args));
  };
};

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all permutations of r elements from an array
 *
 * @example
 * ```js
 * permutations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 1],
 *   [2, 3],
 *   [3, 1],
 *   [3, 2]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each permutation
 * @return {Array<Array<*>>} An array of permutation arrays
 */
const permutations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),
    ],
    []
  );
}

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {...Array<*>} a The arrays to zip
 * @return {Array<Array<*>>}
 */
const zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a The array to access
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Return the index for a given position in an unrolled 2d array
 * @param {number} x The x position
 * @param {number} y The y position
 * @param {number} w The width of the 2d array
 * @returns {number} The index in the unrolled array
 */
const ind = (x, y, w) => x + y * w;

/**
 * Return the position for a given index in an unrolled 2d array
 * @param {number} i The index
 * @param {number} w The width of the 2d array
 * @returns {Array<number>} The position as a 2-tuple
 */
const pos = (i, w) => [i % w, Math.floor(i / w)];

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    memoize,
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    permutations,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    ind,
    pos,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

const _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));
const _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));
const _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);
const _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;
const _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;

/**
 * A 2d vector
 * @typedef {Object} vec2
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new 2d vector
 * @param {number|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec2} A new 2d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec2(3, 2); // (3, 2)
 * let b = vec2(4);    // (4, 4)
 * let c = vec2(a);    // (3, 2)
 * let d = vec2();     // (0, 0)
 */
const vec2 = (x, y) => {
  if (!x && !y) {
    return { x: 0, y: 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0 };
  }
  return { x: x, y: y ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec2} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec2.components = a => [a.x, a.y];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec2} A new vector
 */
vec2.fromComponents = components => vec2(...components.slice(0, 2));

/**
 * Return a unit vector (1, 0)
 * @return {vec2} A unit vector (1, 0)
 */
vec2.ux = () => vec2(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec2} A unit vector (0, 1)
 */
vec2.uy = () => vec2(0, 1);

/**
 * Add vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a + b
 */
vec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });

/**
 * Subtract vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a - b
 */
vec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });

/**
 * Scale a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a * b
 */
vec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });

/**
 * Scale a vector by a scalar, alias for vec2.mul
 * @param {vec2} a Vector a
 * @param {number} b Scalar b
 * @return {vec2} a * b
 */
vec2.scale = (a, b) => vec2.mul(a, b);

/**
 * Divide a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a / b
 */
vec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });

/**
 * Get the length of a vector
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec2} a The vector to normalise
 * @return {vec2} ^a
 */
vec2.nor = a => {
  let len = vec2.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec2();
};

/**
 * Get a dot product of vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a ∙ b
 */
vec2.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec2} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec2} A rotated vector
 */
vec2.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
};

/**
 * Fast method to rotate a vector by -90, 90 or 180 degrees
 * @param {vec2} a The vector to rotate
 * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees
 * @return {vec2} A rotated vector
 */
vec2.rotf = (a, r) => {
  switch (r) {
    case 1: return vec2(a.y, -a.x);
    case -1: return vec2(-a.y, a.x);
    case 2: case -2: return vec2(-a.x, -a.y);
    default: return a;
  }
};

/**
 * Scalar cross product of two vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a × b
 */
vec2.cross = (a, b) => {
  return a.x * b.y - a.y * b.x;
};

/**
 * Check if two vectors are equal
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec2.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec2} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec2.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec2} a The vector to copy
 * @return {vec2} A copy of vector a
 */
vec2.cpy = a => vec2(a);

/**
 * A function to call on each component of a 2d vector
 * @callback vec2MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec2} a Vector a
 * @param {vec2MapCallback} f The function to call on each component of the vector
 * @return {vec2} Vector a mapped through f
 */
vec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec2} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x` or `y`
 * - `u` or `v` (aliases for `x` and `y`, respectively)
 * - `X`, `Y`, `U`, `V` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec2} a The vector to swizzle
 * @param {string} [s='..'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec2(3, -2);
 * vec2.swiz(a, 'x');    // [3]
 * vec2.swiz(a, 'yx');   // [-2, 3]
 * vec2.swiz(a, 'xY');   // [3, 2]
 * vec2.swiz(a, 'Yy');   // [2, -2]
 * vec2.swiz(a, 'x.x');  // [3, -2, 3]
 * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]
 */
vec2.swiz = (a, s = '..') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': result.push(a.x); break;
      case 'y': case 'v': result.push(a.y); break;
      case 'X': case 'U': result.push(-a.x); break;
      case 'Y': case 'V': result.push(-a.y); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 2d vector
 * @typedef {Object} polarCoordinates2d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec2} a The vector to convert
 * @return {polarCoordinates2d} The magnitude and angle of the vector
 */
vec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The angle of the vector
 * @return {vec2} A vector with the given angle and magnitude
 */
vec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));

/**
 * A 3d vector
 * @typedef {Object} vec3
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 * @property {number} z The z component of the vector
 */

/**
 * Create a new 3d vector
 * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector, or the z component if x is a vec2
 * @param {number} [z] The z component of the vector
 * @return {vec3} A new 3d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec3(3, 2, 1);       // (3, 2, 1)
 * let b = vec3(4, 5);          // (4, 5, 0)
 * let c = vec3(6);             // (6, 6, 6)
 * let d = vec3(a);             // (3, 2, 1)
 * let e = vec3();              // (0, 0, 0)
 * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)
 * let g = vec3(vec2(4, 5));    // (4, 5, 0)
 */
const vec3 = (x, y, z) => {
  if (!x && !y && !z) {
    return { x: 0, y: 0, z: 0 };
  }
  if (_vec_is_vec3(x)) {
    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0, z: y || 0 };
  }
  return { x: x, y: y ?? x, z: z ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec3} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec3.components = a => [a.x, a.y, a.z];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec3} A new vector
 */
vec3.fromComponents = components => vec3(...components.slice(0, 3));

/**
 * Return a unit vector (1, 0, 0)
 * @return {vec3} A unit vector (1, 0, 0)
 */
vec3.ux = () => vec3(1, 0, 0);

/**
 * Return a unit vector (0, 1, 0)
 * @return {vec3} A unit vector (0, 1, 0)
 */
vec3.uy = () => vec3(0, 1, 0);

/**
 * Return a unit vector (0, 0, 1)
 * @return {vec3} A unit vector (0, 0, 1)
 */
vec3.uz = () => vec3(0, 0, 1);

/**
 * Add vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a + b
 */
vec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });

/**
 * Subtract vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a - b
 */
vec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });

/**
 * Scale a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a * b
 */
vec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });

/**
 * Scale a vector by a scalar, alias for vec3.mul
 * @param {vec3} a Vector a
 * @param {number} b Scalar b
 * @return {vec3} a * b
 */
vec3.scale = (a, b) => vec3.mul(a, b);

/**
 * Divide a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a / b
 */
vec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });

/**
 * Get the length of a vector
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);

/**
 * Normalise a vector
 * @param {vec3} a The vector to normalise
 * @return {vec3} ^a
 */
vec3.nor = a => {
  let len = vec3.len(a);
  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();
};

/**
 * Get a dot product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {number} a ∙ b
 */
vec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

/**
 * Rotate a vector using a rotation matrix
 * @param {vec3} a The vector to rotate
 * @param {mat} m The rotation matrix
 * @return {vec3} A rotated vector
 */
vec3.rot = (a, m) => vec3(
  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)
);

/**
 * Rotate a vector by r radians around the x axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotx = (a, r) => vec3(
  a.x,
  a.y * Math.cos(r) - a.z * Math.sin(r),
  a.y * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the y axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.roty = (a, r) => vec3(
  a.x * Math.cos(r) + a.z * Math.sin(r),
  a.y,
  -a.x * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the z axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotz = (a, r) => vec3(
  a.x * Math.cos(r) - a.y * Math.sin(r),
  a.x * Math.sin(r) + a.y * Math.cos(r),
  a.z
);

/**
 * Rotate a vector using a quaternion
 * @param {vec3} a The vector to rotate
 * @param {Array<number>} q The quaternion to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rotq = (v, q) => {
  if (q.length !== 4) {
    return vec3();
  }

  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
  if (d === 0) {
    return vec3();
  }

  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];
  const u = vec3(...uq.slice(0, 3));
  const s = uq[3];
  return vec3.add(
    vec3.add(
      vec3.mul(u, 2 * vec3.dot(u, v)),
      vec3.mul(v, s * s - vec3.dot(u, u))
    ),
    vec3.mul(vec3.cross(u, v), 2 * s)
  );
};

/**
 * Rotate a vector using Euler angles
 * @param {vec3} a The vector to rotate
 * @param {vec3} e The Euler angles to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);

/**
 * Get the cross product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {vec3} a × b
 */
vec3.cross = (a, b) => vec3(
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
);

/**
 * Check if two vectors are equal
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;

/**
 * Get the angle of a vector from the x axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radx = a => Math.atan2(a.z, a.y);

/**
 * Get the angle of a vector from the y axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.rady = a => Math.atan2(a.x, a.y);

/**
 * Get the angle of a vector from the z axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radz = a => Math.atan2(a.y, a.z);

/**
 * Copy a vector
 * @param {vec3} a The vector to copy
 * @return {vec3} A copy of vector a
 */
vec3.cpy = a => vec3(a);

/**
 * A function to call on each component of a 3d vector
 * @callback vec3MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y' | 'z'} label The component label (x, y or z)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec3} a Vector a
 * @param {vec3MapCallback} f The function to call on each component of the vector
 * @return {vec3} Vector a mapped through f
 */
vec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });

/**
 * Convert a vector into a string
 * @param {vec3} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x`, `y` or `z`
 * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)
 * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)
 * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec3} a The vector to swizzle
 * @param {string} [s='...'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec3(3, -2, 1);
 * vec3.swiz(a, 'x');     // [3]
 * vec3.swiz(a, 'zyx');   // [1, -2, 3]
 * vec3.swiz(a, 'xYZ');   // [3, 2, -1]
 * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]
 * vec3.swiz(a, 'x.x');   // [3, -2, 3]
 * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]
 */
vec3.swiz = (a, s = '...') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': case 'r': result.push(a.x); break;
      case 'y': case 'v': case 'g': result.push(a.y); break;
      case 'z': case 'w': case 'b': result.push(a.z); break;
      case 'X': case 'U': case 'R': result.push(-a.x); break;
      case 'Y': case 'V': case 'G': result.push(-a.y); break;
      case 'Z': case 'W': case 'B': result.push(-a.z); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 3d vector
 * @typedef {Object} polarCoordinates3d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The tilt angle of the vector
 * @property {number} phi The pan angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec3} a The vector to convert
 * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector
 */
vec3.polar = a => {
  let r = vec3.len(a),
    theta = Math.acos(a.y / r),
    phi = Math.atan2(a.z, a.x);
  return { r, theta, phi };
};

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The tilt of the vector
 * @param {number} phi The pan of the vector
 * @return {vec3} A vector with the given angle and magnitude
 */
vec3.fromPolar = (r, theta, phi) => {
  const sinTheta = Math.sin(theta);
  return vec3(
    r * sinTheta * Math.cos(phi),
    r * Math.cos(theta),
    r * sinTheta * Math.sin(phi)
  );
};

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|false} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Multiply a matrix by a vector
 * @param {mat} a Matrix a
 * @param {vec2|vec3|number[]} b Vector b
 * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied
 */
mat.mulv = (a, b) => {
  let n, bb, rt;
  if (_vec_is_vec3(b)) {
    bb = vec3.components(b);
    n = 3;
    rt = vec3.fromComponents;
  } else if (_vec_is_vec2(b)) {
    bb = vec2.components(b);
    n = 2;
    rt = vec2.fromComponents;
  } else {
    bb = b;
    n = b.length ?? 0;
    rt = v => v;
  }
  if (a.n !== n) { return false; }
  const result = [];
  for (let i = 1; i <= a.m; i++) {
    result.push(_vec_dot(mat.row(a, i), bb));
  }
  return rt(result);
}

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|false} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|false} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|false} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec2, vec3, mat };
}


/***/ }),

/***/ "./node_modules/poly-decomp/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/poly-decomp/src/index.js ***!
  \***********************************************/
/***/ ((module) => {

module.exports = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
};

/**
 * Compute the intersection between two lines.
 * @static
 * @method lineInt
 * @param  {Array}  l1          Line vector 1
 * @param  {Array}  l2          Line vector 2
 * @param  {Number} precision   Precision to use when checking if the lines are parallel
 * @return {Array}              The intersection point.
 */
function lineInt(l1,l2,precision){
    precision = precision || 0;
    var i = [0,0]; // point
    var a1, b1, c1, a2, b2, c2, det; // scalars
    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2*b1;
    if (!scalar_eq(det, 0, precision)) { // lines are not parallel
        i[0] = (b2 * c1 - b1 * c2) / det;
        i[1] = (a1 * c2 - a2 * c1) / det;
    }
    return i;
}

/**
 * Checks if two line segments intersects.
 * @method segmentsIntersect
 * @param {Array} p1 The start vertex of the first line segment.
 * @param {Array} p2 The end vertex of the first line segment.
 * @param {Array} q1 The start vertex of the second line segment.
 * @param {Array} q2 The end vertex of the second line segment.
 * @return {Boolean} True if the two line segments intersect
 */
function lineSegmentsIntersect(p1, p2, q1, q2){
	var dx = p2[0] - p1[0];
	var dy = p2[1] - p1[1];
	var da = q2[0] - q1[0];
	var db = q2[1] - q1[1];

	// segments are parallel
	if((da*dy - db*dx) === 0){
		return false;
	}

	var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
	var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);

	return (s>=0 && s<=1 && t>=0 && t<=1);
}

/**
 * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
 * @static
 * @method area
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @return {Number}
 */
function triangleArea(a,b,c){
    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));
}

function isLeft(a,b,c){
    return triangleArea(a,b,c) > 0;
}

function isLeftOn(a,b,c) {
    return triangleArea(a, b, c) >= 0;
}

function isRight(a,b,c) {
    return triangleArea(a, b, c) < 0;
}

function isRightOn(a,b,c) {
    return triangleArea(a, b, c) <= 0;
}

var tmpPoint1 = [],
    tmpPoint2 = [];

/**
 * Check if three points are collinear
 * @method collinear
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Array} c
 * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
 * @return {Boolean}
 */
function collinear(a,b,c,thresholdAngle) {
    if(!thresholdAngle){
        return triangleArea(a, b, c) === 0;
    } else {
        var ab = tmpPoint1,
            bc = tmpPoint2;

        ab[0] = b[0]-a[0];
        ab[1] = b[1]-a[1];
        bc[0] = c[0]-b[0];
        bc[1] = c[1]-b[1];

        var dot = ab[0]*bc[0] + ab[1]*bc[1],
            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),
            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),
            angle = Math.acos(dot/(magA*magB));
        return angle < thresholdAngle;
    }
}

function sqdist(a,b){
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
}

/**
 * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
 * @method at
 * @param  {Number} i
 * @return {Array}
 */
function polygonAt(polygon, i){
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
}

/**
 * Clear the polygon data
 * @method clear
 * @return {Array}
 */
function polygonClear(polygon){
    polygon.length = 0;
}

/**
 * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
 * @method append
 * @param {Polygon} poly The polygon to get points from.
 * @param {Number}  from The vertex index in "poly".
 * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
 * @return {Array}
 */
function polygonAppend(polygon, poly, from, to){
    for(var i=from; i<to; i++){
        polygon.push(poly[i]);
    }
}

/**
 * Make sure that the polygon vertices are ordered counter-clockwise.
 * @method makeCCW
 */
function polygonMakeCCW(polygon){
    var br = 0,
        v = polygon;

    // find bottom right point
    for (var i = 1; i < polygon.length; ++i) {
        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {
            br = i;
        }
    }

    // reverse poly if clockwise
    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
        polygonReverse(polygon);
        return true;
    } else {
        return false;
    }
}

/**
 * Reverse the vertices in the polygon
 * @method reverse
 */
function polygonReverse(polygon){
    var tmp = [];
    var N = polygon.length;
    for(var i=0; i!==N; i++){
        tmp.push(polygon.pop());
    }
    for(var i=0; i!==N; i++){
		polygon[i] = tmp[i];
    }
}

/**
 * Check if a point in the polygon is a reflex point
 * @method isReflex
 * @param  {Number}  i
 * @return {Boolean}
 */
function polygonIsReflex(polygon, i){
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
}

var tmpLine1=[],
    tmpLine2=[];

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee(polygon, a,b) {
    var p, dist, l1=tmpLine1, l2=tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
        return false;
    }
    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));
    for (var i = 0; i !== polygon.length; ++i) { // for each edge
        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges
            continue;
        }
        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1,l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b
                return false;
            }
        }
    }

    return true;
}

/**
 * Check if two vertices in the polygon can see each other
 * @method canSee2
 * @param  {Number} a Vertex index 1
 * @param  {Number} b Vertex index 2
 * @return {Boolean}
 */
function polygonCanSee2(polygon, a,b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
        // ignore incident edges
        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){
            continue;
        }
        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){
            return false;
        }
    }
    return true;
}

/**
 * Copy the polygon from vertex i to vertex j.
 * @method copy
 * @param  {Number} i
 * @param  {Number} j
 * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
 * @return {Polygon}                The resulting copy.
 */
function polygonCopy(polygon, i,j,targetPoly){
    var p = targetPoly || [];
    polygonClear(p);
    if (i < j) {
        // Insert all vertices from i to j
        for(var k=i; k<=j; k++){
            p.push(polygon[k]);
        }

    } else {

        // Insert vertices 0 to j
        for(var k=0; k<=j; k++){
            p.push(polygon[k]);
        }

        // Insert vertices i to end
        for(var k=i; k<polygon.length; k++){
            p.push(polygon[k]);
        }
    }

    return p;
}

/**
 * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
 * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
 * @method getCutEdges
 * @return {Array}
 */
function polygonGetCutEdges(polygon) {
    var min=[], tmp1=[], tmp2=[], tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
                if (polygonCanSee(polygon, i, j)) {
                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

                    for(var k=0; k<tmp2.length; k++){
                        tmp1.push(tmp2[k]);
                    }

                    if (tmp1.length < nDiags) {
                        min = tmp1;
                        nDiags = tmp1.length;
                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                    }
                }
            }
        }
    }

    return min;
}

/**
 * Decomposes the polygon into one or more convex sub-Polygons.
 * @method decomp
 * @return {Array} An array or Polygon objects.
 */
function polygonDecomp(polygon){
    var edges = polygonGetCutEdges(polygon);
    if(edges.length > 0){
        return polygonSlice(polygon, edges);
    } else {
        return [polygon];
    }
}

/**
 * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
 * @method slice
 * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
 * @return {Array}
 */
function polygonSlice(polygon, cutEdges){
    if(cutEdges.length === 0){
		return [polygon];
    }
    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){

        var polys = [polygon];

        for(var i=0; i<cutEdges.length; i++){
            var cutEdge = cutEdges[i];
            // Cut all polys
            for(var j=0; j<polys.length; j++){
                var poly = polys[j];
                var result = polygonSlice(poly, cutEdge);
                if(result){
                    // Found poly! Cut and quit
                    polys.splice(j,1);
                    polys.push(result[0],result[1]);
                    break;
                }
            }
        }

        return polys;
    } else {

        // Was given one edge
        var cutEdge = cutEdges;
        var i = polygon.indexOf(cutEdge[0]);
        var j = polygon.indexOf(cutEdge[1]);

        if(i !== -1 && j !== -1){
            return [polygonCopy(polygon, i,j),
                    polygonCopy(polygon, j,i)];
        } else {
            return false;
        }
    }
}

/**
 * Checks that the line segments of this polygon do not intersect each other.
 * @method isSimple
 * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
 * @return {Boolean}
 * @todo Should it check all segments with all others?
 */
function polygonIsSimple(polygon){
    var path = polygon, i;
    // Check
    for(i=0; i<path.length-1; i++){
        for(var j=0; j<i-1; j++){
            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){
                return false;
            }
        }
    }

    // Check the segment between the last and the first point to all others
    for(i=1; i<path.length-2; i++){
        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){
            return false;
        }
    }

    return true;
}

function getIntersectionPoint(p1, p2, q1, q2, delta){
	delta = delta || 0;
	var a1 = p2[1] - p1[1];
	var b1 = p1[0] - p2[0];
	var c1 = (a1 * p1[0]) + (b1 * p1[1]);
	var a2 = q2[1] - q1[1];
	var b2 = q1[0] - q2[0];
	var c2 = (a2 * q1[0]) + (b2 * q1[1]);
	var det = (a1 * b2) - (a2 * b1);

	if(!scalar_eq(det,0,delta)){
		return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];
	} else {
		return [0,0];
    }
}

/**
 * Quickly decompose the Polygon into convex sub-polygons.
 * @method quickDecomp
 * @param  {Array} result
 * @param  {Array} [reflexVertices]
 * @param  {Array} [steinerPoints]
 * @param  {Number} [delta]
 * @param  {Number} [maxlevel]
 * @param  {Number} [level]
 * @return {Array}
 */
function polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof(result)!=="undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];

    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points
    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars
    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers
    var lowerPoly=[], upperPoly=[]; // polygons
    var poly = polygon,
        v = polygon;

    if(v.length < 3){
		return result;
    }

    level++;
    if(level > maxlevel){
        console.warn("quickDecomp: max level ("+maxlevel+") reached.");
        return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
        if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;


            for (var j = 0; j < polygon.length; ++j) {
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge
                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection
                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly
                        d = sqdist(poly[i], p);
                        if (d < lowerDist) { // keep only the closest intersection
                            lowerDist = d;
                            lowerInt = p;
                            lowerIndex = j;
                        }
                    }
                }
                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                        d = sqdist(poly[i], p);
                        if (d < upperDist) {
                            upperDist = d;
                            upperInt = p;
                            upperIndex = j;
                        }
                    }
                }
            }

            // if there are no vertices to connect to, choose a point in the middle
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
                //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
                p[0] = (lowerInt[0] + upperInt[0]) / 2;
                p[1] = (lowerInt[1] + upperInt[1]) / 2;
                steinerPoints.push(p);

                if (i < upperIndex) {
                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly, i, upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    if (lowerIndex !== 0){
                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);
                    }
                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
                        polygonAppend(lowerPoly, poly,i,poly.length);
                    }
                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);
                    polygonAppend(lowerPoly, poly,0,upperIndex+1);
                    lowerPoly.push(p);
                    upperPoly.push(p);
                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);
                    polygonAppend(upperPoly, poly,lowerIndex,i+1);
                }
            } else {
                // connect to the closest point within the triangle
                //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");

                if (lowerIndex > upperIndex) {
                    upperIndex += polygon.length;
                }
                closestDist = Number.MAX_VALUE;

                if(upperIndex < lowerIndex){
                    return result;
                }

                for (var j = lowerIndex; j <= upperIndex; ++j) {
                    if (
                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&
                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))
                    ) {
                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                        if (d < closestDist && polygonCanSee2(poly, i, j)) {
                            closestDist = d;
                            closestIndex = j % polygon.length;
                        }
                    }
                }

                if (i < closestIndex) {
                    polygonAppend(lowerPoly, poly,i,closestIndex+1);
                    if (closestIndex !== 0){
                        polygonAppend(upperPoly, poly,closestIndex,v.length);
                    }
                    polygonAppend(upperPoly, poly,0,i+1);
                } else {
                    if (i !== 0){
                        polygonAppend(lowerPoly, poly,i,v.length);
                    }
                    polygonAppend(lowerPoly, poly,0,closestIndex+1);
                    polygonAppend(upperPoly, poly,closestIndex,i+1);
                }
            }

            // solve smallest poly first
            if (lowerPoly.length < upperPoly.length) {
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            } else {
                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);
            }

            return result;
        }
    }
    result.push(polygon);

    return result;
}

/**
 * Remove collinear points in the polygon.
 * @method removeCollinearPoints
 * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
 * @return {Number}           The number of points removed
 */
function polygonRemoveCollinearPoints(polygon, precision){
    var num = 0;
    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){
        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){
            // Remove the middle point
            polygon.splice(i%polygon.length,1);
            num++;
        }
    }
    return num;
}

/**
 * Remove duplicate points in the polygon.
 * @method removeDuplicatePoints
 * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
 */
function polygonRemoveDuplicatePoints(polygon, precision){
    for(var i=polygon.length-1; i>=1; --i){
        var pi = polygon[i];
        for(var j=i-1; j>=0; --j){
            if(points_eq(pi, polygon[j], precision)){
                polygon.splice(i,1);
                continue;
            }
        }
    }
}

/**
 * Check if two scalars are equal
 * @static
 * @method eq
 * @param  {Number} a
 * @param  {Number} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function scalar_eq(a,b,precision){
    precision = precision || 0;
    return Math.abs(a-b) <= precision;
}

/**
 * Check if two points are equal
 * @static
 * @method points_eq
 * @param  {Array} a
 * @param  {Array} b
 * @param  {Number} [precision]
 * @return {Boolean}
 */
function points_eq(a,b,precision){
    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);
}


/***/ }),

/***/ "./src/2d/index.ts":
/*!*************************!*\
  !*** ./src/2d/index.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_62156__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distance = distance;
exports.angle = angle;
exports.angleBetween = angleBetween;
exports.pointsAreCollinear = pointsAreCollinear;
exports.lineToRay = lineToRay;
exports.rayToLine = rayToLine;
exports.aabb = aabb;
exports.aabbToRectangle = aabbToRectangle;
exports.aabbsOverlap = aabbsOverlap;
exports.pointInAABB = pointInAABB;
exports.encloseAABBs = encloseAABBs;
exports.rectangleIsRotated = rectangleIsRotated;
exports.rectangleVertices = rectangleVertices;
exports.verticesToEdges = verticesToEdges;
exports.polygonIsConvex = polygonIsConvex;
exports.polygonSelfIntersects = polygonSelfIntersects;
exports.polygonIsValid = polygonIsValid;
exports.polygonWindingOrder = polygonWindingOrder;
exports.polygonArea = polygonArea;
exports.polygonCentroid = polygonCentroid;
exports.polygonConvexHull = polygonConvexHull;
exports.optimisePolygon = optimisePolygon;
exports.decomposePolygon = decomposePolygon;
exports.pointOnRay = pointOnRay;
exports.pointOnLine = pointOnLine;
exports.pointInCircle = pointInCircle;
exports.pointInRectangle = pointInRectangle;
exports.pointInPolygon = pointInPolygon;
exports.rayTraverseGrid = rayTraverseGrid;
exports.rayIntersectsRay = rayIntersectsRay;
exports.rayIntersectsLine = rayIntersectsLine;
exports.rayIntersectsCircle = rayIntersectsCircle;
exports.rayIntersectsRectangle = rayIntersectsRectangle;
exports.rayIntersectsPolygon = rayIntersectsPolygon;
exports.lineIntersectsRay = lineIntersectsRay;
exports.lineIntersectsLine = lineIntersectsLine;
exports.lineIntersectsCircle = lineIntersectsCircle;
exports.lineIntersectsRectangle = lineIntersectsRectangle;
exports.lineIntersectsPolygon = lineIntersectsPolygon;
exports.circleIntersectsCircle = circleIntersectsCircle;
exports.circleIntersectsRectangle = circleIntersectsRectangle;
exports.circleIntersectsPolygon = circleIntersectsPolygon;
exports.rectangleIntersectsRectangle = rectangleIntersectsRectangle;
exports.rectangleIntersectsPolygon = rectangleIntersectsPolygon;
exports.polygonIntersectsPolygon = polygonIntersectsPolygon;
const utils_1 = __nested_webpack_require_62156__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __nested_webpack_require_62156__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const decomp = __importStar(__nested_webpack_require_62156__(/*! poly-decomp */ "./node_modules/poly-decomp/src/index.js"));
const utilities_1 = __nested_webpack_require_62156__(/*! ../utilities */ "./src/utilities/index.ts");
const constants = __importStar(__nested_webpack_require_62156__(/*! ../utilities/constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_62156__(/*! ./types */ "./src/2d/types.ts");
__exportStar(__nested_webpack_require_62156__(/*! ./types */ "./src/2d/types.ts"), exports);
/**
 * Contents
 *
 * Utilities
 * @see distance
 * @see angle
 * @see angleBetween
 * @see pointsAreCollinear
 *
 * Line and ray utilities
 * @see lineToRay
 * @see rayToLine
 *
 * AABBs
 * @see aabb
 * @see aabbToRectangle
 * @see aabbsOverlap
 * @see pointInAABB
 * @see encloseAABBs
 *
 * Rectangle utilities
 * @see rectangleIsRotated
 * @see rectangleVertices
 *
 * Polygon utilities
 * @see verticesToEdges
 * @see findOuterEdges (not exported)
 * @see polygonIsConvex
 * @see polygonSelfIntersects
 * @see polygonIsValid
 * @see polygonWindingOrder
 * @see polygonArea
 * @see polygonCentroid
 * @see polygonConvexHull
 * @see removeDuplicateVertices (not exported)
 * @see removeDuplicateAdjacentVertices (not exported)
 * @see removeCollinearVertices (not exported)
 * @see optimisePolygon
 * @see decomposePolygon
 *
 * Points
 * @see pointOnRay
 * @see pointOnLine
 * @see pointInCircle
 * @see pointInRectangle
 * @see pointInPolygon
 *
 * Rays
 * @see rayTraverseGrid
 * @see rayIntersectsRay
 * @see rayIntersectsLine
 * @see rayIntersectsCircle
 * @see rayIntersectsRectangle
 * @see rayIntersectsValidConvexPolygonEdges (not exported)
 * @see rayIntersectsPolygon
 *
 * Lines
 * @see lineIntersectsRay
 * @see lineIntersectsLine
 * @see lineIntersectsCircle
 * @see lineIntersectsRectangle
 * @see lineIntersectsValidConvexPolygonEdges (not exported)
 * @see lineIntersectsPolygon
 *
 * Circles
 * @see circleIntersectsCircle
 * @see circleIntersectsRectangle
 * @see circleIntersectsValidConvexPolygonEdges (not exported)
 * @see circleIntersectsPolygon
 *
 * Rectangles
 * @see projectVerticesToAxis (not exported)
 * @see rectangleIntersectsRectangle
 * @see rectangleIntersectsPolygon
 *
 * Polygons
 * @see polygonIntersectsPolygon
 */
/**
 * Calculate the distance between two points
 */
function distance(a, b) {
    return vec_1.vec2.len(vec_1.vec2.sub(a, b));
}
/**
 * Calculate the clockwise angle from point a to point b
 *
 * The result is in radians and ranges from 0 to 2π (360 degrees)
 *
 * Returns 0 if the vectors are equal
 */
function angle(a, b) {
    if ((0, utilities_1.vectorsAlmostEqual)(a, b)) {
        return 0;
    }
    const theta = vec_1.vec2.rad(vec_1.vec2.sub(b, a)) % (2 * Math.PI);
    if (theta < 0) {
        return theta + 2 * Math.PI; // Ensure angle is positive
    }
    return theta;
}
/**
 * Calculate the clockwise angle between two lines or rays
 *
 * Returns 0 if either line is zero-length
 */
function angleBetween(a, b) {
    let aLine = (0, types_1.isRay)(a) ? rayToLine(a, 1) : a;
    let bLine = (0, types_1.isRay)(b) ? rayToLine(b, 1) : b;
    if ((0, utilities_1.vectorAlmostZero)(vec_1.vec2.sub(aLine.end, aLine.start)) ||
        (0, utilities_1.vectorAlmostZero)(vec_1.vec2.sub(bLine.end, bLine.start))) {
        return 0; // Zero-length line
    }
    const dirA = vec_1.vec2.nor(vec_1.vec2.sub(aLine.end, aLine.start));
    const dirB = vec_1.vec2.nor(vec_1.vec2.sub(bLine.end, bLine.start));
    // Clamp dot product to [-1, 1] to avoid NaN due to floating-point errors
    const dot = (0, utils_1.clamp)(vec_1.vec2.dot(dirA, dirB), -1, 1);
    const cross = vec_1.vec2.cross(dirA, dirB);
    const angle = Math.atan2(cross, dot);
    return angle < 0 ? angle + 2 * Math.PI : angle; // Ensure angle is positive
}
/**
 * Check if three points in 2D space are collinear
 */
function pointsAreCollinear(a, b, c) {
    // Check if the area of the triangle formed by the points is zero
    const area = 0.5 * Math.abs(a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    return Math.abs(area) < constants.EPSILON;
}
/**
 * Convert a line segment to a ray
 */
function lineToRay(line) {
    return {
        origin: line.start,
        direction: vec_1.vec2.nor(vec_1.vec2.sub(line.end, line.start)),
    };
}
/**
 * Convert a ray to a line segment
 */
function rayToLine(ray, length = 1) {
    return {
        start: ray.origin,
        end: vec_1.vec2.add(ray.origin, vec_1.vec2.mul(ray.direction, length)),
    };
}
/**
 * Get the bounding box (AABB) of a geometric object
 */
function aabb(o) {
    if ((0, types_1.isLine)(o)) {
        return {
            position: (0, vec_1.vec2)(Math.min(o.start.x, o.end.x), Math.min(o.start.y, o.end.y)),
            size: (0, vec_1.vec2)(Math.abs(o.end.x - o.start.x), Math.abs(o.end.y - o.start.y)),
        };
    }
    if ((0, types_1.isRectangle)(o)) {
        const vertices = rectangleVertices(o);
        const position = (0, vec_1.vec2)(Math.min(...vertices.map(v => v.x)), Math.min(...vertices.map(v => v.y)));
        return {
            position,
            size: (0, vec_1.vec2)(Math.max(...vertices.map(v => v.x)) - position.x, Math.max(...vertices.map(v => v.y)) - position.y),
        };
    }
    if ((0, types_1.isCircle)(o)) {
        return {
            position: vec_1.vec2.sub(o.position, (0, vec_1.vec2)(o.radius, o.radius)),
            size: (0, vec_1.vec2)(o.radius * 2),
        };
    }
    if ((0, types_1.isPolygon)(o)) {
        const position = (0, vec_1.vec2)(Math.min(...o.vertices.map(v => v.x)), Math.min(...o.vertices.map(v => v.y)));
        return {
            position,
            size: (0, vec_1.vec2)(Math.max(...o.vertices.map(v => v.x)) - position.x, Math.max(...o.vertices.map(v => v.y)) - position.y),
        };
    }
    return null;
}
/**
 * Convert an AABB to a rectangle
 */
function aabbToRectangle(aabb) {
    return {
        position: vec_1.vec2.add(aabb.position, vec_1.vec2.div(aabb.size, 2)),
        size: aabb.size,
        rotation: 0,
    };
}
/**
 * Check if two AABBs overlap and return the overlapping area if so
 */
function aabbsOverlap(a, b) {
    const overlapX = (0, utilities_1.overlapInterval)({ min: a.position.x, max: a.position.x + a.size.x }, { min: b.position.x, max: b.position.x + b.size.x });
    const overlapY = (0, utilities_1.overlapInterval)({ min: a.position.y, max: a.position.y + a.size.y }, { min: b.position.y, max: b.position.y + b.size.y });
    // If the AABBs don't overlap on one or more axes, they don't overlap at all
    if (!overlapX || !overlapY) {
        return { intersects: false };
    }
    return {
        intersects: true,
        overlap: {
            position: (0, vec_1.vec2)(overlapX.min, overlapY.min),
            size: (0, vec_1.vec2)(overlapX.max - overlapX.min, overlapY.max - overlapY.min),
        },
    };
}
/**
 * Check if a point is inside an AABB
 *
 * This should be faster than pointInRectangle since we don't need to consider
 * rotation
 */
function pointInAABB(point, aabb) {
    const { position, size } = aabb;
    const min = position;
    const max = vec_1.vec2.add(position, size);
    // Check if the point is inside the AABB
    const intersects = (0, utilities_1.valueInInterval)(point.x, { min: min.x, max: max.x }) &&
        (0, utilities_1.valueInInterval)(point.y, { min: min.y, max: max.y });
    // Find the closest point on the AABB perimeter to the given point
    let closestPoint;
    let normal = undefined;
    if (!intersects) {
        // If the point is outside, clamp to the box
        closestPoint = (0, vec_1.vec2)((0, utils_1.clamp)(point.x, min.x, max.x), (0, utils_1.clamp)(point.y, min.y, max.y));
    }
    else {
        // If the point is inside, project to the nearest edge
        const distances = [
            {
                x: min.x,
                y: point.y,
                d: Math.abs(point.x - min.x),
                normal: (0, vec_1.vec2)(-1, 0),
            }, // left
            {
                x: max.x,
                y: point.y,
                d: Math.abs(point.x - max.x),
                normal: (0, vec_1.vec2)(1, 0),
            }, // right
            {
                x: point.x,
                y: min.y,
                d: Math.abs(point.y - min.y),
                normal: (0, vec_1.vec2)(0, -1),
            }, // top
            {
                x: point.x,
                y: max.y,
                d: Math.abs(point.y - max.y),
                normal: (0, vec_1.vec2)(0, 1),
            }, // bottom
        ];
        const nearest = distances.reduce((a, b) => (a.d < b.d ? a : b));
        closestPoint = (0, vec_1.vec2)(nearest.x, nearest.y);
        normal = nearest.normal;
    }
    // Calculate the distance from the point to the closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    // If the point is inside, distance should be negative
    return {
        intersects,
        closestPoint,
        distance: intersects ? -distance : distance,
        normal,
    };
}
/**
 * Enclose a set of AABBs in a single AABB
 */
function encloseAABBs(...aabbs) {
    if (aabbs.length === 0) {
        return { position: (0, vec_1.vec2)(), size: (0, vec_1.vec2)() };
    }
    const minX = Math.min(...aabbs.map(({ position }) => position.x));
    const minY = Math.min(...aabbs.map(({ position }) => position.y));
    const maxX = Math.max(...aabbs.map(({ position, size }) => position.x + size.x));
    const maxY = Math.max(...aabbs.map(({ position, size }) => position.y + size.y));
    return {
        position: (0, vec_1.vec2)(minX, minY),
        size: (0, vec_1.vec2)(maxX - minX, maxY - minY),
    };
}
/**
 * Check if a rectangle is rotated
 */
function rectangleIsRotated(rectangle) {
    return (rectangle.rotation !== undefined &&
        Math.abs(rectangle.rotation) > constants.EPSILON);
}
/**
 * Get the vertices of a rectangle
 *
 * Vertices will be returned in clockwise order starting at the top-left:
 * - Top-left
 * - Top-right
 * - Bottom-right
 * - Bottom-left
 */
function rectangleVertices(rectangle) {
    const { position, size, rotation = 0 } = rectangle;
    const halfSize = vec_1.vec2.div(size, 2);
    // Calculate the four corners of the rectangle
    let topLeftOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'XY'));
    let topRightOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'xY'));
    let bottomRightOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'xy'));
    let bottomLeftOffset = vec_1.vec2.fromComponents(vec_1.vec2.swiz(halfSize, 'Xy'));
    // Rotate the offsets if the rectangle is rotated
    if (rectangleIsRotated(rectangle)) {
        topLeftOffset = vec_1.vec2.rot(topLeftOffset, rotation);
        topRightOffset = vec_1.vec2.rot(topRightOffset, rotation);
        bottomRightOffset = vec_1.vec2.rot(bottomRightOffset, rotation);
        bottomLeftOffset = vec_1.vec2.rot(bottomLeftOffset, rotation);
    }
    return [
        vec_1.vec2.add(position, topLeftOffset),
        vec_1.vec2.add(position, topRightOffset),
        vec_1.vec2.add(position, bottomRightOffset),
        vec_1.vec2.add(position, bottomLeftOffset),
    ];
}
/**
 * Convert a list of vertices to a list of edges
 */
function verticesToEdges(vertices) {
    const edges = [];
    for (let i = 0; i < vertices.length; i++) {
        const start = vertices[i];
        const end = (0, utils_1.at)(vertices, i + 1);
        edges.push({ start, end });
    }
    return edges;
}
/**
 * Find outer edges in a list of polygons
 *
 * We assume that the polygons were the result of decomposing a concave polygon
 * into a set of convex polygons, and as such they are all convex and share
 * one or more edges
 *
 * This means we can identify outer edges because they'll only appear once
 * in the list of edges, while inner edges will appear twice (once for each
 * polygon that shares them)
 */
function findOuterEdges(polygons) {
    const allEdges = polygons.flatMap(polygon => verticesToEdges(polygon.vertices));
    // Edges are the duplicates if they overlap but have no intersection point
    // (this implies that they have infinitely many intersection points)
    const edgesOverlap = (a, b) => {
        const result = lineIntersectsLine(a, b);
        if (result.intersects && !result.intersectionPoint) {
            // Edge case: if the edges intersect and have no intersect point, but
            // share only one endpoint, then they aren't considered overlapping
            if (((0, utilities_1.vectorsAlmostEqual)(a.end, b.start) &&
                !(0, utilities_1.vectorsAlmostEqual)(a.start, b.end)) ||
                ((0, utilities_1.vectorsAlmostEqual)(a.start, b.end) &&
                    !(0, utilities_1.vectorsAlmostEqual)(a.end, b.start))) {
                return false;
            }
            return true;
        }
        return false;
    };
    // Filter out the edges that appear more than once
    const result = [];
    for (const edge of allEdges) {
        if (!result.some(e => edgesOverlap(e, edge)) &&
            !allEdges.some(e => e !== edge && edgesOverlap(e, edge))) {
            result.push(edge); // This edge is an outer edge
        }
    }
    return result;
}
/**
 * Check if a polygon is convex
 *
 * Returns null if the polygon is invalid
 */
function polygonIsConvex(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let sign = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        const c = (0, utils_1.at)(polygon.vertices, i + 2);
        const crossProduct = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        if (crossProduct !== 0) {
            if (sign === 0) {
                sign = Math.sign(crossProduct);
            }
            else if (Math.sign(crossProduct) !== sign) {
                return false; // Found a change in sign, polygon is not convex
            }
        }
    }
    return true; // All cross products have the same sign, polygon is convex
}
/**
 * Check if a polygon self-intersects
 */
function polygonSelfIntersects(polygon) {
    if (polygon.vertices.length < 3) {
        return false; // A polygon must have at least 3 vertices
    }
    const n = polygon.vertices.length;
    for (let i = 0; i < n; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        for (let j = i + 2; j < n; j++) {
            const c = polygon.vertices[j];
            const d = (0, utils_1.at)(polygon.vertices, j + 1);
            // Skip adjacent edges
            if (i === 0 && j === n - 1) {
                continue;
            }
            // Check if the segments (a, b) and (c, d) intersect
            const { intersects } = lineIntersectsLine({ start: a, end: b }, { start: c, end: d });
            if (intersects) {
                return true; // Found an intersection, polygon self-intersects
            }
        }
    }
    return false; // No intersections found, polygon does not self-intersect
}
/**
 * Check if a polygon is valid
 *
 * A polygon is valid if it has at least 3 vertices and does not
 * self-intersect
 */
function polygonIsValid(polygon) {
    return polygon.vertices.length >= 3 && !polygonSelfIntersects(polygon);
}
/**
 * Determine the winding order of a polygon's vertices
 *
 * Returns 'clockwise' or 'counter-clockwise' depending on the chosen
 * coordinate system
 *
 * By default we use the 'screen' coordinate system (y increases downwards)
 *
 * Returns null if the polygon is invalid
 */
function polygonWindingOrder(polygon, options) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let sum = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        sum += (b.x - a.x) * (b.y + a.y);
    }
    const coordinateSystem = (options === null || options === void 0 ? void 0 : options.coordinateSystem) || 'screen';
    switch (coordinateSystem) {
        case 'cartesian':
            return sum > 0 ? 'clockwise' : 'counter-clockwise';
        case 'screen':
            return sum > 0 ? 'counter-clockwise' : 'clockwise';
        default:
            return null;
    }
}
/**
 * Calculate the area of a polygon
 *
 * Returns null if the polygon is invalid
 */
function polygonArea(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    let area = 0;
    for (let i = 0; i < polygon.vertices.length; i++) {
        const a = polygon.vertices[i];
        const b = (0, utils_1.at)(polygon.vertices, i + 1);
        area += vec_1.vec2.cross(a, b);
    }
    return Math.abs(area) / 2;
}
/**
 * Calculate the centroid of a polygon
 *
 * Returns null if the polygon is invalid or degenerate (i.e. all vertices are
 * collinear)
 */
function polygonCentroid(polygon) {
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygon.vertices.every((v, i, a) => pointsAreCollinear(v, (0, utils_1.at)(a, i + 1), (0, utils_1.at)(a, i + 2)))) {
        return null; // All vertices are collinear
    }
    return vec_1.vec2.div([...polygon.vertices].reduce((a, c) => vec_1.vec2.add(a, c), (0, vec_1.vec2)()), polygon.vertices.length);
}
/**
 * Calculate the convex hull of a polygon
 */
function polygonConvexHull(polygon, options) {
    var _a;
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygonIsConvex(polygon)) {
        return polygon; // The polygon is already convex
    }
    const keepWindingOrder = (_a = options === null || options === void 0 ? void 0 : options.keepWindingOrder) !== null && _a !== void 0 ? _a : true;
    const originalWindingOrder = polygonWindingOrder(polygon);
    // Andrew's monotone chain algorithm for convex hull
    // Sort vertices lexicographically (first by x, then by y)
    const sorted = [...polygon.vertices].sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);
    const lower = [];
    for (const p of sorted) {
        while (lower.length >= 2 &&
            vec_1.vec2.cross(vec_1.vec2.sub(lower[lower.length - 1], lower[lower.length - 2]), vec_1.vec2.sub(p, lower[lower.length - 1])) <= 0) {
            lower.pop();
        }
        lower.push(p);
    }
    const upper = [];
    for (let i = sorted.length - 1; i >= 0; --i) {
        const p = sorted[i];
        while (upper.length >= 2 &&
            vec_1.vec2.cross(vec_1.vec2.sub(upper[upper.length - 1], upper[upper.length - 2]), vec_1.vec2.sub(p, upper[upper.length - 1])) <= 0) {
            upper.pop();
        }
        upper.push(p);
    }
    // Remove the last point of each half because it's repeated at the start of
    // the other
    lower.pop();
    upper.pop();
    const hull = lower.concat(upper);
    if (hull.length < 3) {
        return null;
    }
    // Optionally ensure the winding order is preserved
    if (keepWindingOrder &&
        polygonWindingOrder({ vertices: hull }) !== originalWindingOrder) {
        hull.reverse();
    }
    return {
        vertices: removeDuplicateVertices(hull),
    };
}
/**
 * Remove duplicate vertices from a list of vertices
 */
function removeDuplicateVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const current = vertices[i];
        if (!result.some(v => (0, utilities_1.vectorsAlmostEqual)(current, v))) {
            result.push(current);
        }
    }
    return result;
}
/**
 * Remove duplicate adjacent vertices from a list of vertices
 */
function removeDuplicateAdjacentVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const current = vertices[i];
        const next = (0, utils_1.at)(vertices, i + 1);
        if (!(0, utilities_1.vectorsAlmostEqual)(current, next)) {
            result.push(current);
        }
    }
    return result;
}
/**
 * Remove collinear vertices from a list of vertices
 */
function removeCollinearVertices(vertices) {
    const result = [];
    const n = vertices.length;
    for (let i = 0; i < n; i++) {
        const a = (0, utils_1.at)(vertices, i - 1);
        const b = vertices[i];
        const c = (0, utils_1.at)(vertices, i + 1);
        // Skip collinear points
        if (pointsAreCollinear(a, b, c)) {
            continue;
        }
        result.push(b);
    }
    return result;
}
/**
 * Optimise a polygon by removing collinear vertices and duplicate adjacent
 * vertices
 */
function optimisePolygon(polygon) {
    // Duplicate adjacent vertices will count the polygon as self-intersecting,
    // so skip that check for now and only check the number of vertices
    if (polygon.vertices.length < 3) {
        return null;
    }
    const optimisedVertices = removeCollinearVertices(removeDuplicateAdjacentVertices(polygon.vertices));
    // If we have less than 3 vertices after optimisation, return null
    if (optimisedVertices.length < 3) {
        return null;
    }
    return { vertices: optimisedVertices };
}
/**
 * Decompose a polygon into a set of convex polygons using the Bayazit
 * algorithm
 *
 * Returns null if the polygon is invalid or cannot be decomposed
 */
function decomposePolygon(polygon, options) {
    var _a;
    if (!polygonIsValid(polygon)) {
        return null;
    }
    if (polygonIsConvex(polygon)) {
        return [polygon]; // The polygon is already convex
    }
    const mode = (options === null || options === void 0 ? void 0 : options.mode) || 'fast';
    const keepWindingOrder = (_a = options === null || options === void 0 ? void 0 : options.keepWindingOrder) !== null && _a !== void 0 ? _a : true;
    const originalWindingOrder = polygonWindingOrder(polygon);
    const vertices = polygon.vertices.map(v => [v.x, v.y]);
    if (originalWindingOrder === 'counter-clockwise') {
        vertices.reverse(); // Ensure clockwise winding
    }
    // Decompose the polygon
    let convexPolygons = [];
    switch (mode) {
        case 'fast':
            convexPolygons = decomp.quickDecomp(vertices);
            break;
        case 'optimal':
            convexPolygons = decomp.decomp(vertices);
            break;
    }
    // Convert the result into a list of Polygon objects
    const result = [];
    for (const convex of convexPolygons) {
        result.push({
            vertices: convex.map(v => (0, vec_1.vec2)(v[0], v[1])),
        });
    }
    // Optionally ensure the winding order is preserved
    if (keepWindingOrder) {
        for (const poly of result) {
            if (polygonWindingOrder(poly) !== originalWindingOrder) {
                poly.vertices.reverse();
            }
        }
    }
    return result.length > 0 ? result : null;
}
/**
 * Check if a point is on a ray
 */
function pointOnRay(point, ray) {
    // Vector from ray origin to point
    const toPoint = vec_1.vec2.sub(point, ray.origin);
    // Get normalized ray direction
    const rayDirection = vec_1.vec2.nor(ray.direction);
    // Project toPoint onto the ray direction
    const projection = vec_1.vec2.dot(toPoint, rayDirection);
    // Calculate closest point on ray
    const closestPoint = vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDirection, Math.max(0, projection)));
    // Calculate distance from point to closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    // The point intersects the ray if the distance is effectively zero and the
    // projection is non-negative (meaning the point is in the direction of the
    // ray and not behind it)
    const intersects = distance < constants.EPSILON && projection >= 0;
    // Calculate the intersection normal
    let normal;
    if (!intersects) {
        // Get a vector perpendicular to the ray direction by rotating it 90 degrees
        const rayNormal = vec_1.vec2.rotf(rayDirection, -1);
        // Use the cross product to determine which side of the ray the point is on
        const crossProduct = vec_1.vec2.cross(rayDirection, toPoint);
        // If cross product is negative, point is on the right side of the ray
        // If positive, point is on the left side
        normal = vec_1.vec2.mul(rayNormal, Math.sign(crossProduct));
    }
    return {
        intersects,
        closestPoint,
        distance,
        normal,
    };
}
/**
 * Check if a point intersects a line segment
 */
function pointOnLine(point, line) {
    // Get vector from line start to end
    const lineVector = vec_1.vec2.sub(line.end, line.start);
    // Get normalized line direction
    const lineDirection = vec_1.vec2.nor(lineVector);
    // Get vector from line start to point
    const toPoint = vec_1.vec2.sub(point, line.start);
    // Project toPoint onto the line direction
    const projection = vec_1.vec2.dot(toPoint, lineDirection);
    // Get line length
    const lineLength = vec_1.vec2.len(lineVector);
    // Clamp projection to line segment
    const clampedProjection = Math.max(0, Math.min(lineLength, projection));
    // Calculate closest point on line segment
    const closestPoint = vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDirection, clampedProjection));
    // Calculate distance from point to closest point
    const distance = vec_1.vec2.len(vec_1.vec2.sub(point, closestPoint));
    // Point is on line if distance is effectively zero
    const intersects = distance < constants.EPSILON;
    // Calculate the intersection normal
    let normal;
    if (!intersects) {
        // Get a vector perpendicular to the ray direction by rotating it 90 degrees
        const rayNormal = vec_1.vec2.rotf(lineDirection, -1);
        // Use the cross product to determine which side of the ray the point is on
        const crossProduct = vec_1.vec2.cross(lineDirection, toPoint);
        // If cross product is negative, point is on the right side of the ray
        // If positive, point is on the left side
        normal = vec_1.vec2.mul(rayNormal, Math.sign(crossProduct));
    }
    return {
        intersects,
        closestPoint,
        distance,
        normal,
    };
}
/**
 * Check if a point is inside a circle
 */
function pointInCircle(point, circle) {
    // Calculate vector from circle center to point
    const toPoint = vec_1.vec2.sub(point, circle.position);
    // Calculate distance from point to circle center
    const distanceToCenter = vec_1.vec2.len(toPoint);
    // Check if point is inside the circle
    const intersects = distanceToCenter <= circle.radius;
    // Calculate distance to circle edge
    const distance = intersects
        ? -(circle.radius - distanceToCenter) // Negative if inside
        : distanceToCenter - circle.radius; // Positive if outside
    // Calculate closest point on circle edge
    const closestPoint = vec_1.vec2.add(circle.position, vec_1.vec2.mul(vec_1.vec2.nor(toPoint), circle.radius));
    // Calculate the intersection normal
    const normal = intersects
        ? vec_1.vec2.nor(toPoint) // Normal points outward from circle center
        : undefined;
    return {
        intersects,
        closestPoint,
        distance,
        normal,
    };
}
/**
 * Check if a point is inside a rectangle
 *
 * In cases where the closest point is ambiguous (e.g. corners), the first edge
 * encountered with a closest point will be returned after evaluating edges in
 * this order:
 * top, right, bottom, left (before applying the rectangle's rotation)
 */
function pointInRectangle(point, rectangle) {
    // Edge case: zero-size rectangle
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        // If the rectangle has no size, check if the point is at the rectangle's
        // position
        const isAtPosition = (0, utilities_1.vectorsAlmostEqual)(point, rectangle.position);
        return {
            intersects: isAtPosition,
            closestPoint: rectangle.position,
            distance: isAtPosition
                ? 0
                : vec_1.vec2.len(vec_1.vec2.sub(point, rectangle.position)),
        };
    }
    // Convert rectangle to polygon
    const vertices = rectangleVertices(rectangle);
    const polygonResult = pointInPolygon(point, { vertices });
    // We should always have a valid polygon, but just in case...
    if (!polygonResult) {
        throw new Error('Invalid rectangle vertices');
    }
    return polygonResult;
}
/**
 * Check if a point is inside a polygon
 *
 * Returns null if the polygon is invalid
 */
function pointInPolygon(point, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Check the polygon's winding order (we'll need this later to calculate
    // the intersecting surface normal)
    const windingOrder = polygonWindingOrder(polygon);
    // Find if point is inside polygon using ray casting algorithm
    let inside = false;
    const vertices = polygon.vertices;
    // We'll also keep track of the closest edge while we iterate
    let minDistanceSquared = Infinity;
    let closestPoint = point;
    let normal = undefined;
    for (let i = 0; i < vertices.length; i++) {
        const j = (i + 1) % vertices.length;
        const vi = vertices[i];
        const vj = vertices[j];
        // Ray casting algorithm
        if (vi.y > point.y !== vj.y > point.y &&
            point.x < ((vj.x - vi.x) * (point.y - vi.y)) / (vj.y - vi.y) + vi.x) {
            inside = !inside;
        }
        // Find closest point on this edge
        const edge = { start: vi, end: vj };
        const { closestPoint: edgeClosest, distance: edgeDistance } = pointOnLine(point, edge);
        const distanceSquared = edgeDistance * edgeDistance;
        if (distanceSquared < minDistanceSquared) {
            minDistanceSquared = distanceSquared;
            closestPoint = edgeClosest;
            normal = vec_1.vec2.rotf(vec_1.vec2.nor(vec_1.vec2.sub(vj, vi)), windingOrder === 'clockwise' ? 1 : -1);
        }
    }
    const distance = Math.sqrt(minDistanceSquared);
    return {
        intersects: inside,
        closestPoint,
        distance: inside ? -distance : distance,
        normal: inside ? normal : undefined,
    };
}
/**
 * Check which grid cells a ray traverses
 *
 * Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides
 * and Woo
 *
 * We can optionally limit the number of cells traversed by the ray, or set
 * maxCells to -1 to continue traversing until the ray exits the grid (or until
 * we hit the hard limit of 10000 cells).
 */
function rayTraverseGrid(ray, cellSize, gridTopLeft, gridBottomRight, maxCells = -1) {
    if (cellSize <= 0) {
        return { cells: [] }; // Invalid cell size, return empty cells array
    }
    // Set a limit on the number of cells traversed
    const HARD_LIMIT = 10000;
    maxCells = (0, utils_1.clamp)(maxCells === -1 ? HARD_LIMIT : maxCells, 0, HARD_LIMIT);
    if (maxCells <= 0) {
        return { cells: [] }; // No cells to traverse
    }
    // Make sure the grid top-left and bottom-right boundaries are integers
    gridTopLeft = vec_1.vec2.map(gridTopLeft, Math.floor);
    gridBottomRight = vec_1.vec2.map(gridBottomRight, Math.ceil);
    // Normalize ray direction and handle zero components
    const rayDir = vec_1.vec2.nor(ray.direction);
    if ((0, utilities_1.vectorAlmostZero)(rayDir)) {
        return { cells: [] };
    }
    const cells = [];
    // Calculate initial cell coordinates
    let currentCell = vec_1.vec2.map(vec_1.vec2.div(vec_1.vec2.sub(ray.origin, gridTopLeft), cellSize), Math.floor);
    // Calculate grid size in cells
    const gridSize = vec_1.vec2.sub(gridBottomRight, gridTopLeft);
    // If starting point is outside grid bounds, find entry point
    if (currentCell.x < 0 ||
        currentCell.x >= gridSize.x ||
        currentCell.y < 0 ||
        currentCell.y >= gridSize.y) {
        // Use rayIntersectsRectangle to find grid entry point
        const gridRect = {
            position: vec_1.vec2.add(gridTopLeft, vec_1.vec2.div(vec_1.vec2.sub(gridBottomRight, gridTopLeft), 2)),
            size: vec_1.vec2.sub(gridBottomRight, gridTopLeft),
        };
        const intersection = rayIntersectsRectangle(ray, gridRect);
        if (!intersection.intersects || !intersection.intersectionPoints) {
            return { cells }; // Ray misses grid entirely
        }
        // Get the first intersection point (closest to ray origin)
        const entryPoint = intersection.intersectionPoints[0];
        currentCell = vec_1.vec2.map(vec_1.vec2.div(vec_1.vec2.sub(entryPoint, gridTopLeft), cellSize), Math.floor);
        // Check if entry point is valid (this should never fail but check anyway)
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y) {
            return { cells }; // No valid entry point found
        }
    }
    // Calculate step direction (either 1 or -1) for each axis
    const step = {
        x: Math.sign(rayDir.x),
        y: Math.sign(rayDir.y),
    };
    // Calculate tDelta - distance along ray from one grid line to next
    const tDelta = {
        x: rayDir.x !== 0 ? Math.abs(cellSize / rayDir.x) : Infinity,
        y: rayDir.y !== 0 ? Math.abs(cellSize / rayDir.y) : Infinity,
    };
    // Calculate initial cell boundary positions
    const initialBoundary = (0, vec_1.vec2)(gridTopLeft.x + (currentCell.x + (step.x > 0 ? 1 : 0)) * cellSize, gridTopLeft.y + (currentCell.y + (step.y > 0 ? 1 : 0)) * cellSize);
    // Calculate initial tMax values, handling boundary cases
    const tMax = {
        x: rayDir.x !== 0
            ? Math.abs((initialBoundary.x - ray.origin.x) / rayDir.x)
            : Infinity,
        y: rayDir.y !== 0
            ? Math.abs((initialBoundary.y - ray.origin.y) / rayDir.y)
            : Infinity,
    };
    // If we're exactly on a boundary, we need to adjust tMax
    if (Math.abs(ray.origin.x - initialBoundary.x) < constants.EPSILON) {
        tMax.x = tDelta.x;
    }
    if (Math.abs(ray.origin.y - initialBoundary.y) < constants.EPSILON) {
        tMax.y = tDelta.y;
    }
    // Add starting cell
    cells.push((0, vec_1.vec2)(currentCell.x, currentCell.y));
    let cellCount = 1;
    // Main loop
    while (cellCount < maxCells &&
        currentCell.x >= 0 &&
        currentCell.x < gridSize.x &&
        currentCell.y >= 0 &&
        currentCell.y < gridSize.y) {
        // Advance to next cell based on shortest tMax
        if (tMax.x < tMax.y) {
            tMax.x += tDelta.x;
            currentCell.x += step.x;
        }
        else {
            tMax.y += tDelta.y;
            currentCell.y += step.y;
        }
        // Check if we're still in bounds
        if (currentCell.x < 0 ||
            currentCell.x >= gridSize.x ||
            currentCell.y < 0 ||
            currentCell.y >= gridSize.y) {
            break;
        }
        // Add current cell
        cells.push((0, vec_1.vec2)(currentCell.x, currentCell.y));
        cellCount++;
    }
    return { cells };
}
/**
 * Check if two rays intersect
 */
function rayIntersectsRay(rayA, rayB) {
    // Normalize the direction vectors
    const dirA = vec_1.vec2.nor(rayA.direction);
    const dirB = vec_1.vec2.nor(rayB.direction);
    // If either ray has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(dirA) || (0, utilities_1.vectorAlmostZero)(dirB)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(dirA, dirB);
    // Get the vector between starting points
    const startDiff = vec_1.vec2.sub(rayB.origin, rayA.origin);
    // If determinant is close to 0, rays are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if rays are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, dirA)) < constants.EPSILON) {
            // Rays are collinear - check if they overlap
            const t = vec_1.vec2.dot(startDiff, dirA);
            // For rays pointing in the same direction:
            // If t <= 0: rayA's origin is behind or at rayB's origin
            // If t >= 0: rayB's origin is behind or at rayA's origin
            // dot(dirA, dirB) should be close to 1 for same direction
            if ((t <= 0 || t >= 0) && vec_1.vec2.dot(dirA, dirB) > 1 - constants.EPSILON) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping rays
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, dirB) / det;
    const s = vec_1.vec2.cross(startDiff, dirA) / det;
    // Check if intersection occurs on both rays (t >= 0 and s >= 0)
    if (t >= 0 && s >= 0) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(rayA.origin, vec_1.vec2.mul(dirA, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a ray intersects a line segment
 */
function rayIntersectsLine(ray, line) {
    // Convert line to a direction vector
    const lineDir = vec_1.vec2.sub(line.end, line.start);
    // Normalize the ray direction
    const rayDir = vec_1.vec2.nor(ray.direction);
    // If either the ray or the line has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(lineDir) || (0, utilities_1.vectorAlmostZero)(rayDir)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(rayDir, lineDir);
    // Get the vector between ray origin and line start
    const startDiff = vec_1.vec2.sub(line.start, ray.origin);
    // If determinant is close to 0, ray and line are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if they are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, rayDir)) < constants.EPSILON) {
            // They are collinear - project the line endpoints onto the ray
            const t1 = vec_1.vec2.dot(vec_1.vec2.sub(line.start, ray.origin), rayDir);
            const t2 = vec_1.vec2.dot(vec_1.vec2.sub(line.end, ray.origin), rayDir);
            // Check if any part of the line segment is in front of the ray
            if ((t1 >= 0 || t2 >= 0) && Math.min(t1, t2) <= vec_1.vec2.len(lineDir)) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping segments
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, lineDir) / det; // Ray parameter
    const s = vec_1.vec2.cross(startDiff, rayDir) / det; // Line parameter
    // Check if intersection occurs on the ray (t >= 0) and within the line
    // segment (0 <= s <= 1)
    if (t >= 0 && s >= 0 && s <= 1) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a ray intersects a circle
 */
function rayIntersectsCircle(ray, circle) {
    // 1. Parameterized ray equation: P(t) = origin + t * direction
    const rayDir = vec_1.vec2.nor(ray.direction);
    // Calculate vector from ray origin to circle center
    const toCenter = vec_1.vec2.sub(circle.position, ray.origin);
    // 2. Substitute ray equation into circle equation:
    // (origin.x + t*dir.x - circle.x)² + (origin.y + t*dir.y - circle.y)² = r²
    // Expand and collect terms to get quadratic equation: at² + bt + c = 0
    // a = dot(dir, dir) (should be 1 since dir is normalized)
    const a = vec_1.vec2.dot(rayDir, rayDir);
    // b = 2 * dot(dir, (origin - center))
    const b = 2 * vec_1.vec2.dot(rayDir, vec_1.vec2.mul(toCenter, -1));
    // c = dot((origin - center), (origin - center)) - radius²
    const c = vec_1.vec2.dot(toCenter, toCenter) - circle.radius * circle.radius;
    // 3. Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // 4. Check if solutions exist (discriminant >= 0)
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where ray just touches circle (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0) {
            const point = vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // 5. Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    // If both t values are negative, ray points away from circle
    if (t2 < 0) {
        return { intersects: false };
    }
    // Calculate intersection points for positive t values
    let intersectionPoints = [];
    if (t1 >= 0) {
        intersectionPoints.push(vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t1)));
    }
    if (t2 >= 0) {
        intersectionPoints.push(vec_1.vec2.add(ray.origin, vec_1.vec2.mul(rayDir, t2)));
    }
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a rectangle
 */
function rayIntersectsRectangle(ray, rectangle) {
    // Get vertices of the rectangle in clockwise order
    const vertices = rectangleVertices(rectangle);
    let intersectionPoints = [];
    // Check each edge of the rectangle for intersection
    const edges = verticesToEdges(vertices);
    for (const edge of edges) {
        const intersection = rayIntersectsLine(ray, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to ray origin
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        const rayDir = vec_1.vec2.nor(ray.direction);
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.dot(vec_1.vec2.sub(a, ray.origin), rayDir);
            const distB = vec_1.vec2.dot(vec_1.vec2.sub(b, ray.origin), rayDir);
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function rayIntersectsValidConvexPolygonEdges(ray, edges) {
    let intersectionPoints = [];
    // Check each outer edge for intersections
    for (const edge of edges) {
        const intersection = rayIntersectsLine(ray, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to ray origin
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        const rayDir = vec_1.vec2.nor(ray.direction);
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.dot(vec_1.vec2.sub(a, ray.origin), rayDir);
            const distB = vec_1.vec2.dot(vec_1.vec2.sub(b, ray.origin), rayDir);
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a ray intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function rayIntersectsPolygon(ray, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // Check the ray against the outer edges of each convex polygons
        return rayIntersectsValidConvexPolygonEdges(ray, findOuterEdges(convexPolygons));
    }
    // For convex polygons, check each edge
    return rayIntersectsValidConvexPolygonEdges(ray, verticesToEdges(polygon.vertices));
}
/**
 * Check if a line segment intersects a ray
 */
function lineIntersectsRay(line, ray) {
    return rayIntersectsLine(ray, line);
}
/**
 * Check if two line segments intersect
 */
function lineIntersectsLine(lineA, lineB) {
    // Get the vectors representing the directions of each line
    const dirA = vec_1.vec2.sub(lineA.end, lineA.start);
    const dirB = vec_1.vec2.sub(lineB.end, lineB.start);
    // If either line has zero direction, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(dirA) || (0, utilities_1.vectorAlmostZero)(dirB)) {
        return {
            intersects: false,
        };
    }
    // Calculate the cross product determinant
    const det = vec_1.vec2.cross(dirA, dirB);
    // Get the vector between starting points
    const startDiff = vec_1.vec2.sub(lineB.start, lineA.start);
    // If determinant is close to 0, lines are parallel or collinear
    if (Math.abs(det) < constants.EPSILON) {
        // Check if lines are collinear
        if (Math.abs(vec_1.vec2.cross(startDiff, dirA)) < constants.EPSILON) {
            // Lines are collinear - check if they overlap
            const t0 = vec_1.vec2.dot(startDiff, dirA) / vec_1.vec2.dot(dirA, dirA);
            const t1 = t0 + vec_1.vec2.dot(dirB, dirA) / vec_1.vec2.dot(dirA, dirA);
            // Check if segments overlap
            const interval0 = Math.min(t0, t1);
            const interval1 = Math.max(t0, t1);
            if (interval0 <= 1 && interval1 >= 0) {
                return {
                    intersects: true,
                    // No single intersection point for overlapping lines
                };
            }
        }
        return {
            intersects: false,
        };
    }
    // Calculate intersection parameters
    const t = vec_1.vec2.cross(startDiff, dirB) / det;
    const s = vec_1.vec2.cross(startDiff, dirA) / det;
    // Check if intersection occurs within both line segments
    if (t >= 0 && t <= 1 && s >= 0 && s <= 1) {
        return {
            intersects: true,
            intersectionPoint: vec_1.vec2.add(lineA.start, vec_1.vec2.mul(dirA, t)),
        };
    }
    return {
        intersects: false,
    };
}
/**
 * Check if a line segment intersects a circle
 */
function lineIntersectsCircle(line, circle) {
    // 1. Parameterized line equation: P(t) = start + t * (end - start)
    const lineDir = vec_1.vec2.sub(line.end, line.start);
    const lineLengthSquared = vec_1.vec2.dot(lineDir, lineDir);
    // If the line segment has zero length, it cannot intersect
    if (lineLengthSquared < constants.EPSILON) {
        return { intersects: false };
    }
    // If both endpoints of the line are inside the circle, then we have an
    // intersection (but no intersection points)
    if (pointInCircle(line.start, circle).intersects &&
        pointInCircle(line.end, circle).intersects) {
        return { intersects: true };
    }
    // Calculate vector from circle center to line start
    const toCenter = vec_1.vec2.sub(circle.position, line.start);
    // 2. Substitute line equation into circle equation:
    // (start.x + t*dir.x - circle.x)² + (start.y + t*dir.y - circle.y)² = r²
    // Expand and collect terms to get quadratic equation: at² + bt + c = 0
    // a = dot(dir, dir)
    const a = lineLengthSquared;
    // b = 2 * dot(dir, (start - center))
    const b = 2 * vec_1.vec2.dot(lineDir, vec_1.vec2.mul(toCenter, -1));
    // c = dot((start - center), (start - center)) - radius²
    const c = vec_1.vec2.dot(toCenter, toCenter) - circle.radius * circle.radius;
    // 3. Solve quadratic equation using discriminant
    const discriminant = b * b - 4 * a * c;
    // If discriminant is negative, no intersection
    if (discriminant < -constants.EPSILON) {
        return { intersects: false };
    }
    // Handle case where line just touches circle (discriminant ≈ 0)
    if (Math.abs(discriminant) < constants.EPSILON) {
        const t = -b / (2 * a);
        if (t >= 0 && t <= 1) {
            const point = vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t));
            return {
                intersects: true,
                intersectionPoints: [point],
            };
        }
        return { intersects: false };
    }
    // Calculate intersection points for discriminant > 0
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b - sqrtDiscriminant) / (2 * a);
    const t2 = (-b + sqrtDiscriminant) / (2 * a);
    let intersectionPoints = [];
    // If both t values are outside [0, 1], no intersection
    if (t2 < 0 || t1 > 1) {
        return { intersects: false };
    }
    // Calculate intersection points for valid t values
    if (t1 >= 0 && t1 <= 1) {
        intersectionPoints.push(vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t1)));
    }
    if (t2 >= 0 && t2 <= 1) {
        intersectionPoints.push(vec_1.vec2.add(line.start, vec_1.vec2.mul(lineDir, t2)));
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a rectangle
 */
function lineIntersectsRectangle(line, rectangle) {
    // Edge case: zero-size rectangle
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        return {
            intersects: false,
        };
    }
    // Get vertices of the rectangle in clockwise order
    const vertices = rectangleVertices(rectangle);
    // If both endpoints are inside, line is completely contained
    if (pointInRectangle(line.start, rectangle).intersects &&
        pointInRectangle(line.end, rectangle).intersects) {
        return {
            intersects: true,
        };
    }
    let intersectionPoints = [];
    // Check each edge of the rectangle for intersection
    const edges = verticesToEdges(vertices);
    for (const edge of edges) {
        const intersection = lineIntersectsLine(line, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function lineIntersectsValidConvexPolygonEdges(line, polygon, edges) {
    // Special case: line segment is entirely inside polygon
    const midpoint = {
        x: (line.start.x + line.end.x) / 2,
        y: (line.start.y + line.end.y) / 2,
    };
    const pointInside = pointInPolygon(midpoint, polygon);
    const startInside = pointInPolygon(line.start, polygon);
    const endInside = pointInPolygon(line.end, polygon);
    if ((pointInside === null || pointInside === void 0 ? void 0 : pointInside.intersects) &&
        (startInside === null || startInside === void 0 ? void 0 : startInside.intersects) &&
        (endInside === null || endInside === void 0 ? void 0 : endInside.intersects)) {
        return {
            intersects: true,
        };
    }
    let intersectionPoints = [];
    // Check each outer edge for intersections
    for (const edge of edges) {
        const intersection = lineIntersectsLine(line, edge);
        if (intersection.intersects && intersection.intersectionPoint) {
            intersectionPoints.push(intersection.intersectionPoint);
        }
    }
    // Remove duplicate intersection points and sort by distance to line start
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    if (intersectionPoints.length > 1) {
        intersectionPoints.sort((a, b) => {
            const distA = vec_1.vec2.len(vec_1.vec2.sub(a, line.start));
            const distB = vec_1.vec2.len(vec_1.vec2.sub(b, line.start));
            return distA - distB;
        });
    }
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a line segment intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function lineIntersectsPolygon(line, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // Check the line against the outer edges of each convex polygon
        return lineIntersectsValidConvexPolygonEdges(line, polygon, findOuterEdges(convexPolygons));
    }
    // For convex polygons, check each edge
    return lineIntersectsValidConvexPolygonEdges(line, polygon, verticesToEdges(polygon.vertices));
}
/**
 * Check if two circles intersect
 */
function circleIntersectsCircle(circleA, circleB) {
    // Calculate the vector from center A to center B
    const centerToCenterVec = vec_1.vec2.sub(circleB.position, circleA.position);
    const centerToCenter = vec_1.vec2.len(centerToCenterVec);
    const sumRadii = circleA.radius + circleB.radius;
    // If distance between centers is greater than sum of radii, the circles
    // don't intersect
    if (centerToCenter > sumRadii + constants.EPSILON) {
        return { intersects: false };
    }
    // If circles are identical (same position and radius), they have infinitely
    // many intersection points
    if (centerToCenter < constants.EPSILON &&
        Math.abs(circleA.radius - circleB.radius) < constants.EPSILON) {
        return {
            intersects: true,
            minimumSeparation: vec_1.vec2.mul(vec_1.vec2.ux(), 2 * circleA.radius),
        };
    }
    // Check if one circle is inside the other (no intersection points but still
    // intersecting)
    const radiusDiff = Math.abs(circleA.radius - circleB.radius);
    if (centerToCenter < radiusDiff - constants.EPSILON) {
        return {
            intersects: true,
            minimumSeparation: vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), circleA.radius - centerToCenter + circleB.radius),
        };
    }
    // Calculate intersection points for standard intersecting case
    // http://mathworld.wolfram.com/Circle-CircleIntersection.html
    const a = (circleA.radius * circleA.radius -
        circleB.radius * circleB.radius +
        centerToCenter * centerToCenter) /
        (2 * centerToCenter);
    const h = Math.sqrt(Math.max(0, circleA.radius * circleA.radius - a * a));
    // Calculate the point on the line between centers that is distance 'a' from
    // circle A's center
    const p = vec_1.vec2.add(circleA.position, vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), a));
    // If circles are tangent (touching at one point)
    if (Math.abs(centerToCenter - sumRadii) < constants.EPSILON) {
        return {
            intersects: true,
            intersectionPoints: [p],
            minimumSeparation: (0, vec_1.vec2)(),
        };
    }
    // Calculate the perpendicular vector to get both intersection points
    const perpVec = vec_1.vec2.mul((0, vec_1.vec2)({ x: -centerToCenterVec.y, y: centerToCenterVec.x }), h / centerToCenter);
    const intersectionPoints = [vec_1.vec2.add(p, perpVec), vec_1.vec2.sub(p, perpVec)];
    // Calculate the minimum separation vector
    const minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(centerToCenterVec), sumRadii - centerToCenter);
    return {
        intersects: true,
        intersectionPoints,
        minimumSeparation,
    };
}
/**
 * Check if a circle intersects a rectangle
 */
function circleIntersectsRectangle(circle, rectangle) {
    // Get rectangle vertices so we can test against rotated rectangles
    const vertices = rectangleVertices(rectangle);
    const edges = verticesToEdges(vertices);
    // Check if circle's center is inside rectangle
    const pointInRectResult = pointInRectangle(circle.position, rectangle);
    const circleCenterInsideRectangle = pointInRectResult.intersects;
    // Check if rectangle's center is inside circle
    const pointInCircleResult = pointInCircle(rectangle.position, circle);
    const rectangleCenterInsideCircle = pointInCircleResult.intersects;
    // Check circle intersection with rectangle edges
    const intersectionPoints = [];
    for (const edge of edges) {
        const result = lineIntersectsCircle(edge, circle);
        if (result.intersects && result.intersectionPoints) {
            intersectionPoints.push(...result.intersectionPoints);
        }
    }
    // Calculate the minimum separation vector
    let minimumSeparation;
    if (Math.abs(pointInRectResult.distance) < constants.EPSILON) {
        minimumSeparation = (0, vec_1.vec2)();
    }
    else if (pointInRectResult.distance < 0) {
        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInRectResult.closestPoint, circle.position)), circle.radius + Math.abs(pointInRectResult.distance));
    }
    else {
        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circle.position, pointInRectResult.closestPoint)), circle.radius - pointInRectResult.distance);
    }
    // If either shape's center is inside the other and there are no intersection
    // points, it means one of the shapes completely encloses the other
    if ((circleCenterInsideRectangle || rectangleCenterInsideCircle) &&
        intersectionPoints.length === 0) {
        return {
            intersects: true,
            minimumSeparation,
        };
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    if (uniquePoints.length > 0) {
        return {
            intersects: true,
            intersectionPoints: uniquePoints,
            minimumSeparation,
        };
    }
    return { intersects: false };
}
/**
 * Check if a circle intersects the edges of a convex polygon
 *
 * We assume the polygon has already been checked for validity and convexity
 */
function circleIntersectsValidConvexPolygonEdges(circle, edges, circleCenterInsidePolygon, polygonCenterInsideCircle) {
    let intersectionPoints = [];
    // Check each outer edge for intersections with the circle
    for (const edge of edges) {
        const result = lineIntersectsCircle(edge, circle);
        if (result.intersects && result.intersectionPoints) {
            intersectionPoints.push(...result.intersectionPoints);
        }
    }
    // If either shape's center is inside the other and there are no
    // intersection points, one shape completely encloses the other
    if ((circleCenterInsidePolygon || polygonCenterInsideCircle) &&
        intersectionPoints.length === 0) {
        return { intersects: true };
    }
    // Remove duplicate intersection points
    intersectionPoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: intersectionPoints.length > 0,
        intersectionPoints: intersectionPoints.length > 0 ? intersectionPoints : undefined,
    };
}
/**
 * Check if a circle intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function circleIntersectsPolygon(circle, polygon, options) {
    var _a, _b, _c, _d, _e, _f;
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    const MAX_ITERATIONS = 10;
    const findMinimumSeparation = (_a = options === null || options === void 0 ? void 0 : options.findMinimumSeparation) !== null && _a !== void 0 ? _a : false;
    // Check if circle's center is inside polygon
    const pointInPolygonResult = pointInPolygon(circle.position, polygon);
    const circleCenterInsidePolygon = (_b = pointInPolygonResult === null || pointInPolygonResult === void 0 ? void 0 : pointInPolygonResult.intersects) !== null && _b !== void 0 ? _b : false;
    // If polygon is not convex, decompose it into convex polygons
    if (!polygonIsConvex(polygon)) {
        const convexPolygons = decomposePolygon(polygon);
        if (!convexPolygons) {
            return null;
        }
        // For a concave polygon, the centroid might be outside of the polygon, so
        // in order to check if the polygon is entirely inside the circle, we need
        // to check if all sub-polygon centroids are inside the circle
        const polygonCenterInsideCircle = convexPolygons.every(convexPolygon => {
            var _a;
            const centroid = polygonCentroid(convexPolygon);
            if (!centroid) {
                return false; // Invalid centroid
            }
            return (_a = pointInCircle(centroid, circle).intersects) !== null && _a !== void 0 ? _a : false;
        });
        // Find outer edges from the decomposed polygons
        const outerEdges = findOuterEdges(convexPolygons);
        const result = circleIntersectsValidConvexPolygonEdges(circle, outerEdges, circleCenterInsidePolygon, polygonCenterInsideCircle);
        if (result.intersects && findMinimumSeparation) {
            let iteration = 0;
            let previousSeparation = null;
            let currentSeparation = (0, vec_1.vec2)();
            let currentSeparationIntersects = true;
            while (
            // Continue if we still haven't found a separation that doesn't
            // intersect
            currentSeparationIntersects &&
                // Continue if we're still converging (i.e. if we didn't make any
                // progress in the last iteration then we can stop)
                (previousSeparation === null ||
                    !(0, utilities_1.vectorsAlmostEqual)(previousSeparation, currentSeparation)) &&
                // Continue until we reach the maximum number of iterations
                ++iteration < MAX_ITERATIONS) {
                let minimumSeparations = [];
                let circlePosition = vec_1.vec2.add(circle.position, currentSeparation);
                // Find minimum separation vectors for each convex sub-polygon
                for (const convexPolygon of convexPolygons) {
                    const pointInConvexPolygonResult = pointInPolygon(circlePosition, convexPolygon);
                    if (!pointInConvexPolygonResult) {
                        continue;
                    }
                    let minimumSeparation;
                    if (Math.abs(pointInConvexPolygonResult.distance) < constants.EPSILON) {
                        minimumSeparation = (0, vec_1.vec2)();
                    }
                    else if (pointInConvexPolygonResult.distance < 0) {
                        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInConvexPolygonResult.closestPoint, circlePosition)), circle.radius + Math.abs(pointInConvexPolygonResult.distance));
                    }
                    else {
                        minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circlePosition, pointInConvexPolygonResult.closestPoint)), circle.radius - pointInConvexPolygonResult.distance);
                    }
                    minimumSeparations.push({
                        separation: minimumSeparation,
                        distance: Math.abs(pointInConvexPolygonResult.distance),
                    });
                }
                // Sort minimum separations by penetration distance
                minimumSeparations = minimumSeparations.sort((a, b) => a.distance - b.distance);
                previousSeparation = vec_1.vec2.cpy(currentSeparation);
                currentSeparation = vec_1.vec2.add(currentSeparation, ((_c = minimumSeparations[0]) === null || _c === void 0 ? void 0 : _c.separation) || (0, vec_1.vec2)());
                // Check if the current separation still intersects
                currentSeparationIntersects =
                    (_e = (_d = circleIntersectsPolygon({
                        ...circle,
                        position: vec_1.vec2.add(circle.position, 
                        // Add a small buffer to avoid numerical/precision issues
                        vec_1.vec2.mul(currentSeparation, 1.01)),
                    }, polygon, {
                        ...options,
                        // Don't recurse to avoid infinite loops
                        findMinimumSeparation: false,
                    })) === null || _d === void 0 ? void 0 : _d.intersects) !== null && _e !== void 0 ? _e : false;
            }
            return {
                ...result,
                minimumSeparation: currentSeparation,
            };
        }
        return result;
    }
    // Check if polygon's centroid is inside circle
    // For a convex polygon, the centroid is always inside the polygon
    const polygonCenter = polygonCentroid(polygon);
    const pointInCircleResult = pointInCircle(polygonCenter, circle);
    const polygonCenterInsideCircle = (_f = pointInCircleResult.intersects) !== null && _f !== void 0 ? _f : false;
    // For convex polygons, check each edge directly
    const edges = verticesToEdges(polygon.vertices);
    const result = circleIntersectsValidConvexPolygonEdges(circle, edges, circleCenterInsidePolygon, polygonCenterInsideCircle);
    if (result.intersects && findMinimumSeparation) {
        // Calculate the minimum separation vector
        let minimumSeparation;
        if (Math.abs(pointInPolygonResult.distance) < constants.EPSILON) {
            minimumSeparation = (0, vec_1.vec2)();
        }
        else if (pointInPolygonResult.distance < 0) {
            minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(pointInPolygonResult.closestPoint, circle.position)), circle.radius + Math.abs(pointInPolygonResult.distance));
        }
        else {
            minimumSeparation = vec_1.vec2.mul(vec_1.vec2.nor(vec_1.vec2.sub(circle.position, pointInPolygonResult.closestPoint)), circle.radius - pointInPolygonResult.distance);
        }
        return {
            ...result,
            minimumSeparation,
        };
    }
    return result;
}
/**
 * Project vertices onto an axis and return the min/max values
 */
function projectVerticesToAxis(vertices, axis) {
    let min = Infinity;
    let max = -Infinity;
    for (const vertex of vertices) {
        const projection = vec_1.vec2.dot(vertex, axis);
        min = Math.min(min, projection);
        max = Math.max(max, projection);
    }
    return { min, max };
}
/**
 * Check if two rectangles intersect
 */
function rectangleIntersectsRectangle(rectangleA, rectangleB) {
    // Edge case: if either rectangle has zero size, they cannot intersect
    if ((0, utilities_1.vectorAlmostZero)(rectangleA.size) || (0, utilities_1.vectorAlmostZero)(rectangleB.size)) {
        return { intersects: false };
    }
    // Get vertices of both rectangles
    const verticesA = rectangleVertices(rectangleA);
    const verticesB = rectangleVertices(rectangleB);
    // Get edges of both rectangles
    const edgesA = verticesToEdges(verticesA);
    const edgesB = verticesToEdges(verticesB);
    // Get separating axes by calculating the normals of each edge
    const axes = [];
    for (const edge of [...edgesA, ...edgesB]) {
        const edgeVec = vec_1.vec2.sub(edge.end, edge.start);
        const normal = vec_1.vec2.nor(vec_1.vec2.rotf(edgeVec, -1));
        // Only add unique axes
        if (!axes.some(axis => Math.abs(vec_1.vec2.dot(axis, normal)) > 1 - constants.EPSILON)) {
            axes.push(normal);
        }
    }
    // Track minimum penetration for separation vector
    let minPenetration = Infinity;
    let minAxis = (0, vec_1.vec2)();
    // Test each axis
    for (const axis of axes) {
        // Project both rectangles onto the axis
        const projectionA = projectVerticesToAxis(verticesA, axis);
        const projectionB = projectVerticesToAxis(verticesB, axis);
        // If we find a separating axis, the rectangles don't intersect
        if (projectionA.max < projectionB.min ||
            projectionB.max < projectionA.min) {
            return { intersects: false };
        }
        // Calculate penetration depth
        const overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
        // Track minimum penetration and its axis
        if (overlap < minPenetration) {
            minPenetration = overlap;
            minAxis = axis;
        }
    }
    // Find intersection points by checking each edge of rectangle A against each
    // edge of rectangle B
    const intersectionPoints = [];
    for (const edgeA of edgesA) {
        for (const edgeB of edgesB) {
            const intersection = lineIntersectsLine(edgeA, edgeB);
            if (intersection.intersects && intersection.intersectionPoint) {
                intersectionPoints.push(intersection.intersectionPoint);
            }
        }
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    // Calculate the minimum separation vector
    const centerA = rectangleA.position;
    const centerB = rectangleB.position;
    const centerToCenter = vec_1.vec2.sub(centerB, centerA);
    // If the dot product is negative, we need to flip the axis
    if (vec_1.vec2.dot(minAxis, centerToCenter) < 0) {
        minAxis = vec_1.vec2.mul(minAxis, -1);
    }
    // The minimum separation vector is the axis scaled by the penetration depth
    const minimumSeparation = vec_1.vec2.mul(minAxis, minPenetration);
    return {
        intersects: true,
        intersectionPoints: uniquePoints.length > 0 ? uniquePoints : undefined,
        minimumSeparation,
    };
}
/**
 * Check if a rectangle intersects a polygon
 *
 * Returns null if the polygon is invalid
 */
function rectangleIntersectsPolygon(rectangle, polygon) {
    // First check if the polygon is valid
    if (!polygonIsValid(polygon)) {
        return null;
    }
    // Edge case: if the rectangle has zero size, there is no intersection
    if ((0, utilities_1.vectorAlmostZero)(rectangle.size)) {
        return { intersects: false };
    }
    // Convert rectangle to polygon
    const rectVertices = rectangleVertices(rectangle);
    const rectPolygon = {
        vertices: rectVertices,
    };
    // Use polygon intersection algorithm
    return polygonIntersectsPolygon(rectPolygon, polygon);
}
/**
 * Check if two polygons intersect
 *
 * Returns null if either polygon is invalid
 */
function polygonIntersectsPolygon(polygonA, polygonB) {
    // First check if both polygons are valid
    if (!polygonIsValid(polygonA) || !polygonIsValid(polygonB)) {
        return null;
    }
    // Decompose polygon A if it's concave
    let convexPolygonsA = [];
    if (!polygonIsConvex(polygonA)) {
        const decomposedA = decomposePolygon(polygonA);
        if (!decomposedA) {
            return null;
        }
        convexPolygonsA = decomposedA;
    }
    else {
        convexPolygonsA = [polygonA];
    }
    // Decompose polygon B if it's concave
    let convexPolygonsB = [];
    if (!polygonIsConvex(polygonB)) {
        const decomposedB = decomposePolygon(polygonB);
        if (!decomposedB) {
            return null;
        }
        convexPolygonsB = decomposedB;
    }
    else {
        convexPolygonsB = [polygonB];
    }
    // Get the outer edges of the decomposed polygons
    const outerEdgesA = findOuterEdges(convexPolygonsA);
    const outerEdgesB = findOuterEdges(convexPolygonsB);
    // Find intersection points between outer edges only
    const intersectionPoints = [];
    for (const edgeA of outerEdgesA) {
        for (const edgeB of outerEdgesB) {
            const intersection = lineIntersectsLine(edgeA, edgeB);
            if (intersection.intersects && intersection.intersectionPoint) {
                intersectionPoints.push(intersection.intersectionPoint);
            }
        }
    }
    // Check if one polygon is contained within the other
    // A polygon is contained within another if the centroids of all its
    // convex sub-polygons are inside the other polygon
    if (intersectionPoints.length === 0) {
        const polygonACentroids = convexPolygonsA
            .map(polygonCentroid)
            .filter(centroid => !!centroid);
        if (polygonACentroids.every(centroid => { var _a; return (_a = pointInPolygon(centroid, polygonB)) === null || _a === void 0 ? void 0 : _a.intersects; })) {
            return { intersects: true };
        }
        const polygonBCentroids = convexPolygonsB
            .map(polygonCentroid)
            .filter(centroid => !!centroid);
        if (polygonBCentroids.every(centroid => { var _a; return (_a = pointInPolygon(centroid, polygonA)) === null || _a === void 0 ? void 0 : _a.intersects; })) {
            return { intersects: true };
        }
    }
    // Remove duplicate intersection points
    const uniquePoints = removeDuplicateVertices(intersectionPoints);
    return {
        intersects: uniquePoints.length > 0,
        intersectionPoints: uniquePoints.length > 0 ? uniquePoints : undefined,
    };
}


/***/ }),

/***/ "./src/2d/types.ts":
/*!*************************!*\
  !*** ./src/2d/types.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_141290__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isPoint = isPoint;
exports.isRay = isRay;
exports.isLine = isLine;
exports.isCircle = isCircle;
exports.isAABB = isAABB;
exports.isRectangle = isRectangle;
exports.isPolygon = isPolygon;
const types_1 = __nested_webpack_require_141290__(/*! ../utilities/types */ "./src/utilities/types.ts");
/**
 * Type guard to check if a value is a Point
 */
function isPoint(value) {
    return (0, types_1.isVec2)(value);
}
/**
 * Check if a value is a Ray
 */
function isRay(value) {
    return (value &&
        typeof value === 'object' &&
        'origin' in value &&
        isPoint(value.origin) &&
        'direction' in value &&
        (0, types_1.isVec2)(value.direction));
}
/**
 * Check if a value is a Line
 */
function isLine(value) {
    return (value &&
        typeof value === 'object' &&
        'start' in value &&
        isPoint(value.start) &&
        'end' in value &&
        isPoint(value.end));
}
/**
 * Check if a value is a Circle
 */
function isCircle(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'radius' in value &&
        typeof value.radius === 'number');
}
/**
 * Check if a value is an AABB
 */
function isAABB(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec2)(value.size));
}
/**
 * Check if a value is a Rectangle
 */
function isRectangle(value) {
    return (value &&
        typeof value === 'object' &&
        'position' in value &&
        isPoint(value.position) &&
        'size' in value &&
        (0, types_1.isVec2)(value.size) &&
        ('rotation' in value ? typeof value.rotation === 'number' : true));
}
/**
 * Check if a value is a Polygon
 */
function isPolygon(value) {
    return (value &&
        typeof value === 'object' &&
        'vertices' in value &&
        Array.isArray(value.vertices) &&
        value.vertices.every(isPoint));
}


/***/ }),

/***/ "./src/utilities/constants.ts":
/*!************************************!*\
  !*** ./src/utilities/constants.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPSILON = void 0;
exports.EPSILON = 1e-6;


/***/ }),

/***/ "./src/utilities/index.ts":
/*!********************************!*\
  !*** ./src/utilities/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_143977__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vectorAlmostZero = vectorAlmostZero;
exports.vectorsAlmostEqual = vectorsAlmostEqual;
exports.valueInInterval = valueInInterval;
exports.intervalsOverlap = intervalsOverlap;
exports.overlapInterval = overlapInterval;
const constants = __importStar(__nested_webpack_require_143977__(/*! ./constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_143977__(/*! ./types */ "./src/utilities/types.ts");
__exportStar(__nested_webpack_require_143977__(/*! ./types */ "./src/utilities/types.ts"), exports);
function vectorAlmostZero(v) {
    if ((0, types_1.isVec3)(v)) {
        return (Math.abs(v.x) < constants.EPSILON &&
            Math.abs(v.y) < constants.EPSILON &&
            Math.abs(v.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(v)) {
        return (Math.abs(v.x) < constants.EPSILON && Math.abs(v.y) < constants.EPSILON);
    }
    return false;
}
function vectorsAlmostEqual(a, b) {
    if ((0, types_1.isVec3)(a) && (0, types_1.isVec3)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON &&
            Math.abs(a.z - b.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(a) && (0, types_1.isVec2)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON);
    }
    return false;
}
/**
 * Check if a value is within a specified interval
 */
function valueInInterval(value, interval) {
    const { min, minInclusive = true, max, maxInclusive = true } = interval;
    return ((minInclusive ? value >= min : value > min) &&
        (maxInclusive ? value <= max : value < max));
}
/**
 * Check if two intervals (a1, a2) and (b1, b2) overlap
 */
function intervalsOverlap(a, b) {
    return Math.max(a.min, b.min) <= Math.min(a.max, b.max);
}
/**
 * Get the overlapping part of two intervals (a1, a2) and (b1, b2)
 *
 * If the intervals do not overlap, return null
 */
function overlapInterval(a, b) {
    if (!intervalsOverlap(a, b)) {
        return null;
    }
    return { min: Math.max(a.min, b.min), max: Math.min(a.max, b.max) };
}


/***/ }),

/***/ "./src/utilities/types.ts":
/*!********************************!*\
  !*** ./src/utilities/types.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVec2 = isVec2;
exports.isVec3 = isVec3;
/**
 * Check if a value is a vec2
 */
function isVec2(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        !('z' in value));
}
/**
 * Check if a value is a vec3
 */
function isVec3(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        'z' in value &&
        typeof value.z === 'number');
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_148885__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_148885__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_148885__("./src/2d/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js ***!
  \**************************************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/utilities/constants.ts":
/*!************************************!*\
  !*** ./src/utilities/constants.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPSILON = void 0;
exports.EPSILON = 1e-6;


/***/ }),

/***/ "./src/utilities/index.ts":
/*!********************************!*\
  !*** ./src/utilities/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_1000__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vectorAlmostZero = vectorAlmostZero;
exports.vectorsAlmostEqual = vectorsAlmostEqual;
exports.valueInInterval = valueInInterval;
exports.intervalsOverlap = intervalsOverlap;
exports.overlapInterval = overlapInterval;
const constants = __importStar(__nested_webpack_require_1000__(/*! ./constants */ "./src/utilities/constants.ts"));
const types_1 = __nested_webpack_require_1000__(/*! ./types */ "./src/utilities/types.ts");
__exportStar(__nested_webpack_require_1000__(/*! ./types */ "./src/utilities/types.ts"), exports);
function vectorAlmostZero(v) {
    if ((0, types_1.isVec3)(v)) {
        return (Math.abs(v.x) < constants.EPSILON &&
            Math.abs(v.y) < constants.EPSILON &&
            Math.abs(v.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(v)) {
        return (Math.abs(v.x) < constants.EPSILON && Math.abs(v.y) < constants.EPSILON);
    }
    return false;
}
function vectorsAlmostEqual(a, b) {
    if ((0, types_1.isVec3)(a) && (0, types_1.isVec3)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON &&
            Math.abs(a.z - b.z) < constants.EPSILON);
    }
    if ((0, types_1.isVec2)(a) && (0, types_1.isVec2)(b)) {
        return (Math.abs(a.x - b.x) < constants.EPSILON &&
            Math.abs(a.y - b.y) < constants.EPSILON);
    }
    return false;
}
/**
 * Check if a value is within a specified interval
 */
function valueInInterval(value, interval) {
    const { min, minInclusive = true, max, maxInclusive = true } = interval;
    return ((minInclusive ? value >= min : value > min) &&
        (maxInclusive ? value <= max : value < max));
}
/**
 * Check if two intervals (a1, a2) and (b1, b2) overlap
 */
function intervalsOverlap(a, b) {
    return Math.max(a.min, b.min) <= Math.min(a.max, b.max);
}
/**
 * Get the overlapping part of two intervals (a1, a2) and (b1, b2)
 *
 * If the intervals do not overlap, return null
 */
function overlapInterval(a, b) {
    if (!intervalsOverlap(a, b)) {
        return null;
    }
    return { min: Math.max(a.min, b.min), max: Math.min(a.max, b.max) };
}


/***/ }),

/***/ "./src/utilities/types.ts":
/*!********************************!*\
  !*** ./src/utilities/types.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVec2 = isVec2;
exports.isVec3 = isVec3;
/**
 * Check if a value is a vec2
 */
function isVec2(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        !('z' in value));
}
/**
 * Check if a value is a vec3
 */
function isVec3(value) {
    return (value &&
        typeof value === 'object' &&
        'x' in value &&
        typeof value.x === 'number' &&
        'y' in value &&
        typeof value.y === 'number' &&
        'z' in value &&
        typeof value.z === 'number');
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_5880__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_5880__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_5880__("./src/utilities/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/scene-manager/build/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@basementuniverse/scene-manager/build/index.js ***!
  \*********************************************************************/
/***/ ((module) => {

/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else // removed by dead control flow
{ var i, a; }
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = exports.SceneTransitionState = void 0;\nvar SceneTransitionState;\n(function (SceneTransitionState) {\n    SceneTransitionState[\"In\"] = \"in\";\n    SceneTransitionState[\"Out\"] = \"out\";\n    SceneTransitionState[\"None\"] = \"none\";\n})(SceneTransitionState = exports.SceneTransitionState || (exports.SceneTransitionState = {}));\nfunction clamp(a, min = 0, max = 1) {\n    return a < min ? min : (a > max ? max : a);\n}\nclass SceneManager {\n    constructor() {\n        this.scenes = [];\n    }\n    /**\n     * Initialise the scene manager for managing game scenes\n     */\n    static initialise() {\n        if (SceneManager.instance) {\n            throw new Error('SceneManager already initialised');\n        }\n        SceneManager.instance = new SceneManager();\n    }\n    static getInstance() {\n        if (!SceneManager.instance) {\n            throw new Error('SceneManager not properly initialised');\n        }\n        return SceneManager.instance;\n    }\n    /**\n     * Push a scene onto the scene stack and start transitioning in\n     */\n    static push(scene, ...args) {\n        const instance = SceneManager.getInstance();\n        instance.scenes.push(scene);\n        // Initialise the scene and start the transition\n        scene.initialise(...args);\n        scene.transitionIn();\n        return scene;\n    }\n    /**\n     * Remove a scene from the scene stack after transitioning out\n     */\n    static pop() {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            let last = instance.scenes.length - 1;\n            // Remove the top-most scene that isn't currently transitioning out\n            while (last > 0 &&\n                instance.scenes[last].transitionState === SceneTransitionState.Out) {\n                last--;\n            }\n            if (last >= 0) {\n                const scene = instance.scenes[last];\n                // Start transitioning out\n                scene.transitionOut();\n                return scene;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Remove all scene from the scene stack\n     */\n    static clear() {\n        const instance = SceneManager.getInstance();\n        instance.scenes.forEach(scene => {\n            if (scene.transitionState !== SceneTransitionState.Out) {\n                scene.transitionOut();\n            }\n        });\n    }\n    /**\n     * Update the scene manager and the current scene\n     */\n    static update(dt, ...args) {\n        const instance = SceneManager.getInstance();\n        if (instance.scenes.length > 0) {\n            // Only update the top-most scene that isn't currently transitioning out\n            for (let i = instance.scenes.length; i--;) {\n                if (instance.scenes[i].transitionState !== SceneTransitionState.Out) {\n                    instance.scenes[i].update(dt, ...args);\n                    break;\n                }\n            }\n            // Update all scene transitions\n            instance.scenes.forEach(scene => {\n                scene.updateTransition(dt);\n            });\n            // Remove any disposed scenes\n            instance.scenes = instance.scenes.filter(scene => !scene.disposed);\n        }\n    }\n    /**\n     * Render scenes on the screen\n     */\n    static draw(context, ...args) {\n        const instance = SceneManager.getInstance();\n        // Figure out which scenes we need to draw\n        const drawList = [];\n        for (let i = instance.scenes.length; i--;) {\n            const scene = instance.scenes[i];\n            drawList.push(scene);\n            // If transitioning, this scene is assumed to be transparent\n            // (we might want to show the scene underneath if we're doing e.g. a fade)\n            if (!scene.transparent &&\n                scene.transitionState === SceneTransitionState.None) {\n                break;\n            }\n        }\n        // Draw the scenes in bottom -> top order\n        drawList.reverse().forEach(scene => {\n            scene.draw(context, ...args);\n        });\n    }\n    /**\n     * Let all scenes know that a resize event has occurred\n     */\n    static resize(width, height) {\n        var _a;\n        const instance = SceneManager.getInstance();\n        for (const scene of instance.scenes) {\n            (_a = scene.resize) === null || _a === void 0 ? void 0 : _a.call(scene, width, height);\n        }\n    }\n}\nexports[\"default\"] = SceneManager;\nclass Scene {\n    constructor(options) {\n        this.defaultOptions = {\n            transitionTime: 2,\n            transparent: true,\n        };\n        this.transitionState = SceneTransitionState.None;\n        this.transitionAmount = 0;\n        this.transitionTime = 0;\n        this.transparent = false;\n        this.disposed = false;\n        const actualOptions = Object.assign({}, this.defaultOptions, options);\n        this.transitionTime = actualOptions.transitionTime;\n        this.transparent = actualOptions.transparent;\n        this.onTransitionedIn = actualOptions.onTransitionedIn;\n        this.onTransitionedOut = actualOptions.onTransitionedOut;\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    transitionIn() {\n        this.transitionState = SceneTransitionState.In;\n    }\n    transitionOut() {\n        this.transitionState = SceneTransitionState.Out;\n    }\n    updateTransition(dt) {\n        var _a, _b;\n        const amount = dt / this.transitionTime;\n        // Transitioning in\n        if (this.transitionState === SceneTransitionState.In) {\n            if (this.transitionAmount < 1) {\n                this.transitionAmount = clamp(this.transitionAmount + amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                (_a = this.onTransitionedIn) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        }\n        // Transitioning out\n        if (this.transitionState === SceneTransitionState.Out) {\n            if (this.transitionAmount > 0) {\n                this.transitionAmount = clamp(this.transitionAmount - amount);\n            }\n            else {\n                this.transitionState = SceneTransitionState.None;\n                this.dispose();\n                (_b = this.onTransitionedOut) === null || _b === void 0 ? void 0 : _b.call(this);\n            }\n        }\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://@basementuniverse/scene-manager/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = {};
/******/ 	__webpack_modules__["./index.ts"](0, __nested_webpack_exports__);
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @overview A library of useful functions
 * @author Gordon Larrigan
 */

/**
 * Memoize a function
 * @param {Function} f The function to memoize
 * @returns {Function} A memoized version of the function
 */
const memoize = f => {
  var cache = {};
  return function(...args) {
    return cache[args] ?? (cache[args] = f.apply(this, args));
  };
};

/**
 * Check if two numbers are approximately equal
 * @param {number} a Number a
 * @param {number} b Number b
 * @param {number} [p=Number.EPSILON] The precision value
 * @return {boolean} True if numbers a and b are approximately equal
 */
const floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;

/**
 * Clamp a number between min and max
 * @param {number} a The number to clamp
 * @param {number} [min=0] The minimum value
 * @param {number} [max=1] The maximum value
 * @return {number} A clamped number
 */
const clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);

/**
 * Get the fractional part of a number
 * @param {number} a The number from which to get the fractional part
 * @return {number} The fractional part of the number
 */
const frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);

/**
 * Round n to d decimal places
 * @param {number} n The number to round
 * @param {number} [d=0] The number of decimal places to round to
 * @return {number} A rounded number
 */
const round = (n, d = 0) => {
  const p = Math.pow(10, d);
  return Math.round(n * p + Number.EPSILON) / p;
}

/**
 * Do a linear interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} An interpolated value in the interval [a, b]
 */
const lerp = (a, b, i) => a + (b - a) * i;

/**
 * Get the position of i between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolated value in the interval [a, b]
 * @return {number} The position of i between a and b
 */
const unlerp = (a, b, i) => (i - a) / (b - a);

/**
 * Do a bilinear interpolation
 * @param {number} c00 Top-left value
 * @param {number} c10 Top-right value
 * @param {number} c01 Bottom-left value
 * @param {number} c11 Bottom-right value
 * @param {number} ix Interpolation value along x
 * @param {number} iy Interpolation value along y
 * @return {number} A bilinear interpolated value
 */
const blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);

/**
 * Re-map a number i from range a1...a2 to b1...b2
 * @param {number} i The number to re-map
 * @param {number} a1
 * @param {number} a2
 * @param {number} b1
 * @param {number} b2
 * @return {number}
 */
const remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);

/**
 * Do a smooth interpolation between a and b
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value
 * @return {number} An interpolated value in the interval [a, b]
 */
const smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));

/**
 * Get an angle in radians
 * @param {number} degrees The angle in degrees
 * @return {number} The angle in radians
 */
const radians = degrees => (Math.PI / 180) * degrees;

/**
 * Get an angle in degrees
 * @param {number} radians The angle in radians
 * @return {number} The angle in degrees
 */
const degrees = radians => (180 / Math.PI) * radians;

/**
 * Get a random float in the interval [min, max)
 * @param {number} min Inclusive min
 * @param {number} max Exclusive max
 * @return {number} A random float in the interval [min, max)
 */
const randomBetween = (min, max) => Math.random() * (max - min) + min;

/**
 * Get a random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A random integer in the interval [min, max]
 */
const randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

/**
 * Get a normally-distributed random number
 * @param {number} [mu=0.5] The mean value
 * @param {number} [sigma=0.5] The standard deviation
 * @param {number} [samples=2] The number of samples
 * @return {number} A normally-distributed random number
 */
const cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {
  let total = 0;
  for (let i = samples; i--;) {
    total += Math.random();
  }
  return mu + (total - samples / 2) / (samples / 2) * sigma;
};

/**
 * Get a normally-distributed random integer in the interval [min, max]
 * @param {number} min Inclusive min
 * @param {number} max Inclusive max
 * @return {number} A normally-distributed random integer
 */
const cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));

/**
 * Return a weighted random integer
 * @param {Array<number>} w An array of weights
 * @return {number} An index from w
 */
const weightedRandom = w => {
  let total = w.reduce((a, i) => a + i, 0), n = 0;
  const r = Math.random() * total;
  while (total > r) {
    total -= w[n++];
  }
  return n - 1;
};

/**
 * An interpolation function
 * @callback InterpolationFunction
 * @param {number} a The minimum number
 * @param {number} b The maximum number
 * @param {number} i The interpolation value, should be in the interval [0, 1]
 * @return {number} The interpolated value in the interval [a, b]
 */

/**
 * Return an interpolated value from an array
 * @param {Array<number>} a An array of values interpolate
 * @param {number} i A number in the interval [0, 1]
 * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use
 * @return {number} An interpolated value in the interval [min(a), max(a)]
 */
const lerpArray = (a, i, f = lerp) => {
  const s = i * (a.length - 1);
  const p = clamp(Math.trunc(s), 0, a.length - 1);
  return f(a[p] || 0, a[p + 1] || 0, frac(s));
};

/**
 * Get the dot product of two vectors
 * @param {Array<number>} a Vector a
 * @param {Array<number>} b Vector b
 * @return {number} a ∙ b
 */
const dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);

/**
 * Get the factorial of a number
 * @param {number} a
 * @return {number} a!
 */
const factorial = a => {
  let result = 1;
  for (let i = 2; i <= a; i++) {
    result *= i;
  }
  return result;
};

/**
 * Get the number of permutations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nPr
 */
const npr = (n, r) => factorial(n) / factorial(n - r);

/**
 * Get the number of combinations of r elements from a set of n elements
 * @param {number} n
 * @param {number} r
 * @return {number} nCr
 */
const ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));

/**
 * Generate all permutations of r elements from an array
 *
 * @example
 * ```js
 * permutations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 1],
 *   [2, 3],
 *   [3, 1],
 *   [3, 2]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each permutation
 * @return {Array<Array<*>>} An array of permutation arrays
 */
const permutations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),
    ],
    []
  );
}

/**
 * Generate all combinations of r elements from an array
 *
 * @example
 * ```js
 * combinations([1, 2, 3], 2);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, 2],
 *   [1, 3],
 *   [2, 3]
 * ]
 * ```
 * @param {Array<*>} a
 * @param {number} r The number of elements to choose in each combination
 * @return {Array<Array<*>>} An array of combination arrays
 */
const combinations = (a, r) => {
  if (r === 1) {
    return a.map(item => [item]);
  }

  return a.reduce(
    (acc, item, i) => [
      ...acc,
      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),
    ],
    []
  );
};

/**
 * Get a cartesian product of arrays
 *
 * @example
 * ```js
 * cartesian([1, 2, 3], ['a', 'b']);
 * ```
 *
 * Output:
 * ```json
 * [
 *   [1, "a"],
 *   [1, "b"],
 *   [2, "a"],
 *   [2, "b"],
 *   [3, "a"],
 *   [3, "b"]
 * ]
 * ```
 */
const cartesian = (...arr) =>
  arr.reduce(
    (a, b) => a.flatMap(c => b.map(d => [...c, d])),
    [[]]
  );

/**
 * A function for generating array values
 * @callback TimesFunction
 * @param {number} i The array index
 * @return {*} The array value
 */

/**
 * Return a new array with length n by calling function f(i) on each element
 * @param {TimesFunction} f
 * @param {number} n The size of the array
 * @return {Array<*>}
 */
const times = (f, n) => Array(n).fill(0).map((_, i) => f(i));

/**
 * Return an array containing numbers 0->(n - 1)
 * @param {number} n The size of the array
 * @return {Array<number>} An array of integers 0->(n - 1)
 */
const range = n => times(i => i, n);

/**
 * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]
 * @param {...Array<*>} a The arrays to zip
 * @return {Array<Array<*>>}
 */
const zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));

/**
 * Return array[i] with positive and negative wrapping
 * @param {Array<*>} a The array to access
 * @param {number} i The positively/negatively wrapped array index
 * @return {*} An element from the array
 */
const at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];

/**
 * Return the last element of an array without removing it
 * @param {Array<*>} a
 * @return {*} The last element from the array
 */
const peek = (a) => {
  if (!a.length) {
    return undefined;
  }

  return a[a.length - 1];
};

/**
 * Return the index for a given position in an unrolled 2d array
 * @param {number} x The x position
 * @param {number} y The y position
 * @param {number} w The width of the 2d array
 * @returns {number} The index in the unrolled array
 */
const ind = (x, y, w) => x + y * w;

/**
 * Return the position for a given index in an unrolled 2d array
 * @param {number} i The index
 * @param {number} w The width of the 2d array
 * @returns {Array<number>} The position as a 2-tuple
 */
const pos = (i, w) => [i % w, Math.floor(i / w)];

/**
 * Chop an array into chunks of size n
 * @param {Array<*>} a
 * @param {number} n The chunk size
 * @return {Array<Array<*>>} An array of array chunks
 */
const chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));

/**
 * Randomly shuffle a shallow copy of an array
 * @param {Array<*>} a
 * @return {Array<*>} The shuffled array
 */
const shuffle = a => a.slice().sort(() => Math.random() - 0.5);

/**
 * Flatten an object
 * @param {object} o
 * @param {string} concatenator The string to use for concatenating keys
 * @return {object} A flattened object
 */
const flat = (o, concatenator = '.') => {
  return Object.keys(o).reduce((acc, key) => {
    if (o[key] instanceof Date) {
      return {
        ...acc,
        [key]: o[key].toISOString(),
      };
    }

    if (typeof o[key] !== 'object' || !o[key]) {
      return {
        ...acc,
        [key]: o[key],
      };
    }
    const flattened = flat(o[key], concatenator);

    return {
      ...acc,
      ...Object.keys(flattened).reduce(
        (childAcc, childKey) => ({
          ...childAcc,
          [`${key}${concatenator}${childKey}`]: flattened[childKey],
        }),
        {}
      ),
    };
  }, {});
};

/**
 * Unflatten an object
 * @param {object} o
 * @param {string} concatenator The string to check for in concatenated keys
 * @return {object} An un-flattened object
 */
const unflat = (o, concatenator = '.') => {
  let result = {}, temp, substrings, property, i;

  for (property in o) {
    substrings = property.split(concatenator);
    temp = result;
    for (i = 0; i < substrings.length - 1; i++) {
      if (!(substrings[i] in temp)) {
        if (isFinite(substrings[i + 1])) {
          temp[substrings[i]] = [];
        } else {
          temp[substrings[i]] = {};
        }
      }
      temp = temp[substrings[i]];
    }
    temp[substrings[substrings.length - 1]] = o[property];
  }

  return result;
};

/**
 * A split predicate
 * @callback SplitPredicate
 * @param {any} value The current value
 * @return {boolean} True if the array should split at this index
 */

/**
 * Split an array into sub-arrays based on a predicate
 * @param {Array<*>} array
 * @param {SplitPredicate} predicate
 * @return {Array<Array<*>>} An array of arrays
 */
const split = (array, predicate) => {
  const result = [];
  let current = [];
  for (const value of array) {
    if (predicate(value)) {
      if (current.length) {
        result.push(current);
      }
      current = [value];
    } else {
      current.push(value);
    }
  }
  result.push(current);

  return result;
};

/**
 * Pluck keys from an object
 * @param {object} o
 * @param {...string} keys The keys to pluck from the object
 * @return {object} An object containing the plucked keys
 */
const pluck = (o, ...keys) => {
  return keys.reduce(
    (result, key) => Object.assign(result, { [key]: o[key] }),
    {}
  );
};

/**
 * Exclude keys from an object
 * @param {object} o
 * @param {...string} keys The keys to exclude from the object
 * @return {object} An object containing all keys except excluded keys
 */
const exclude = (o, ...keys) => {
  return Object.fromEntries(
    Object.entries(o).filter(([key]) => !keys.includes(key))
  );
};

if (true) {
  module.exports = {
    memoize,
    floatEquals,
    clamp,
    frac,
    round,
    lerp,
    unlerp,
    blerp,
    remap,
    smoothstep,
    radians,
    degrees,
    randomBetween,
    randomIntBetween,
    cltRandom,
    cltRandomInt,
    weightedRandom,
    lerpArray,
    dot,
    factorial,
    npr,
    ncr,
    permutations,
    combinations,
    cartesian,
    times,
    range,
    zip,
    at,
    peek,
    ind,
    pos,
    chunk,
    shuffle,
    flat,
    unflat,
    split,
    pluck,
    exclude,
  };
}


/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * @overview A small vector and matrix library
 * @author Gordon Larrigan
 */

const _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));
const _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));
const _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);
const _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;
const _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;

/**
 * A 2d vector
 * @typedef {Object} vec2
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 */

/**
 * Create a new 2d vector
 * @param {number|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector
 * @return {vec2} A new 2d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec2(3, 2); // (3, 2)
 * let b = vec2(4);    // (4, 4)
 * let c = vec2(a);    // (3, 2)
 * let d = vec2();     // (0, 0)
 */
const vec2 = (x, y) => {
  if (!x && !y) {
    return { x: 0, y: 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0 };
  }
  return { x: x, y: y ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec2} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec2.components = a => [a.x, a.y];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec2} A new vector
 */
vec2.fromComponents = components => vec2(...components.slice(0, 2));

/**
 * Return a unit vector (1, 0)
 * @return {vec2} A unit vector (1, 0)
 */
vec2.ux = () => vec2(1, 0);

/**
 * Return a unit vector (0, 1)
 * @return {vec2} A unit vector (0, 1)
 */
vec2.uy = () => vec2(0, 1);

/**
 * Add vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a + b
 */
vec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });

/**
 * Subtract vectors
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a - b
 */
vec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });

/**
 * Scale a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a * b
 */
vec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });

/**
 * Scale a vector by a scalar, alias for vec2.mul
 * @param {vec2} a Vector a
 * @param {number} b Scalar b
 * @return {vec2} a * b
 */
vec2.scale = (a, b) => vec2.mul(a, b);

/**
 * Divide a vector
 * @param {vec2} a Vector a
 * @param {vec2|number} b Vector or scalar b
 * @return {vec2} a / b
 */
vec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });

/**
 * Get the length of a vector
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec2} a Vector a
 * @return {number} |a|
 */
vec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);

/**
 * Normalise a vector
 * @param {vec2} a The vector to normalise
 * @return {vec2} ^a
 */
vec2.nor = a => {
  let len = vec2.len(a);
  return len ? { x: a.x / len, y: a.y / len } : vec2();
};

/**
 * Get a dot product of vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a ∙ b
 */
vec2.dot = (a, b) => a.x * b.x + a.y * b.y;

/**
 * Rotate a vector by r radians
 * @param {vec2} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec2} A rotated vector
 */
vec2.rot = (a, r) => {
  let s = Math.sin(r),
    c = Math.cos(r);
  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };
};

/**
 * Fast method to rotate a vector by -90, 90 or 180 degrees
 * @param {vec2} a The vector to rotate
 * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees
 * @return {vec2} A rotated vector
 */
vec2.rotf = (a, r) => {
  switch (r) {
    case 1: return vec2(a.y, -a.x);
    case -1: return vec2(-a.y, a.x);
    case 2: case -2: return vec2(-a.x, -a.y);
    default: return a;
  }
};

/**
 * Scalar cross product of two vectors
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {number} a × b
 */
vec2.cross = (a, b) => {
  return a.x * b.y - a.y * b.x;
};

/**
 * Check if two vectors are equal
 * @param {vec2} a Vector a
 * @param {vec2} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec2.eq = (a, b) => a.x === b.x && a.y === b.y;

/**
 * Get the angle of a vector
 * @param {vec2} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec2.rad = a => Math.atan2(a.y, a.x);

/**
 * Copy a vector
 * @param {vec2} a The vector to copy
 * @return {vec2} A copy of vector a
 */
vec2.cpy = a => vec2(a);

/**
 * A function to call on each component of a 2d vector
 * @callback vec2MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y'} label The component label (x or y)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec2} a Vector a
 * @param {vec2MapCallback} f The function to call on each component of the vector
 * @return {vec2} Vector a mapped through f
 */
vec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });

/**
 * Convert a vector into a string
 * @param {vec2} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x` or `y`
 * - `u` or `v` (aliases for `x` and `y`, respectively)
 * - `X`, `Y`, `U`, `V` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec2} a The vector to swizzle
 * @param {string} [s='..'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec2(3, -2);
 * vec2.swiz(a, 'x');    // [3]
 * vec2.swiz(a, 'yx');   // [-2, 3]
 * vec2.swiz(a, 'xY');   // [3, 2]
 * vec2.swiz(a, 'Yy');   // [2, -2]
 * vec2.swiz(a, 'x.x');  // [3, -2, 3]
 * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]
 */
vec2.swiz = (a, s = '..') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': result.push(a.x); break;
      case 'y': case 'v': result.push(a.y); break;
      case 'X': case 'U': result.push(-a.x); break;
      case 'Y': case 'V': result.push(-a.y); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 2d vector
 * @typedef {Object} polarCoordinates2d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec2} a The vector to convert
 * @return {polarCoordinates2d} The magnitude and angle of the vector
 */
vec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The angle of the vector
 * @return {vec2} A vector with the given angle and magnitude
 */
vec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));

/**
 * A 3d vector
 * @typedef {Object} vec3
 * @property {number} x The x component of the vector
 * @property {number} y The y component of the vector
 * @property {number} z The z component of the vector
 */

/**
 * Create a new 3d vector
 * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy
 * @param {number} [y] The y component of the vector, or the z component if x is a vec2
 * @param {number} [z] The z component of the vector
 * @return {vec3} A new 3d vector
 * @example <caption>various ways to initialise a vector</caption>
 * let a = vec3(3, 2, 1);       // (3, 2, 1)
 * let b = vec3(4, 5);          // (4, 5, 0)
 * let c = vec3(6);             // (6, 6, 6)
 * let d = vec3(a);             // (3, 2, 1)
 * let e = vec3();              // (0, 0, 0)
 * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)
 * let g = vec3(vec2(4, 5));    // (4, 5, 0)
 */
const vec3 = (x, y, z) => {
  if (!x && !y && !z) {
    return { x: 0, y: 0, z: 0 };
  }
  if (_vec_is_vec3(x)) {
    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
  }
  if (_vec_is_vec2(x)) {
    return { x: x.x || 0, y: x.y || 0, z: y || 0 };
  }
  return { x: x, y: y ?? x, z: z ?? x };
};

/**
 * Get the components of a vector as an array
 * @param {vec3} a The vector to get components from
 * @return {Array<number>} The vector components as an array
 */
vec3.components = a => [a.x, a.y, a.z];

/**
 * Create a vector from an array of components
 * @param {Array<number>} components The components of the vector
 * @return {vec3} A new vector
 */
vec3.fromComponents = components => vec3(...components.slice(0, 3));

/**
 * Return a unit vector (1, 0, 0)
 * @return {vec3} A unit vector (1, 0, 0)
 */
vec3.ux = () => vec3(1, 0, 0);

/**
 * Return a unit vector (0, 1, 0)
 * @return {vec3} A unit vector (0, 1, 0)
 */
vec3.uy = () => vec3(0, 1, 0);

/**
 * Return a unit vector (0, 0, 1)
 * @return {vec3} A unit vector (0, 0, 1)
 */
vec3.uz = () => vec3(0, 0, 1);

/**
 * Add vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a + b
 */
vec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });

/**
 * Subtract vectors
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a - b
 */
vec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });

/**
 * Scale a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a * b
 */
vec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });

/**
 * Scale a vector by a scalar, alias for vec3.mul
 * @param {vec3} a Vector a
 * @param {number} b Scalar b
 * @return {vec3} a * b
 */
vec3.scale = (a, b) => vec3.mul(a, b);

/**
 * Divide a vector
 * @param {vec3} a Vector a
 * @param {vec3|number} b Vector or scalar b
 * @return {vec3} a / b
 */
vec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });

/**
 * Get the length of a vector
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);

/**
 * Get the length of a vector using taxicab geometry
 * @param {vec3} a Vector a
 * @return {number} |a|
 */
vec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);

/**
 * Normalise a vector
 * @param {vec3} a The vector to normalise
 * @return {vec3} ^a
 */
vec3.nor = a => {
  let len = vec3.len(a);
  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();
};

/**
 * Get a dot product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {number} a ∙ b
 */
vec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;

/**
 * Rotate a vector using a rotation matrix
 * @param {vec3} a The vector to rotate
 * @param {mat} m The rotation matrix
 * @return {vec3} A rotated vector
 */
vec3.rot = (a, m) => vec3(
  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),
  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)
);

/**
 * Rotate a vector by r radians around the x axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotx = (a, r) => vec3(
  a.x,
  a.y * Math.cos(r) - a.z * Math.sin(r),
  a.y * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the y axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.roty = (a, r) => vec3(
  a.x * Math.cos(r) + a.z * Math.sin(r),
  a.y,
  -a.x * Math.sin(r) + a.z * Math.cos(r)
);

/**
 * Rotate a vector by r radians around the z axis
 * @param {vec3} a The vector to rotate
 * @param {number} r The angle to rotate by, measured in radians
 * @return {vec3} A rotated vector
 */
vec3.rotz = (a, r) => vec3(
  a.x * Math.cos(r) - a.y * Math.sin(r),
  a.x * Math.sin(r) + a.y * Math.cos(r),
  a.z
);

/**
 * Rotate a vector using a quaternion
 * @param {vec3} a The vector to rotate
 * @param {Array<number>} q The quaternion to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rotq = (v, q) => {
  if (q.length !== 4) {
    return vec3();
  }

  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
  if (d === 0) {
    return vec3();
  }

  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];
  const u = vec3(...uq.slice(0, 3));
  const s = uq[3];
  return vec3.add(
    vec3.add(
      vec3.mul(u, 2 * vec3.dot(u, v)),
      vec3.mul(v, s * s - vec3.dot(u, u))
    ),
    vec3.mul(vec3.cross(u, v), 2 * s)
  );
};

/**
 * Rotate a vector using Euler angles
 * @param {vec3} a The vector to rotate
 * @param {vec3} e The Euler angles to rotate by
 * @return {vec3} A rotated vector
 */
vec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);

/**
 * Get the cross product of vectors
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {vec3} a × b
 */
vec3.cross = (a, b) => vec3(
  a.y * b.z - a.z * b.y,
  a.z * b.x - a.x * b.z,
  a.x * b.y - a.y * b.x
);

/**
 * Check if two vectors are equal
 * @param {vec3} a Vector a
 * @param {vec3} b Vector b
 * @return {boolean} True if vectors a and b are equal, false otherwise
 */
vec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;

/**
 * Get the angle of a vector from the x axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radx = a => Math.atan2(a.z, a.y);

/**
 * Get the angle of a vector from the y axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.rady = a => Math.atan2(a.x, a.y);

/**
 * Get the angle of a vector from the z axis
 * @param {vec3} a Vector a
 * @return {number} The angle of vector a in radians
 */
vec3.radz = a => Math.atan2(a.y, a.z);

/**
 * Copy a vector
 * @param {vec3} a The vector to copy
 * @return {vec3} A copy of vector a
 */
vec3.cpy = a => vec3(a);

/**
 * A function to call on each component of a 3d vector
 * @callback vec3MapCallback
 * @param {number} value The component value
 * @param {'x' | 'y' | 'z'} label The component label (x, y or z)
 * @return {number} The mapped component
 */

/**
 * Call a function on each component of a vector and build a new vector from the results
 * @param {vec3} a Vector a
 * @param {vec3MapCallback} f The function to call on each component of the vector
 * @return {vec3} Vector a mapped through f
 */
vec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });

/**
 * Convert a vector into a string
 * @param {vec3} a The vector to convert
 * @param {string} [s=', '] The separator string
 * @return {string} A string representation of the vector
 */
vec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;

/**
 * Swizzle a vector with a string of component labels
 *
 * The string can contain:
 * - `x`, `y` or `z`
 * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)
 * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)
 * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)
 * - `0` or `1` (these will be passed through unchanged)
 * - `.` to return the component that would normally be at this position (or 0)
 *
 * Any other characters will default to 0
 * @param {vec3} a The vector to swizzle
 * @param {string} [s='...'] The swizzle string
 * @return {Array<number>} The swizzled components
 * @example <caption>swizzling a vector</caption>
 * let a = vec3(3, -2, 1);
 * vec3.swiz(a, 'x');     // [3]
 * vec3.swiz(a, 'zyx');   // [1, -2, 3]
 * vec3.swiz(a, 'xYZ');   // [3, 2, -1]
 * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]
 * vec3.swiz(a, 'x.x');   // [3, -2, 3]
 * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]
 */
vec3.swiz = (a, s = '...') => {
  const result = [];
  s.split('').forEach((c, i) => {
    switch (c) {
      case 'x': case 'u': case 'r': result.push(a.x); break;
      case 'y': case 'v': case 'g': result.push(a.y); break;
      case 'z': case 'w': case 'b': result.push(a.z); break;
      case 'X': case 'U': case 'R': result.push(-a.x); break;
      case 'Y': case 'V': case 'G': result.push(-a.y); break;
      case 'Z': case 'W': case 'B': result.push(-a.z); break;
      case '0': result.push(0); break;
      case '1': result.push(1); break;
      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;
      default: result.push(0);
    }
  });
  return result;
};

/**
 * Polar coordinates for a 3d vector
 * @typedef {Object} polarCoordinates3d
 * @property {number} r The magnitude (radius) of the vector
 * @property {number} theta The tilt angle of the vector
 * @property {number} phi The pan angle of the vector
 */

/**
 * Convert a vector into polar coordinates
 * @param {vec3} a The vector to convert
 * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector
 */
vec3.polar = a => {
  let r = vec3.len(a),
    theta = Math.acos(a.y / r),
    phi = Math.atan2(a.z, a.x);
  return { r, theta, phi };
};

/**
 * Convert polar coordinates into a vector
 * @param {number} r The magnitude (radius) of the vector
 * @param {number} theta The tilt of the vector
 * @param {number} phi The pan of the vector
 * @return {vec3} A vector with the given angle and magnitude
 */
vec3.fromPolar = (r, theta, phi) => {
  const sinTheta = Math.sin(theta);
  return vec3(
    r * sinTheta * Math.cos(phi),
    r * Math.cos(theta),
    r * sinTheta * Math.sin(phi)
  );
};

/**
 * A matrix
 * @typedef {Object} mat
 * @property {number} m The number of rows in the matrix
 * @property {number} n The number of columns in the matrix
 * @property {Array<number>} entries The matrix values
 */

/**
 * Create a new matrix
 * @param {number} [m=4] The number of rows
 * @param {number} [n=4] The number of columns
 * @param {Array<number>} [entries=[]] Matrix values in reading order
 * @return {mat} A new matrix
 */
const mat = (m = 4, n = 4, entries = []) => ({
  m, n,
  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)
});

/**
 * Get an identity matrix of size n
 * @param {number} n The size of the matrix
 * @return {mat} An identity matrix
 */
mat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));

/**
 * Get an entry from a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {number} The value at position (i, j) in matrix a
 */
mat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];

/**
 * Set an entry of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @param {number} v The value to set in matrix a
 */
mat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };

/**
 * Get a row from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} m The row offset
 * @return {Array<number>} Row m from matrix a
 */
mat.row = (a, m) => {
  const s = (m - 1) * a.n;
  return a.entries.slice(s, s + a.n);
};

/**
 * Get a column from a matrix as an array
 * @param {mat} a Matrix a
 * @param {number} n The column offset
 * @return {Array<number>} Column n from matrix a
 */
mat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);

/**
 * Add matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a + b
 */
mat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);

/**
 * Subtract matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat} a - b
 */
mat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);

/**
 * Multiply matrices
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {mat|false} ab or false if the matrices cannot be multiplied
 */
mat.mul = (a, b) => {
  if (a.n !== b.m) { return false; }
  const result = mat(a.m, b.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= b.n; j++) {
      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));
    }
  }
  return result;
};

/**
 * Multiply a matrix by a vector
 * @param {mat} a Matrix a
 * @param {vec2|vec3|number[]} b Vector b
 * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied
 */
mat.mulv = (a, b) => {
  let n, bb, rt;
  if (_vec_is_vec3(b)) {
    bb = vec3.components(b);
    n = 3;
    rt = vec3.fromComponents;
  } else if (_vec_is_vec2(b)) {
    bb = vec2.components(b);
    n = 2;
    rt = vec2.fromComponents;
  } else {
    bb = b;
    n = b.length ?? 0;
    rt = v => v;
  }
  if (a.n !== n) { return false; }
  const result = [];
  for (let i = 1; i <= a.m; i++) {
    result.push(_vec_dot(mat.row(a, i), bb));
  }
  return rt(result);
}

/**
 * Scale a matrix
 * @param {mat} a Matrix a
 * @param {number} b Scalar b
 * @return {mat} a * b
 */
mat.scale = (a, b) => mat.map(a, v => v * b);

/**
 * Transpose a matrix
 * @param {mat} a The matrix to transpose
 * @return {mat} A transposed matrix
 */
mat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());

/**
 * Get the minor of a matrix
 * @param {mat} a Matrix a
 * @param {number} i The row offset
 * @param {number} j The column offset
 * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square
 */
mat.minor = (a, i, j) => {
  if (a.m !== a.n) { return false; }
  const entries = [];
  for (let ii = 1; ii <= a.m; ii++) {
    if (ii === i) { continue; }
    for (let jj = 1; jj <= a.n; jj++) {
      if (jj === j) { continue; }
      entries.push(mat.get(a, ii, jj));
    }
  }
  return mat(a.m - 1, a.n - 1, entries);
};

/**
 * Get the determinant of a matrix
 * @param {mat} a Matrix a
 * @return {number|false} |a| or false if the matrix is not square
 */
mat.det = a => {
  if (a.m !== a.n) { return false; }
  if (a.m === 1) {
    return a.entries[0];
  }
  if (a.m === 2) {
    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];
  }
  let total = 0, sign = 1;
  for (let j = 1; j <= a.n; j++) {
    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));
    sign *= -1;
  }
  return total;
};

/**
 * Normalise a matrix
 * @param {mat} a The matrix to normalise
 * @return {mat|false} ^a or false if the matrix is not square
 */
mat.nor = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  return mat.map(a, i => i * d);
};

/**
 * Get the adjugate of a matrix
 * @param {mat} a The matrix from which to get the adjugate
 * @return {mat} The adjugate of a
 */
mat.adj = a => {
  const minors = mat(a.m, a.n);
  for (let i = 1; i <= a.m; i++) {
    for (let j = 1; j <= a.n; j++) {
      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));
    }
  }
  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));
  return mat.trans(cofactors);
};

/**
 * Get the inverse of a matrix
 * @param {mat} a The matrix to invert
 * @return {mat|false} a^-1 or false if the matrix has no inverse
 */
mat.inv = a => {
  if (a.m !== a.n) { return false; }
  const d = mat.det(a);
  if (d === 0) { return false; }
  return mat.scale(mat.adj(a), 1 / d);
};

/**
 * Check if two matrices are equal
 * @param {mat} a Matrix a
 * @param {mat} b Matrix b
 * @return {boolean} True if matrices a and b are identical, false otherwise
 */
mat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);

/**
 * Copy a matrix
 * @param {mat} a The matrix to copy
 * @return {mat} A copy of matrix a
 */
mat.cpy = a => mat(a.m, a.n, [...a.entries]);

/**
 * A function to call on each entry of a matrix
 * @callback matrixMapCallback
 * @param {number} value The entry value
 * @param {number} index The entry index
 * @param {Array<number>} entries The array of matrix entries
 * @return {number} The mapped entry
 */

/**
 * Call a function on each entry of a matrix and build a new matrix from the results
 * @param {mat} a Matrix a
 * @param {matrixMapCallback} f The function to call on each entry of the matrix
 * @return {mat} Matrix a mapped through f
 */
mat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));

/**
 * Convert a matrix into a string
 * @param {mat} a The matrix to convert
 * @param {string} [ms=', '] The separator string for columns
 * @param {string} [ns='\n'] The separator string for rows
 * @return {string} A string representation of the matrix
 */
mat.str = (a, ms = ', ', ns = '\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);

if (true) {
  module.exports = { vec2, vec3, mat };
}


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
var max_js_1 = __webpack_require__(/*! ./max.js */ "./node_modules/uuid/dist/cjs-browser/max.js");
Object.defineProperty(exports, "MAX", ({ enumerable: true, get: function () { return max_js_1.default; } }));
var nil_js_1 = __webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/cjs-browser/nil.js");
Object.defineProperty(exports, "NIL", ({ enumerable: true, get: function () { return nil_js_1.default; } }));
var parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
Object.defineProperty(exports, "parse", ({ enumerable: true, get: function () { return parse_js_1.default; } }));
var stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.default; } }));
var v1_js_1 = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/cjs-browser/v1.js");
Object.defineProperty(exports, "v1", ({ enumerable: true, get: function () { return v1_js_1.default; } }));
var v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js");
Object.defineProperty(exports, "v1ToV6", ({ enumerable: true, get: function () { return v1ToV6_js_1.default; } }));
var v3_js_1 = __webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/cjs-browser/v3.js");
Object.defineProperty(exports, "v3", ({ enumerable: true, get: function () { return v3_js_1.default; } }));
var v4_js_1 = __webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/cjs-browser/v4.js");
Object.defineProperty(exports, "v4", ({ enumerable: true, get: function () { return v4_js_1.default; } }));
var v5_js_1 = __webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/cjs-browser/v5.js");
Object.defineProperty(exports, "v5", ({ enumerable: true, get: function () { return v5_js_1.default; } }));
var v6_js_1 = __webpack_require__(/*! ./v6.js */ "./node_modules/uuid/dist/cjs-browser/v6.js");
Object.defineProperty(exports, "v6", ({ enumerable: true, get: function () { return v6_js_1.default; } }));
var v6ToV1_js_1 = __webpack_require__(/*! ./v6ToV1.js */ "./node_modules/uuid/dist/cjs-browser/v6ToV1.js");
Object.defineProperty(exports, "v6ToV1", ({ enumerable: true, get: function () { return v6ToV1_js_1.default; } }));
var v7_js_1 = __webpack_require__(/*! ./v7.js */ "./node_modules/uuid/dist/cjs-browser/v7.js");
Object.defineProperty(exports, "v7", ({ enumerable: true, get: function () { return v7_js_1.default; } }));
var validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
Object.defineProperty(exports, "validate", ({ enumerable: true, get: function () { return validate_js_1.default; } }));
var version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/cjs-browser/version.js");
Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return version_js_1.default; } }));


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/max.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/max.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = 'ffffffff-ffff-ffff-ffff-ffffffffffff';


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function md5(bytes) {
    const words = uint8ToUint32(bytes);
    const md5Bytes = wordsToMd5(words, bytes.length * 8);
    return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
    const bytes = new Uint8Array(input.length * 4);
    for (let i = 0; i < input.length * 4; i++) {
        bytes[i] = (input[i >> 2] >>> ((i % 4) * 8)) & 0xff;
    }
    return bytes;
}
function getOutputLength(inputLength8) {
    return (((inputLength8 + 64) >>> 9) << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
    const xpad = new Uint32Array(getOutputLength(len)).fill(0);
    xpad.set(x);
    xpad[len >> 5] |= 0x80 << len % 32;
    xpad[xpad.length - 1] = len;
    x = xpad;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
    if (input.length === 0) {
        return new Uint32Array();
    }
    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
    for (let i = 0; i < input.length; i++) {
        output[i >> 2] |= (input[i] & 0xff) << ((i % 4) * 8);
    }
    return output;
}
function safeAdd(x, y) {
    const lsw = (x & 0xffff) + (y & 0xffff);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xffff);
}
function bitRotateLeft(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt));
}
function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports["default"] = md5;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports["default"] = { randomUUID };


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = '00000000-0000-0000-0000-000000000000';


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
function parse(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);
}
exports["default"] = parse;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}
exports["default"] = rng;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function f(s, x, y, z) {
    switch (s) {
        case 0:
            return (x & y) ^ (~x & z);
        case 1:
            return x ^ y ^ z;
        case 2:
            return (x & y) ^ (x & z) ^ (y & z);
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return (x << n) | (x >>> (32 - n));
}
function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    const newBytes = new Uint8Array(bytes.length + 1);
    newBytes.set(bytes);
    newBytes[bytes.length] = 0x80;
    bytes = newBytes;
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
            arr[j] =
                (bytes[i * 64 + j * 4] << 24) |
                    (bytes[i * 64 + j * 4 + 1] << 16) |
                    (bytes[i * 64 + j * 4 + 2] << 8) |
                    bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
    }
    M[N - 1][14] = ((bytes.length - 1) * 8) / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;
    for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
            W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
            const s = Math.floor(t / 20);
            const T = (ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t]) >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = (H[0] + a) >>> 0;
        H[1] = (H[1] + b) >>> 0;
        H[2] = (H[2] + c) >>> 0;
        H[3] = (H[3] + d) >>> 0;
        H[4] = (H[4] + e) >>> 0;
    }
    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
exports["default"] = sha1;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unsafeStringify = void 0;
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}
exports.unsafeStringify = unsafeStringify;
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
exports["default"] = stringify;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV1State = void 0;
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const _state = {};
function v1(options, buf, offset) {
    let bytes;
    const isV6 = options?._v6 ?? false;
    if (options) {
        const optionsKeys = Object.keys(options);
        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {
            options = undefined;
        }
    }
    if (options) {
        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV1State(_state, now, rnds);
        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV1State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.nsecs ??= 0;
    if (now === state.msecs) {
        state.nsecs++;
        if (state.nsecs >= 10000) {
            state.node = undefined;
            state.nsecs = 0;
        }
    }
    else if (now > state.msecs) {
        state.nsecs = 0;
    }
    else if (now < state.msecs) {
        state.node = undefined;
    }
    if (!state.node) {
        state.node = rnds.slice(10, 16);
        state.node[0] |= 0x01;
        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    }
    state.msecs = now;
    return state;
}
exports.updateV1State = updateV1State;
function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    else {
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
    }
    msecs ??= Date.now();
    nsecs ??= 0;
    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;
    node ??= rnds.slice(10, 16);
    msecs += 12219292800000;
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    buf[offset++] = (tl >>> 24) & 0xff;
    buf[offset++] = (tl >>> 16) & 0xff;
    buf[offset++] = (tl >>> 8) & 0xff;
    buf[offset++] = tl & 0xff;
    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
    buf[offset++] = (tmh >>> 8) & 0xff;
    buf[offset++] = tmh & 0xff;
    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;
    buf[offset++] = (tmh >>> 16) & 0xff;
    buf[offset++] = (clockseq >>> 8) | 0x80;
    buf[offset++] = clockseq & 0xff;
    for (let n = 0; n < 6; ++n) {
        buf[offset++] = node[n];
    }
    return buf;
}
exports["default"] = v1;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v1ToV6.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
}
exports["default"] = v1ToV6;
function _v1ToV6(v1Bytes) {
    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const md5_js_1 = __webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/cjs-browser/md5.js");
const v35_js_1 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
var v35_js_2 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v3(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);
}
v3.DNS = v35_js_1.DNS;
v3.URL = v35_js_1.URL;
exports["default"] = v3;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = exports.stringToBytes = void 0;
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; ++i) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
exports.stringToBytes = stringToBytes;
exports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(version, hash, value, namespace, buf, offset) {
    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;
    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;
    if (typeof namespace === 'string') {
        namespace = (0, parse_js_1.default)(namespace);
    }
    if (namespace?.length !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    }
    let bytes = new Uint8Array(16 + valueBytes.length);
    bytes.set(namespaceBytes);
    bytes.set(valueBytes, namespaceBytes.length);
    bytes = hash(bytes);
    bytes[6] = (bytes[6] & 0x0f) | version;
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v35;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const native_js_1 = __webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/cjs-browser/native.js");
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v4(options, buf, offset) {
    if (native_js_1.default.randomUUID && !buf && !options) {
        return native_js_1.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(rnds);
}
exports["default"] = v4;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URL = exports.DNS = void 0;
const sha1_js_1 = __webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/cjs-browser/sha1.js");
const v35_js_1 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
var v35_js_2 = __webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/cjs-browser/v35.js");
Object.defineProperty(exports, "DNS", ({ enumerable: true, get: function () { return v35_js_2.DNS; } }));
Object.defineProperty(exports, "URL", ({ enumerable: true, get: function () { return v35_js_2.URL; } }));
function v5(value, namespace, buf, offset) {
    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);
}
v5.DNS = v35_js_1.DNS;
v5.URL = v35_js_1.URL;
exports["default"] = v5;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v6.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v6.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const v1_js_1 = __webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/cjs-browser/v1.js");
const v1ToV6_js_1 = __webpack_require__(/*! ./v1ToV6.js */ "./node_modules/uuid/dist/cjs-browser/v1ToV6.js");
function v6(options, buf, offset) {
    options ??= {};
    offset ??= 0;
    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
    bytes = (0, v1ToV6_js_1.default)(bytes);
    if (buf) {
        for (let i = 0; i < 16; i++) {
            buf[offset + i] = bytes[i];
        }
        return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
}
exports["default"] = v6;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v6ToV1.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v6ToV1.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parse_js_1 = __webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/cjs-browser/parse.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
}
exports["default"] = v6ToV1;
function _v6ToV1(v6Bytes) {
    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/v7.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/v7.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateV7State = void 0;
const rng_js_1 = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/cjs-browser/rng.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/cjs-browser/stringify.js");
const _state = {};
function v7(options, buf, offset) {
    let bytes;
    if (options) {
        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
    }
    else {
        const now = Date.now();
        const rnds = (0, rng_js_1.default)();
        updateV7State(_state, now, rnds);
        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
}
function updateV7State(state, now, rnds) {
    state.msecs ??= -Infinity;
    state.seq ??= 0;
    if (now > state.msecs) {
        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
        state.msecs = now;
    }
    else {
        state.seq = (state.seq + 1) | 0;
        if (state.seq === 0) {
            state.msecs++;
        }
    }
    return state;
}
exports.updateV7State = updateV7State;
function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    if (!buf) {
        buf = new Uint8Array(16);
        offset = 0;
    }
    else {
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
    }
    msecs ??= Date.now();
    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];
    buf[offset++] = (msecs / 0x10000000000) & 0xff;
    buf[offset++] = (msecs / 0x100000000) & 0xff;
    buf[offset++] = (msecs / 0x1000000) & 0xff;
    buf[offset++] = (msecs / 0x10000) & 0xff;
    buf[offset++] = (msecs / 0x100) & 0xff;
    buf[offset++] = msecs & 0xff;
    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);
    buf[offset++] = (seq >>> 20) & 0xff;
    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);
    buf[offset++] = (seq >>> 6) & 0xff;
    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
}
exports["default"] = v7;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const regex_js_1 = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/cjs-browser/regex.js");
function validate(uuid) {
    return typeof uuid === 'string' && regex_js_1.default.test(uuid);
}
exports["default"] = validate;


/***/ }),

/***/ "./node_modules/uuid/dist/cjs-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/cjs-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_js_1 = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/cjs-browser/validate.js");
function version(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
        throw TypeError('Invalid UUID');
    }
    return parseInt(uuid.slice(14, 15), 16);
}
exports["default"] = version;


/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const content_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js"));
const debug_1 = __importDefault(__webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js"));
const input_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js"));
const scene_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js"));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const LoadingScene_1 = __webpack_require__(/*! ./LoadingScene */ "./src/LoadingScene.ts");
const config = __importStar(__webpack_require__(/*! ./config.json */ "./src/config.json"));
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/constants.ts"));
class Game {
    constructor(container) {
        this.frameRate = 0;
        this.frameCount = 0;
        if (container === null) {
            throw new Error('A valid container element must be specified');
        }
        if (container.tagName.toLowerCase() !== 'canvas') {
            throw new Error('Container element must be a canvas');
        }
        this.canvas = container;
        const context = this.canvas.getContext('2d');
        if (context !== null) {
            this.context = context;
        }
        else {
            throw new Error('Failed to get a context for main canvas');
        }
        window.addEventListener('resize', this.resize.bind(this), false);
        this.resize();
    }
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    initialise() {
        content_manager_1.default.initialise({
            simulateSlowLoading: constants.SIMULATE_SLOW_LOADING,
        });
        debug_1.default.initialise();
        input_manager_1.default.initialise();
        scene_manager_1.default.initialise();
        this.lastFrameTime = this.lastFrameCountTime = performance.now();
        this.loop();
        scene_manager_1.default.push(new LoadingScene_1.LoadingScene());
    }
    loop() {
        const now = performance.now();
        const elapsedTime = Math.min(now - this.lastFrameTime, constants.FPS_MIN);
        if (now - this.lastFrameCountTime >= 1000) {
            this.lastFrameCountTime = now;
            this.frameRate = this.frameCount;
            this.frameCount = 0;
        }
        this.frameCount++;
        this.lastFrameTime = now;
        if (config.showFPS) {
            debug_1.default.value('FPS', this.frameRate, { align: 'right' });
        }
        this.update(elapsedTime);
        this.draw();
        window.requestAnimationFrame(this.loop.bind(this));
    }
    update(dt) {
        Game.screen = (0, vec_1.vec2)(this.canvas.width, this.canvas.height);
        debug_1.default.value('status', content_manager_1.default.status);
        debug_1.default.value('progress', content_manager_1.default.progress);
        scene_manager_1.default.update(dt);
        input_manager_1.default.update();
    }
    draw() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        scene_manager_1.default.draw(this.context);
        debug_1.default.draw(this.context);
    }
}
exports["default"] = Game;


/***/ }),

/***/ "./src/GameScene.ts":
/*!**************************!*\
  !*** ./src/GameScene.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GameScene = void 0;
const camera_1 = __importDefault(__webpack_require__(/*! @basementuniverse/camera */ "./node_modules/@basementuniverse/camera/build/index.js"));
const content_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js"));
const input_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js"));
const scene_manager_1 = __importStar(__webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js"));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const Game_1 = __importDefault(__webpack_require__(/*! ./Game */ "./src/Game.ts"));
const Level_1 = __importDefault(__webpack_require__(/*! ./Level */ "./src/Level.ts"));
class GameScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: GameScene.TRANSITION_TIME,
        });
        this.time = 0;
    }
    initialise(levelId) {
        this.camera = new camera_1.default((0, vec_1.vec2)());
        const levelData = content_manager_1.default.get(levelId);
        if (!levelData) {
            throw new Error(`Level data for '${levelId}' not found`);
        }
        this.level = Level_1.default.fromData(levelData);
    }
    update(dt) {
        this.time += dt;
        if (input_manager_1.default.keyPressed('Escape')) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new GameScene(), this.level.data.id);
        }
        this.level.update(dt, this.camera);
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        context.fillStyle = '#ccc';
        context.fillRect(0, 0, Game_1.default.screen.x, Game_1.default.screen.y);
        context.save();
        this.camera.draw(context, Game_1.default.screen);
        this.level.draw(context, this.camera);
        context.restore();
        context.restore();
    }
}
exports.GameScene = GameScene;
GameScene.SCREEN_WIDTH_PRODUCTS = 12;
GameScene.TRANSITION_TIME = 1;


/***/ }),

/***/ "./src/Level.ts":
/*!**********************!*\
  !*** ./src/Level.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isLevelData = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! @basementuniverse/debug */ "./node_modules/@basementuniverse/debug/build/index.js"));
const input_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js"));
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const actors_1 = __webpack_require__(/*! ./actors */ "./src/actors/index.ts");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/constants.ts"));
const ProductFactory_1 = __webpack_require__(/*! ./ProductFactory */ "./src/ProductFactory.ts");
const ShelfFactory_1 = __webpack_require__(/*! ./ShelfFactory */ "./src/ShelfFactory.ts");
function isLevelData(data) {
    return (typeof data === 'object' &&
        typeof data.id === 'string' &&
        typeof data.name === 'string' &&
        (data.description === undefined || typeof data.description === 'string') &&
        typeof data.grid === 'object' &&
        typeof data.grid.width === 'number' &&
        typeof data.grid.height === 'number' &&
        (data.lockedProducts === undefined ||
            (Array.isArray(data.lockedProducts) &&
                data.lockedProducts.every((lockedProduct) => typeof lockedProduct === 'object' &&
                    typeof lockedProduct.shelfReference === 'string' &&
                    typeof lockedProduct.slot === 'number'))) &&
        Array.isArray(data.actors) &&
        data.actors.every((actor) => typeof actor === 'object' &&
            (0, utilities_1.isVec2)(actor.gridPosition) &&
            typeof actor.type === 'string') &&
        (data.timeLimit === undefined || typeof data.timeLimit === 'number'));
}
exports.isLevelData = isLevelData;
class Level {
    constructor(data) {
        this.actors = [];
        this.draggingProduct = null;
        this.shelves = [];
        this.completed = false;
        this.data = data;
        this.data.actors.forEach(actorData => {
            this.actors.push({
                gridPosition: actorData.gridPosition,
                actor: this.createActor(actorData.type, actorData),
            });
        });
        const shelvesWithReference = this.shelves.filter(shelf => shelf.reference !== undefined);
        const shelvesByReference = shelvesWithReference.reduce((acc, shelf) => ({
            ...acc,
            [shelf.reference]: shelf,
        }), {});
        if (this.data.lockedProducts) {
            this.data.lockedProducts.forEach(lock => {
                const { shelfReference, slot } = lock;
                if (!shelvesByReference[shelfReference]) {
                    return;
                }
                shelvesByReference[shelfReference].lockProductAtIndex(slot);
            });
        }
        this.stats = {
            time: 0,
            productMatches: Object.fromEntries(ProductFactory_1.ProductFactory.productIds.map(id => [
                id,
                {
                    product: ProductFactory_1.ProductFactory.createProduct(this, id),
                    total: 0,
                },
            ])),
            totalMatches: 0,
            completedShelves: Object.fromEntries(shelvesWithReference.map(shelf => [
                shelf.reference,
                { shelf, completed: false },
            ])),
            totalCompletedShelves: 0,
            productPlacements: [],
            currentProductPlacement: Object.fromEntries(Object.values(shelvesByReference).map(shelf => [
                shelf,
                shelf.products.map((product, slot) => ({
                    shelf,
                    slot,
                    product,
                })),
            ])),
        };
    }
    static fromData(data) {
        if (!isLevelData(data)) {
            throw new Error('Invalid level data');
        }
        return new Level(data);
    }
    createActor(type, data) {
        switch (type) {
            case 'shelf':
            case 'closing-shelf':
            case 'supply-shelf':
            case 'disappearing-shelf':
            case 'deep-shelf':
            case 'display-shelf':
            case 'locking-shelf':
                return ShelfFactory_1.ShelfFactory.createShelf(this, data);
            case 'carousel':
                return actors_1.Carousel.fromData(this, data);
            case 'collapse':
                return actors_1.Collapse.fromData(this, data);
        }
        throw new Error(`Unknown actor type: ${type}`);
    }
    update(dt, camera) {
        const productSize = actors_1.Product.calculateSize();
        const gridSizePixels = (0, vec_1.vec2)(this.data.grid.width * productSize.x, this.data.grid.height * productSize.y);
        const gridTopLeft = vec_1.vec2.mul(gridSizePixels, -0.5);
        this.actors.forEach(({ actor, gridPosition }) => {
            actor.position = vec_1.vec2.add(gridTopLeft, vec_1.vec2.mul(gridPosition, productSize));
            if ('offset' in actor && actor.offset) {
                actor.position = vec_1.vec2.add(actor.position, vec_1.vec2.mul(actor.offset, productSize));
            }
            actor.update(dt, this, camera);
        });
        if (!input_manager_1.default.mouseDown() && this.draggingProduct) {
            this.finishDraggingProduct();
        }
        if (!this.completed &&
            this.shelves.every(shelf => shelf.ignore || shelf.shelfIsComplete())) {
            this.completed = true;
            console.log('All shelves completed!');
        }
        this.actors = this.actors.filter(({ actor }) => !actor.disposed);
        this.shelves = this.shelves.filter(shelf => !shelf.disposed);
        const shelvesWithReference = this.shelves.filter(shelf => shelf.reference);
        this.stats.time += dt;
        this.stats.completedShelves = Object.fromEntries(shelvesWithReference.map(shelf => [
            shelf.reference,
            { shelf, completed: shelf.shelfIsComplete() },
        ]));
        this.stats.currentProductPlacement = Object.fromEntries(shelvesWithReference.map(shelf => [
            shelf.reference,
            {
                shelf,
                products: shelf.products,
            },
        ]));
    }
    startDraggingProduct(shelf, slotIndex, product) {
        this.draggingProduct = {
            shelf,
            slotIndex,
            product,
        };
    }
    finishDraggingProduct() {
        if (!this.draggingProduct) {
            return;
        }
        const result = this.isValidDropPosition(this.draggingProduct.product);
        if (result.valid && result.shelf && result.slotIndex !== undefined) {
            this.draggingProduct.shelf.removeProductAtIndex(this.draggingProduct.slotIndex);
            result.shelf.addProductAtIndex(result.slotIndex, this.draggingProduct.product);
            if (result.shelf.reference) {
                this.stats.productPlacements.push({
                    shelf: result.shelf,
                    slot: result.slotIndex,
                    product: this.draggingProduct.product,
                });
            }
        }
        this.draggingProduct.product.dragging = false;
        this.draggingProduct = null;
    }
    isValidDropPosition(product) {
        const results = [];
        for (const shelf of this.shelves) {
            const result = shelf.findShelfSlot(product);
            if (result.valid) {
                results.push({
                    shelf,
                    ...result,
                });
            }
        }
        results.sort((a, b) => { var _a, _b; return ((_a = a.distance) !== null && _a !== void 0 ? _a : 0) - ((_b = b.distance) !== null && _b !== void 0 ? _b : 0); });
        const closestResult = results[0];
        if (closestResult &&
            closestResult.valid &&
            closestResult.slotIndex !== undefined) {
            return {
                valid: true,
                shelf: closestResult.shelf,
                slotIndex: closestResult.slotIndex,
            };
        }
        return { valid: false };
    }
    draw(context, camera) {
        if (constants.DEBUG) {
            const productSize = actors_1.Product.calculateSize();
            const gridSizePixels = (0, vec_1.vec2)(this.data.grid.width * productSize.x, this.data.grid.height * productSize.y);
            const gridTopLeft = camera.worldToScreen(vec_1.vec2.mul(gridSizePixels, -0.5));
            for (let x = 0; x < this.data.grid.width; x++) {
                for (let y = 0; y < this.data.grid.height; y++) {
                    debug_1.default.border(`grid-${x}-${y}-border`, '', vec_1.vec2.add(gridTopLeft, vec_1.vec2.mul((0, vec_1.vec2)(x, y), productSize)), {
                        size: productSize,
                        showLabel: false,
                        showValue: false,
                        borderColour: 'rgba(255, 0, 0, 0.5)',
                        borderStyle: 'dashed',
                        space: 'screen',
                    });
                }
            }
        }
        this.actors.forEach(({ actor }) => {
            actor.draw(context);
        });
        if (this.draggingProduct) {
            this.draggingProduct.product.draw(context);
        }
    }
}
exports["default"] = Level;


/***/ }),

/***/ "./src/LoadingScene.ts":
/*!*****************************!*\
  !*** ./src/LoadingScene.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadingScene = void 0;
const content_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js"));
const scene_manager_1 = __importStar(__webpack_require__(/*! @basementuniverse/scene-manager */ "./node_modules/@basementuniverse/scene-manager/build/index.js"));
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const content_compiled_json_1 = __importDefault(__webpack_require__(/*! ../content/content-compiled.json */ "./content/content-compiled.json"));
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/constants.ts"));
const Game_1 = __importDefault(__webpack_require__(/*! ./Game */ "./src/Game.ts"));
const GameScene_1 = __webpack_require__(/*! ./GameScene */ "./src/GameScene.ts");
const ProductFactory_1 = __webpack_require__(/*! ./ProductFactory */ "./src/ProductFactory.ts");
class LoadingScene extends scene_manager_1.Scene {
    constructor() {
        super({
            transitionTime: LoadingScene.TRANSITION_TIME,
        });
        this.cooldownTime = 0;
    }
    initialise() {
        this.finishedLoadingContent = false;
        this.progressBar = { position: (0, vec_1.vec2)(), progress: 0 };
        this.cooldownTime = constants.DEBUG
            ? LoadingScene.DEBUG_COOLDOWN_TIME
            : LoadingScene.COOLDOWN_TIME;
        content_manager_1.default.load(content_compiled_json_1.default)
            .then(() => {
            ProductFactory_1.ProductFactory.initialise();
            this.finishedLoadingContent = true;
        })
            .catch((error) => {
            constants.DEBUG && console.log(`Unable to load content: ${error}`);
        });
    }
    update(dt) {
        this.progressBar.position = vec_1.vec2.map(vec_1.vec2.mul(Game_1.default.screen, 1 / 2), Math.floor);
        this.progressBar.progress = content_manager_1.default.progress;
        if (this.finishedLoadingContent) {
            this.cooldownTime -= dt;
        }
        if (this.cooldownTime <= 0) {
            scene_manager_1.default.pop();
            scene_manager_1.default.push(new GameScene_1.GameScene(), 'test-7-collapse');
        }
    }
    draw(context) {
        context.save();
        if (this.transitionState !== scene_manager_1.SceneTransitionState.None) {
            context.globalAlpha = this.transitionAmount;
        }
        context.fillStyle = 'white';
        context.fillRect(this.progressBar.position.x, this.progressBar.position.y, this.progressBar.progress * 100, 20);
        context.restore();
    }
}
exports.LoadingScene = LoadingScene;
LoadingScene.TRANSITION_TIME = 0.5;
LoadingScene.COOLDOWN_TIME = 2.5;
LoadingScene.DEBUG_COOLDOWN_TIME = 0.5;


/***/ }),

/***/ "./src/ProductFactory.ts":
/*!*******************************!*\
  !*** ./src/ProductFactory.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProductFactory = exports.isProductsData = void 0;
const content_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/content-manager */ "./node_modules/@basementuniverse/content-manager/build/index.js"));
const Product_1 = __webpack_require__(/*! ./actors/Product */ "./src/actors/Product.ts");
function isProductsData(data) {
    return (Array.isArray(data) && data.every((datum) => (0, Product_1.isProductData)(datum)));
}
exports.isProductsData = isProductsData;
class ProductFactory {
    static get productIds() {
        if (!this.productDefinitions) {
            throw new Error('Product definitions not initialized');
        }
        return Object.keys(this.productDefinitions);
    }
    static initialise() {
        const productsData = content_manager_1.default.get('products');
        if (!productsData) {
            throw new Error('Product definitions not found');
        }
        if (!isProductsData(productsData)) {
            throw new Error('Invalid product definitions data');
        }
        this.productDefinitions = Object.fromEntries(productsData.map(product => [product.id, product]));
    }
    static createProduct(level, id, data) {
        const productData = this.productDefinitions[id];
        if (!productData) {
            throw new Error(`Product id "${id}" not found`);
        }
        return Product_1.Product.fromData(level, {
            ...productData,
            ...(data !== null && data !== void 0 ? data : {}),
        });
    }
}
exports.ProductFactory = ProductFactory;
ProductFactory.productDefinitions = {};


/***/ }),

/***/ "./src/ShelfFactory.ts":
/*!*****************************!*\
  !*** ./src/ShelfFactory.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShelfFactory = exports.isAbstractShelfData = void 0;
const actors_1 = __webpack_require__(/*! ./actors */ "./src/actors/index.ts");
function isAbstractShelfData(data, valid) {
    return (typeof data === 'object' &&
        'type' in data &&
        typeof data.type === 'string' &&
        (valid === undefined || valid.includes(data.type)));
}
exports.isAbstractShelfData = isAbstractShelfData;
class ShelfFactory {
    static createShelf(level, data) {
        switch (data.type) {
            case 'shelf':
                return actors_1.Shelf.fromData(level, data);
            case 'closing-shelf':
                return actors_1.ClosingShelf.fromData(level, data);
            case 'supply-shelf':
                return actors_1.SupplyShelf.fromData(level, data);
            case 'disappearing-shelf':
                return actors_1.DisappearingShelf.fromData(level, data);
            case 'deep-shelf':
                return actors_1.DeepShelf.fromData(level, data);
            case 'display-shelf':
                return actors_1.DisplayShelf.fromData(level, data);
            case 'locking-shelf':
                return actors_1.LockingShelf.fromData(level, data);
        }
        throw new Error(`Unknown shelf type: ${data.type}`);
    }
}
exports.ShelfFactory = ShelfFactory;


/***/ }),

/***/ "./src/actors/Actor.ts":
/*!*****************************!*\
  !*** ./src/actors/Actor.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Actor = void 0;
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/cjs-browser/index.js");
class Actor {
    constructor(level) {
        this.level = level;
        this.position = (0, vec_1.vec2)();
        this.disposed = false;
        this.id = (0, uuid_1.v4)();
    }
}
exports.Actor = Actor;


/***/ }),

/***/ "./src/actors/Carousel.ts":
/*!********************************!*\
  !*** ./src/actors/Carousel.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Carousel = exports.isCarouselData = void 0;
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const _1 = __webpack_require__(/*! . */ "./src/actors/index.ts");
const ShelfFactory_1 = __webpack_require__(/*! ../ShelfFactory */ "./src/ShelfFactory.ts");
function isCarouselData(data) {
    return (typeof data === 'object' &&
        ['horizontal', 'vertical'].includes(data.orientation) &&
        typeof data.speed === 'number' &&
        Array.isArray(data.shelves) &&
        data.shelves.every((shelf) => typeof shelf === 'object' && 'type' in shelf));
}
exports.isCarouselData = isCarouselData;
class Carousel extends _1.Actor {
    constructor(level, orientation, speed, shelves) {
        super(level);
        this.orientation = orientation;
        this.speed = speed;
        this.shelves = shelves;
        this.time = 0;
        level.shelves.push(...this.shelves);
    }
    static fromData(level, data) {
        if (!isCarouselData(data)) {
            throw new Error('Invalid carousel data');
        }
        const shelves = data.shelves.map(shelfData => ShelfFactory_1.ShelfFactory.createShelf(level, shelfData));
        return new Carousel(level, data.orientation, data.speed, shelves);
    }
    calculatePosition(camera) {
        const shelfSizes = this.shelves.map(shelf => shelf.calculateSize());
        const { left } = camera.bounds;
        switch (this.orientation) {
            case 'horizontal':
                return left - Math.max(...shelfSizes.map(size => size.x));
            case 'vertical':
                return left - Math.max(...shelfSizes.map(size => size.y));
        }
    }
    calculateSize(camera) {
        const shelfSizes = this.shelves.map(shelf => shelf.calculateSize());
        const { left, right } = camera.bounds;
        switch (this.orientation) {
            case 'horizontal':
                const largestShelfWidth = Math.max(...shelfSizes.map(size => size.x));
                return Math.max(largestShelfWidth + (right - left), shelfSizes.reduce((acc, size) => acc + size.x, 0));
            case 'vertical':
                const largestShelfHeight = Math.max(...shelfSizes.map(size => size.y));
                return Math.max(largestShelfHeight + (right - left), shelfSizes.reduce((acc, size) => acc + size.y, 0));
        }
    }
    update(dt, level, camera) {
        this.time += dt;
        const position = this.calculatePosition(camera);
        switch (this.orientation) {
            case 'horizontal':
                this.position.x = position;
                break;
            case 'vertical':
                this.position.y = position;
                break;
        }
        const productSize = _1.Product.calculateSize();
        const carouselSize = this.calculateSize(camera);
        const speed = productSize.x * this.speed;
        const shelfSizes = this.shelves.map(shelf => shelf.calculateSize());
        const shelfOffsets = (() => {
            switch (this.orientation) {
                case 'horizontal':
                    return (0, utils_1.times)(index => shelfSizes.slice(0, index).reduce((acc, size) => acc + size.x, 0), this.shelves.length);
                case 'vertical':
                    return (0, utils_1.times)(index => shelfSizes.slice(0, index).reduce((acc, size) => acc + size.y, 0), this.shelves.length);
            }
        })();
        this.shelves.forEach((shelf, index) => {
            let offset = vec_1.vec2.mul(shelf.offset, productSize);
            switch (this.orientation) {
                case 'horizontal':
                    shelf.position.x =
                        this.position.x +
                            offset.x +
                            ((this.time * speed + shelfOffsets[index]) % carouselSize);
                    shelf.position.y = this.position.y + offset.y;
                    break;
                case 'vertical':
                    shelf.position.x = this.position.x + offset.x;
                    shelf.position.y =
                        this.position.y +
                            offset.y +
                            ((this.time * speed + shelfOffsets[index]) % carouselSize);
                    break;
            }
            shelf.update(dt, level, camera);
        });
    }
    draw(context) {
        this.shelves.forEach(shelf => {
            shelf.draw(context);
        });
    }
}
exports.Carousel = Carousel;


/***/ }),

/***/ "./src/actors/ClosingShelf.ts":
/*!************************************!*\
  !*** ./src/actors/ClosingShelf.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosingShelf = exports.isClosingShelfData = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const ProductFactory_1 = __webpack_require__(/*! ../ProductFactory */ "./src/ProductFactory.ts");
const Shelf_1 = __webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts");
function isClosingShelfData(data) {
    return (0, Shelf_1.isShelfData)(data);
}
exports.isClosingShelfData = isClosingShelfData;
class ClosingShelf extends Shelf_1.Shelf {
    constructor() {
        super(...arguments);
        this.closed = false;
        this.closingTime = 0;
        this.finishedClosing = false;
    }
    static fromData(level, data) {
        if (!isClosingShelfData(data)) {
            throw new Error('Invalid closing shelf data');
        }
        const products = data.products.map(productId => productId !== null ? ProductFactory_1.ProductFactory.createProduct(level, productId) : null);
        return new ClosingShelf(level, products, data.offset || (0, vec_1.vec2)(), data.slotCount || ClosingShelf.DEFAULT_SLOT_COUNT, data.matchCount || ClosingShelf.DEFAULT_MATCH_COUNT, data.ignore || false, data.reference || undefined);
    }
    update(dt, level, camera) {
        this.products.forEach((product, index) => {
            product === null || product === void 0 ? void 0 : product.update(dt, level, camera, this, index);
        });
        const match = this.checkForMatches();
        if (match.found) {
            this.closed = true;
        }
        if (this.closed) {
            this.closingTime = (0, utils_1.clamp)(this.closingTime + dt, 0, ClosingShelf.CLOSING_TIME);
            if (this.closingTime >= ClosingShelf.CLOSING_TIME) {
                this.finishedClosing = true;
            }
        }
        if (!this.statsUpdated) {
            if (match.found) {
                match.matches.forEach(product => {
                    if (product) {
                        level.stats.productMatches[product.id].total++;
                        level.stats.totalMatches++;
                    }
                });
                this.statsUpdated = true;
            }
            if (this.shelfIsComplete()) {
                level.stats.totalCompletedShelves++;
                this.statsUpdated = true;
            }
        }
    }
    canPickUpProductAtIndex(product, index) {
        if (this.closed) {
            return false;
        }
        return super.canPickUpProductAtIndex(product, index);
    }
    canDropProductAtIndex(product, index) {
        if (this.closed) {
            return false;
        }
        return super.canDropProductAtIndex(product, index);
    }
    shelfIsComplete() {
        return this.closed;
    }
    draw(context) {
        super.draw(context);
        if (this.closed) {
            const size = this.calculateSize();
            const closingAmount = this.finishedClosing
                ? size.y
                : (0, utils_1.remap)(this.closingTime, 0, ClosingShelf.CLOSING_TIME, 0, size.y);
            (0, canvas_helpers_1.rectangle)(context, this.position, (0, vec_1.vec2)(size.x, closingAmount), ClosingShelf.CLOSING_STYLE);
        }
    }
}
exports.ClosingShelf = ClosingShelf;
ClosingShelf.CLOSING_TIME = 0.5;
ClosingShelf.CLOSING_STYLE = {
    stroke: false,
    fill: true,
    fillColor: 'rgba(0, 0, 0, 0.5)',
};


/***/ }),

/***/ "./src/actors/Collapse.ts":
/*!********************************!*\
  !*** ./src/actors/Collapse.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collapse = exports.isCollapseData = void 0;
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const _1 = __webpack_require__(/*! . */ "./src/actors/index.ts");
const ShelfFactory_1 = __webpack_require__(/*! ../ShelfFactory */ "./src/ShelfFactory.ts");
function easeOutBounce(x) {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x < 1 / d1) {
        return n1 * x * x;
    }
    else if (x < 2 / d1) {
        return n1 * (x -= 1.5 / d1) * x + 0.75;
    }
    else if (x < 2.5 / d1) {
        return n1 * (x -= 2.25 / d1) * x + 0.9375;
    }
    else {
        return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
}
function isCollapseData(data) {
    return (typeof data === 'object' &&
        typeof data.grid === 'object' &&
        typeof data.grid.width === 'number' &&
        typeof data.grid.height === 'number' &&
        ['horizontal', 'vertical'].includes(data.orientation) &&
        ['positive', 'negative', 'center'].includes(data.direction) &&
        Array.isArray(data.actors) &&
        data.actors.every((actor) => typeof actor === 'object' && ('type' in actor || isCollapseData(actor))));
}
exports.isCollapseData = isCollapseData;
class Collapse extends _1.Actor {
    constructor(level, grid, orientation, direction, actors) {
        super(level);
        this.grid = grid;
        this.orientation = orientation;
        this.direction = direction;
        this.actors = actors;
        this.actorStates = new Map();
        level.shelves.push(...this.actors.filter(a => a instanceof _1.Shelf));
        this.actors.forEach(actor => {
            this.actorStates.set(actor, {
                targetPosition: (0, vec_1.vec2)(),
            });
        });
        this.calculateTargetPositions();
        this.actors.forEach(actor => {
            if (this.actorStates.has(actor)) {
                const state = this.actorStates.get(actor);
                actor.position = vec_1.vec2.add(this.position, state.targetPosition);
                state.oldPosition = vec_1.vec2.cpy(state.targetPosition);
                state.easeProgress = 0;
            }
        });
    }
    static fromData(level, data) {
        if (!isCollapseData(data)) {
            throw new Error('Invalid collapse data');
        }
        const actors = data.actors.map(actorData => {
            if (actorData.type === 'collapse') {
                return Collapse.fromData(level, actorData);
            }
            return ShelfFactory_1.ShelfFactory.createShelf(level, actorData);
        });
        return new Collapse(level, data.grid, data.orientation, data.direction, actors);
    }
    calculateSize() {
        const size = (0, vec_1.vec2)();
        this.actors.forEach(actor => {
            const actorSize = actor.calculateSize();
            switch (this.orientation) {
                case 'horizontal':
                    size.x += actorSize.x;
                    size.y = Math.max(size.y, actorSize.y);
                    break;
                case 'vertical':
                    size.x = Math.max(size.x, actorSize.x);
                    size.y += actorSize.y;
                    break;
            }
        });
        return size;
    }
    getAABB() {
        return {
            position: this.position,
            size: this.calculateSize(),
        };
    }
    calculateGridSize() {
        return vec_1.vec2.mul((0, vec_1.vec2)(this.grid.width, this.grid.height), _1.Product.calculateSize());
    }
    calculateStartPosition() {
        const gridSize = this.calculateGridSize();
        const contentSize = this.calculateSize();
        const startPosition = (0, vec_1.vec2)();
        switch (this.orientation) {
            case 'horizontal':
                switch (this.direction) {
                    case 'positive':
                        startPosition.x = gridSize.x - contentSize.x;
                        startPosition.y = 0;
                        break;
                    case 'negative':
                        startPosition.x = 0;
                        startPosition.y = 0;
                        break;
                    case 'center':
                        startPosition.x = (gridSize.x - contentSize.x) / 2;
                        startPosition.y = 0;
                        break;
                }
                break;
            case 'vertical':
                switch (this.direction) {
                    case 'positive':
                        startPosition.x = 0;
                        startPosition.y = gridSize.y - contentSize.y;
                        break;
                    case 'negative':
                        startPosition.x = 0;
                        startPosition.y = 0;
                        break;
                    case 'center':
                        startPosition.x = 0;
                        startPosition.y = (gridSize.y - contentSize.y) / 2;
                        break;
                }
                break;
        }
        return startPosition;
    }
    calculateTargetPositions() {
        const startPosition = this.calculateStartPosition();
        let current = (0, vec_1.vec2)();
        this.actors.forEach(actor => {
            const actorSize = actor.calculateSize();
            const targetPosition = vec_1.vec2.add(startPosition, current);
            if (this.actorStates.has(actor)) {
                const state = this.actorStates.get(actor);
                state.targetPosition = targetPosition;
            }
            else {
                this.actorStates.set(actor, { targetPosition });
            }
            switch (this.orientation) {
                case 'horizontal':
                    current.x += actorSize.x;
                    break;
                case 'vertical':
                    current.y += actorSize.y;
                    break;
            }
        });
    }
    update(dt, level, camera) {
        this.calculateTargetPositions();
        this.actors.forEach(actor => {
            var _a, _b, _c, _d, _e;
            if (this.actorStates.has(actor)) {
                const state = this.actorStates.get(actor);
                if (state.easeProgress === undefined ||
                    state.easeProgress >= 1 ||
                    (0, utilities_1.vectorsAlmostEqual)(actor.position, vec_1.vec2.add(this.position, state.targetPosition))) {
                    actor.position = vec_1.vec2.add(this.position, state.targetPosition);
                    state.easeProgress = 0;
                    state.oldPosition = vec_1.vec2.cpy(state.targetPosition);
                }
                else {
                    state.easeProgress = (0, utils_1.clamp)(((_a = state.easeProgress) !== null && _a !== void 0 ? _a : 1) + dt / Collapse.COLLAPSE_TIME, 0, 1);
                    const easedPosition = (0, vec_1.vec2)((0, utils_1.lerp)((_c = (_b = state.oldPosition) === null || _b === void 0 ? void 0 : _b.x) !== null && _c !== void 0 ? _c : 0, state.targetPosition.x, easeOutBounce(state.easeProgress)), (0, utils_1.lerp)((_e = (_d = state.oldPosition) === null || _d === void 0 ? void 0 : _d.y) !== null && _e !== void 0 ? _e : 0, state.targetPosition.y, easeOutBounce(state.easeProgress)));
                    actor.position = vec_1.vec2.add(this.position, easedPosition);
                }
            }
            actor.update(dt, level, camera);
        });
        if (this.actors.length === 0) {
            this.disposed = true;
        }
        this.actors = this.actors.filter(actor => !actor.disposed);
    }
    draw(context) {
        this.actors.forEach(actor => {
            actor.draw(context);
        });
    }
}
exports.Collapse = Collapse;
Collapse.COLLAPSE_TIME = 1.5;


/***/ }),

/***/ "./src/actors/DeepShelf.ts":
/*!*********************************!*\
  !*** ./src/actors/DeepShelf.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeepShelf = exports.isDeepShelfData = void 0;
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const ProductFactory_1 = __webpack_require__(/*! ../ProductFactory */ "./src/ProductFactory.ts");
const Product_1 = __webpack_require__(/*! ./Product */ "./src/actors/Product.ts");
const Shelf_1 = __webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts");
function isDeepShelfData(data) {
    return (typeof data === 'object' &&
        Array.isArray(data.layers) &&
        data.layers.every((layer) => (0, Shelf_1.isShelfProductsData)(layer)) &&
        (data.offset === undefined || (0, utilities_1.isVec2)(data.offset)) &&
        (data.slotCount === undefined || typeof data.slotCount === 'number') &&
        (data.matchCount === undefined || typeof data.matchCount === 'number'));
}
exports.isDeepShelfData = isDeepShelfData;
class DeepShelf extends Shelf_1.Shelf {
    constructor(level, layers, offset = (0, vec_1.vec2)(), slotCount = DeepShelf.DEFAULT_SLOT_COUNT, matchCount = DeepShelf.DEFAULT_MATCH_COUNT, ignore = false, reference) {
        var _a;
        super(level, (_a = (0, utils_1.peek)(layers)) !== null && _a !== void 0 ? _a : new Array(slotCount).fill(null), offset, slotCount, matchCount, ignore, reference);
        this.layers = layers;
        this.nextLayerCanvas = null;
        this.nextLayerContext = null;
        this.nextNextLayerCanvas = null;
        this.nextNextLayerContext = null;
        this.changingLayers = false;
        this.changingLayersTime = 0;
        const size = this.calculateSize();
        this.nextLayerCanvas = document.createElement('canvas');
        this.nextLayerCanvas.width = size.x;
        this.nextLayerCanvas.height = size.y;
        this.nextLayerContext = this.nextLayerCanvas.getContext('2d');
        if (!this.nextLayerContext) {
            throw new Error('Failed to get a context for next layer canvas');
        }
        this.nextNextLayerCanvas = document.createElement('canvas');
        this.nextNextLayerCanvas.width = size.x;
        this.nextNextLayerCanvas.height = size.y;
        this.nextNextLayerContext = this.nextNextLayerCanvas.getContext('2d');
        if (!this.nextNextLayerContext) {
            throw new Error('Failed to get a context for next next layer canvas');
        }
    }
    static fromData(level, data) {
        if (!isDeepShelfData(data)) {
            throw new Error('Invalid DeepShelf data');
        }
        const layers = data.layers.map((layer) => layer.map(productId => productId === null
            ? null
            : ProductFactory_1.ProductFactory.createProduct(level, productId)));
        return new DeepShelf(level, layers, data.offset || (0, vec_1.vec2)(), data.slotCount || DeepShelf.DEFAULT_SLOT_COUNT, data.matchCount || DeepShelf.DEFAULT_MATCH_COUNT, data.ignore || false, data.reference || undefined);
    }
    update(dt, level, camera) {
        var _a;
        super.update(dt, level, camera);
        this.layers.slice(0, -1).forEach(layer => {
            layer.forEach((product, index) => {
                if (product !== null) {
                    product.size = Product_1.Product.calculateSize();
                    product.positionImmediate = vec_1.vec2.add(this.position, vec_1.vec2.mul((0, vec_1.vec2)(product.size.x, 0), index));
                }
            });
        });
        this.layers.forEach((layer, layerIndex) => {
            this.layers[layerIndex] = layer.map(product => {
                if (product && product.finishedDisappearing) {
                    return null;
                }
                return product;
            });
        });
        if (this.layers.length > 0) {
            const currentLayer = (0, utils_1.peek)(this.layers);
            if (this.layerIsEmpty(currentLayer) && !this.changingLayers) {
                this.changingLayers = true;
                this.changingLayersTime = DeepShelf.CHANGING_LAYERS_ANIMATION_TIME;
            }
        }
        this.changingLayersTime = (0, utils_1.clamp)(this.changingLayersTime - dt, 0, DeepShelf.CHANGING_LAYERS_ANIMATION_TIME);
        if (this.changingLayers && this.changingLayersTime <= 0) {
            if (this.layers.length > 1) {
                this.layers.pop();
            }
            this.products = (_a = (0, utils_1.peek)(this.layers)) !== null && _a !== void 0 ? _a : new Array(this.slotCount).fill(null);
            this.changingLayers = false;
            this.statsUpdated = false;
        }
    }
    layerIsEmpty(layer) {
        return layer.every(product => product === null);
    }
    shelfIsEmpty() {
        return this.layers.every(layer => this.layerIsEmpty(layer));
    }
    shelfIsComplete() {
        return this.shelfIsEmpty();
    }
    addProductAtIndex(index, product) {
        if (index < 0 || index >= this.slotCount) {
            return false;
        }
        if (this.products[index] !== null) {
            return false;
        }
        if (this.layers.length === 0) {
            return false;
        }
        this.products[index] = product;
        (0, utils_1.peek)(this.layers)[index] = product;
        return true;
    }
    removeProductAtIndex(index) {
        if (index < 0 || index >= this.slotCount) {
            return null;
        }
        if (this.layers.length === 0) {
            return null;
        }
        const product = this.products[index];
        this.products[index] = null;
        (0, utils_1.peek)(this.layers)[index] = null;
        return product;
    }
    lockProductAtIndex(index, locked = true) {
        const layer = Math.floor(index / this.slotCount);
        const layerIndex = index % this.slotCount;
        if (layer < 0 ||
            layer >= this.layers.length ||
            layerIndex < 0 ||
            layerIndex >= this.slotCount) {
            return null;
        }
        const product = this.layers[layer][layerIndex];
        if (product === null) {
            return null;
        }
        product.locked = locked;
        return product.locked;
    }
    draw(context) {
        const size = this.calculateSize();
        const halfSize = vec_1.vec2.div(size, 2);
        if (this.nextNextLayerCanvas &&
            this.nextNextLayerContext &&
            this.layers.length > 2 &&
            this.changingLayers) {
            this.nextNextLayerCanvas.width = size.x;
            this.nextNextLayerCanvas.height = size.y;
            this.nextNextLayerContext.save();
            this.nextNextLayerContext.clearRect(0, 0, size.x, size.y);
            this.nextNextLayerContext.translate(-this.position.x, -this.position.y);
            const nextNextLayerIndex = this.layers.length - 3;
            this.layers[nextNextLayerIndex].forEach(product => {
                if (product === null) {
                    return;
                }
                product.draw(this.nextNextLayerContext);
            });
            this.nextNextLayerContext.fillStyle = DeepShelf.NEXT_LAYER_OVERLAY_COLOR;
            this.nextNextLayerContext.globalCompositeOperation = 'source-atop';
            this.nextNextLayerContext.fillRect(this.position.x, this.position.y, size.x, size.y);
            this.nextNextLayerContext.restore();
            context.save();
            context.globalAlpha = (0, utils_1.remap)(this.changingLayersTime, DeepShelf.CHANGING_LAYERS_ANIMATION_TIME, 0, 0, DeepShelf.NEXT_LAYER_ALPHA);
            context.translate(this.position.x + halfSize.x + DeepShelf.NEXT_LAYER_OFFSET.x, this.position.y + halfSize.y + DeepShelf.NEXT_LAYER_OFFSET.y);
            context.scale(DeepShelf.NEXT_LAYER_SCALE, DeepShelf.NEXT_LAYER_SCALE);
            context.drawImage(this.nextNextLayerCanvas, -halfSize.x, -halfSize.y, size.x, size.y);
            context.restore();
        }
        if (this.nextLayerCanvas &&
            this.nextLayerContext &&
            this.layers.length > 1) {
            this.nextLayerCanvas.width = size.x;
            this.nextLayerCanvas.height = size.y;
            this.nextLayerContext.save();
            this.nextLayerContext.clearRect(0, 0, size.x, size.y);
            this.nextLayerContext.translate(-this.position.x, -this.position.y);
            const nextLayerIndex = this.layers.length - 2;
            this.layers[nextLayerIndex].forEach(product => {
                if (product === null) {
                    return;
                }
                product.draw(this.nextLayerContext);
            });
            this.nextLayerContext.fillStyle = DeepShelf.NEXT_LAYER_OVERLAY_COLOR;
            this.nextLayerContext.globalCompositeOperation = 'source-atop';
            if (this.changingLayers) {
                this.nextLayerContext.globalAlpha = (0, utils_1.unlerp)(0, DeepShelf.CHANGING_LAYERS_ANIMATION_TIME, this.changingLayersTime);
            }
            this.nextLayerContext.fillRect(this.position.x, this.position.y, size.x, size.y);
            this.nextLayerContext.restore();
            let nextLayerAlpha = DeepShelf.NEXT_LAYER_ALPHA;
            let nextLayerOffset = vec_1.vec2.cpy(DeepShelf.NEXT_LAYER_OFFSET);
            let nextLayerScale = DeepShelf.NEXT_LAYER_SCALE;
            if (this.changingLayers) {
                const i = 1 -
                    (0, utils_1.unlerp)(0, DeepShelf.CHANGING_LAYERS_ANIMATION_TIME, this.changingLayersTime);
                nextLayerAlpha = (0, utils_1.lerp)(DeepShelf.NEXT_LAYER_ALPHA, 1, i);
                nextLayerOffset = (0, vec_1.vec2)((0, utils_1.lerp)(DeepShelf.NEXT_LAYER_OFFSET.x, 0, i), (0, utils_1.lerp)(DeepShelf.NEXT_LAYER_OFFSET.y, 0, i));
                nextLayerScale = (0, utils_1.lerp)(DeepShelf.NEXT_LAYER_SCALE, 1, i);
            }
            context.save();
            context.globalAlpha = nextLayerAlpha;
            context.translate(this.position.x + halfSize.x + nextLayerOffset.x, this.position.y + halfSize.y + nextLayerOffset.y);
            context.scale(nextLayerScale, nextLayerScale);
            context.drawImage(this.nextLayerCanvas, -halfSize.x, -halfSize.y, size.x, size.y);
            context.restore();
        }
        super.draw(context);
    }
}
exports.DeepShelf = DeepShelf;
DeepShelf.NEXT_LAYER_SCALE = 0.9;
DeepShelf.NEXT_LAYER_OFFSET = (0, vec_1.vec2)(0, -8);
DeepShelf.NEXT_LAYER_ALPHA = 0.8;
DeepShelf.NEXT_LAYER_OVERLAY_COLOR = 'rgba(0, 0, 0, 0.6)';
DeepShelf.CHANGING_LAYERS_ANIMATION_TIME = 0.5;


/***/ }),

/***/ "./src/actors/DisappearingShelf.ts":
/*!*****************************************!*\
  !*** ./src/actors/DisappearingShelf.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisappearingShelf = exports.isDisappearingShelfData = void 0;
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const ShelfFactory_1 = __webpack_require__(/*! ../ShelfFactory */ "./src/ShelfFactory.ts");
const Shelf_1 = __webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts");
function isDisappearingShelfData(data) {
    return (typeof data === 'object' &&
        (0, ShelfFactory_1.isAbstractShelfData)(data.shelf, [
            'shelf',
            'deep-shelf',
            'display-shelf',
            'locking-shelf',
            'supply-shelf',
        ]) &&
        (data.offset === undefined || (0, utilities_1.isVec2)(data.offset)));
}
exports.isDisappearingShelfData = isDisappearingShelfData;
class DisappearingShelf extends Shelf_1.Shelf {
    constructor(level, shelf, offset = (0, vec_1.vec2)()) {
        super(level, [], offset, undefined, undefined, true, undefined, false);
        this.shelf = shelf;
        this.offset = offset;
        this.disappearing = false;
        this.disappearingTime = 0;
    }
    static fromData(level, data) {
        if (!isDisappearingShelfData(data)) {
            throw new Error('Invalid disappearing shelf data');
        }
        const shelf = ShelfFactory_1.ShelfFactory.createShelf(level, data.shelf);
        return new DisappearingShelf(level, shelf, data.offset || (0, vec_1.vec2)());
    }
    update(dt, level, camera) {
        this.shelf.position = this.position;
        this.shelf.update(dt, level, camera);
        if (this.shelfIsComplete() && !this.disappearing) {
            this.disappearing = true;
            this.disappearingTime = DisappearingShelf.DISAPPEARING_ANIMATION_TIME;
            level.stats.totalCompletedShelves++;
        }
        if (this.disappearing) {
            this.disappearingTime = (0, utils_1.clamp)(this.disappearingTime - dt, 0, DisappearingShelf.DISAPPEARING_ANIMATION_TIME);
            if (this.disappearingTime <= 0) {
                this.shelf.disposed = true;
                this.disposed = true;
            }
        }
    }
    findShelfSlot(_product) {
        return { valid: false };
    }
    canPickUpProductAtIndex(_product, _index) {
        return false;
    }
    canDropProductAtIndex(_product, _index) {
        return false;
    }
    shelfIsEmpty() {
        return true;
    }
    shelfIsComplete() {
        return this.shelf.shelfIsComplete();
    }
    getAABB(index) {
        return this.shelf.getAABB(index);
    }
    draw(context) {
        const halfSize = vec_1.vec2.scale(this.calculateSize(), 0.5);
        if (this.disappearing) {
            context.save();
            context.translate(this.position.x + halfSize.x, this.position.y + halfSize.y);
            let scale;
            if (this.disappearingTime >=
                DisappearingShelf.DISAPPEARING_ANIMATION_TIME -
                    DisappearingShelf.DISAPPEARING_ANIMATION_GROW_TIME) {
                scale = (0, utils_1.remap)(this.disappearingTime, DisappearingShelf.DISAPPEARING_ANIMATION_TIME, DisappearingShelf.DISAPPEARING_ANIMATION_TIME -
                    DisappearingShelf.DISAPPEARING_ANIMATION_GROW_TIME, 1, DisappearingShelf.DISAPPEARING_ANIMATION_SCALE_AMOUNT);
            }
            else {
                scale = (0, utils_1.remap)(this.disappearingTime, DisappearingShelf.DISAPPEARING_ANIMATION_TIME -
                    DisappearingShelf.DISAPPEARING_ANIMATION_GROW_TIME, 0, DisappearingShelf.DISAPPEARING_ANIMATION_SCALE_AMOUNT, 0);
            }
            context.scale(scale, scale);
            context.translate(-this.position.x - halfSize.x, -this.position.y - halfSize.y);
            this.shelf.draw(context);
            context.restore();
        }
        else {
            this.shelf.draw(context);
        }
    }
}
exports.DisappearingShelf = DisappearingShelf;
DisappearingShelf.DISAPPEARING_ANIMATION_TIME = 0.5;
DisappearingShelf.DISAPPEARING_ANIMATION_SCALE_AMOUNT = 1.1;
DisappearingShelf.DISAPPEARING_ANIMATION_GROW_TIME = 0.2;


/***/ }),

/***/ "./src/actors/DisplayShelf.ts":
/*!************************************!*\
  !*** ./src/actors/DisplayShelf.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisplayShelf = exports.isDisplayShelfData = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const ProductFactory_1 = __webpack_require__(/*! ../ProductFactory */ "./src/ProductFactory.ts");
const Product_1 = __webpack_require__(/*! ./Product */ "./src/actors/Product.ts");
const Shelf_1 = __webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts");
function isDisplayShelfData(data) {
    return (0, Shelf_1.isShelfData)(data) && (0, Shelf_1.isShelfProductsData)(data.allowed);
}
exports.isDisplayShelfData = isDisplayShelfData;
class DisplayShelf extends Shelf_1.Shelf {
    constructor(level, allowed, products, offset = (0, vec_1.vec2)(), slotCount = Shelf_1.Shelf.DEFAULT_SLOT_COUNT, matchCount = Shelf_1.Shelf.DEFAULT_MATCH_COUNT, ignore = false, reference, addToLevel = true) {
        super(level, products, offset, slotCount, matchCount, ignore, reference, addToLevel);
        this.allowed = allowed;
        this.products = products;
        this.offset = offset;
        this.slotCount = slotCount;
        this.matchCount = matchCount;
        this.ignore = ignore;
        this.reference = reference;
        this.completed = false;
        this.completingTime = 0;
        this.finishedCompleting = false;
    }
    static fromData(level, data) {
        if (!isDisplayShelfData(data)) {
            throw new Error('Invalid display shelf data');
        }
        const allowed = data.allowed.map(productId => productId !== null ? ProductFactory_1.ProductFactory.createProduct(level, productId) : null);
        const products = data.products.map(productId => productId !== null ? ProductFactory_1.ProductFactory.createProduct(level, productId) : null);
        return new DisplayShelf(level, allowed, products, data.offset || (0, vec_1.vec2)(), data.slotCount || Shelf_1.Shelf.DEFAULT_SLOT_COUNT, data.matchCount || Shelf_1.Shelf.DEFAULT_MATCH_COUNT, data.ignore || false, data.reference || undefined);
    }
    update(dt, level, camera) {
        const productSize = Product_1.Product.calculateSize();
        this.allowed.forEach((product, index) => {
            if (product === null) {
                return;
            }
            product.positionImmediate = vec_1.vec2.add(this.position, vec_1.vec2.mul((0, vec_1.vec2)(productSize.x, 0), index));
        });
        this.products.forEach((product, index) => {
            product === null || product === void 0 ? void 0 : product.update(dt, level, camera, this, index);
        });
        const match = this.checkForMatches();
        if (match.found) {
            this.completed = true;
        }
        if (this.completed) {
            this.completingTime = (0, utils_1.clamp)(this.completingTime + dt, 0, DisplayShelf.COMPLETING_TIME);
            if (this.completingTime >= DisplayShelf.COMPLETING_TIME) {
                this.finishedCompleting = true;
            }
        }
        if (!this.statsUpdated) {
            if (match.found) {
                match.matches.forEach(product => {
                    if (product) {
                        level.stats.productMatches[product.id].total++;
                        level.stats.totalMatches++;
                    }
                });
                this.statsUpdated = true;
            }
            if (this.shelfIsComplete()) {
                level.stats.totalCompletedShelves++;
                this.statsUpdated = true;
            }
        }
    }
    checkForMatches() {
        var _a;
        let matches = [];
        for (const [index, allowed] of this.allowed.entries()) {
            if (allowed === null && this.products[index] === null) {
                continue;
            }
            if (allowed !== null &&
                this.products[index] !== null &&
                ((_a = this.products[index]) === null || _a === void 0 ? void 0 : _a.matchesProduct(allowed))) {
                matches.push(this.products[index]);
                continue;
            }
            return { found: false, matches: [] };
        }
        return { found: true, matches };
    }
    canPickUpProductAtIndex(product, index) {
        if (this.completed) {
            return false;
        }
        return super.canPickUpProductAtIndex(product, index);
    }
    canDropProductAtIndex(product, index) {
        if (this.completed) {
            return false;
        }
        return super.canDropProductAtIndex(product, index);
    }
    shelfIsComplete() {
        return this.completed;
    }
    draw(context) {
        super.draw(context, false);
        context.save();
        this.allowed.forEach(product => {
            if (product === null) {
                return;
            }
            product.drawOutline(context);
        });
        this.products.forEach(product => {
            if (product === null) {
                return;
            }
            if (product.dragging) {
                return;
            }
            product.draw(context);
        });
        context.restore();
        if (this.completed) {
            const size = this.calculateSize();
            const completingAmount = this.finishedCompleting
                ? size.y
                : (0, utils_1.remap)(this.completingTime, 0, DisplayShelf.COMPLETING_TIME, 0, size.y);
            (0, canvas_helpers_1.rectangle)(context, this.position, (0, vec_1.vec2)(size.x, completingAmount), DisplayShelf.COMPLETING_STYLE);
        }
    }
}
exports.DisplayShelf = DisplayShelf;
DisplayShelf.COMPLETING_TIME = 0.5;
DisplayShelf.COMPLETING_STYLE = {
    stroke: false,
    fill: true,
    fillColor: 'rgba(0, 255, 0, 0.5)',
};


/***/ }),

/***/ "./src/actors/LockingShelf.ts":
/*!************************************!*\
  !*** ./src/actors/LockingShelf.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockingShelf = exports.isLockingShelfData = exports.isLockingModeData = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const ProductFactory_1 = __webpack_require__(/*! ../ProductFactory */ "./src/ProductFactory.ts");
const ShelfFactory_1 = __webpack_require__(/*! ../ShelfFactory */ "./src/ShelfFactory.ts");
const Shelf_1 = __webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts");
function isLockingModeData(data) {
    if (typeof data !== 'object' || !data.mode) {
        return false;
    }
    switch (data.mode) {
        case 'toggle-timer':
            return (typeof data.time === 'number' &&
                typeof data.initiallyLocked === 'boolean' &&
                (data.finalCountdownUnlock === undefined ||
                    typeof data.finalCountdownUnlock === 'number'));
        case 'countdown-timer':
            return typeof data.time === 'number';
        case 'match-products':
            return typeof data.product === 'string' && typeof data.n === 'number';
        case 'complete-shelves':
            return typeof data.n === 'number';
        case 'complete-shelf':
            return typeof data.shelfIndex === 'number';
        case 'place-product':
            return (typeof data.shelfIndex === 'number' &&
                typeof data.slotIndex === 'number' &&
                (data.latch === undefined || typeof data.latch === 'boolean') &&
                (data.inverted === undefined || typeof data.inverted === 'boolean') &&
                (data.product === undefined || typeof data.product === 'string'));
    }
    return false;
}
exports.isLockingModeData = isLockingModeData;
function isLockingShelfData(data) {
    return (typeof data === 'object' &&
        (0, ShelfFactory_1.isAbstractShelfData)(data.shelf, [
            'shelf',
            'closing-shelf',
            'deep-shelf',
            'disappearing-shelf',
            'display-shelf',
            'supply-shelf',
        ]) &&
        isLockingModeData(data.locking) &&
        (data.offset === undefined || (0, utilities_1.isVec2)(data.offset)));
}
exports.isLockingShelfData = isLockingShelfData;
class LockingShelf extends Shelf_1.Shelf {
    constructor(level, shelf, locking, offset = (0, vec_1.vec2)()) {
        const originalShelfCanDropProductAtIndex = shelf.canDropProductAtIndex.bind(shelf);
        shelf.canDropProductAtIndex = (product, index) => {
            if (this.locked) {
                return false;
            }
            return originalShelfCanDropProductAtIndex(product, index);
        };
        const originalShelfCanPickUpProductAtIndex = shelf.canPickUpProductAtIndex.bind(shelf);
        shelf.canPickUpProductAtIndex = (product, index) => {
            if (this.locked) {
                return false;
            }
            return originalShelfCanPickUpProductAtIndex(product, index);
        };
        super(level, [], offset, undefined, undefined, true, undefined, false);
        this.shelf = shelf;
        this.locking = locking;
        this.offset = offset;
        this.locked = false;
        this.lockingTime = 0;
    }
    static fromData(level, data) {
        if (!isLockingShelfData(data)) {
            throw new Error('Invalid locking shelf data');
        }
        const shelf = ShelfFactory_1.ShelfFactory.createShelf(level, data.shelf);
        let locking;
        if ('product' in data.locking && data.locking.product !== undefined) {
            locking = {
                ...data.locking,
                product: ProductFactory_1.ProductFactory.createProduct(level, data.locking.product),
            };
        }
        else {
            locking = { ...data.locking };
        }
        return new LockingShelf(level, shelf, locking, data.offset || (0, vec_1.vec2)());
    }
    update(dt, level, camera) {
        this.shelf.position = this.position;
        this.shelf.update(dt, level, camera);
        this.locked = this.shelfIsLocked(level);
        this.lockingTime = (0, utils_1.clamp)(this.lockingTime + (this.locked ? dt : -dt), 0, LockingShelf.LOCKING_TIME);
    }
    shelfIsLocked(level) {
        var _a;
        switch (this.locking.mode) {
            case 'toggle-timer':
                if (this.locking.finalCountdownUnlock !== undefined &&
                    level.data.timeLimit !== undefined &&
                    level.data.timeLimit - level.stats.time <=
                        this.locking.finalCountdownUnlock) {
                    return false;
                }
                return (Math.floor(level.stats.time / this.locking.time +
                    (this.locking.initiallyLocked ? 0 : 0.5)) %
                    2 ===
                    0);
            case 'countdown-timer':
                return level.stats.time > this.locking.time;
            case 'match-products':
                if ('product' in this.locking && this.locking.product !== undefined) {
                    const matches = Object.values(level.stats.productMatches).filter(({ product, total }) => this.locking.product.matchesProduct(product) &&
                        total >= this.locking.n);
                    return matches.length > 0;
                }
                return level.stats.totalMatches >= this.locking.n;
            case 'complete-shelves':
                return level.stats.totalCompletedShelves >= this.locking.n;
            case 'complete-shelf':
                return !!((_a = level.stats.completedShelves[this.locking.shelfReference]) === null || _a === void 0 ? void 0 : _a.completed);
            case 'place-product':
                let locked = false;
                if (this.locking.latch) {
                    locked = level.stats.productPlacements.some(({ shelf, slot, product }) => shelf.reference === this.locking.shelfReference &&
                        slot === this.mode.slot &&
                        (this.locking.product === undefined ||
                            product.matchesProduct(this.locking.product)));
                }
                else {
                    locked = Object.values(level.stats.currentProductPlacement).some(({ shelf, products }) => shelf.reference === this.locking.shelfReference &&
                        products.some((product, index) => product !== null &&
                            index === this.mode.slot &&
                            (this.locking.product === undefined ||
                                product.matchesProduct(this.locking.product))));
                }
                return this.locking.inverted ? !locked : locked;
        }
    }
    findShelfSlot(_product) {
        return { valid: false };
    }
    canPickUpProductAtIndex(_product, _index) {
        return false;
    }
    canDropProductAtIndex(_product, _index) {
        return false;
    }
    shelfIsEmpty() {
        return true;
    }
    shelfIsComplete() {
        return this.shelf.shelfIsComplete();
    }
    getAABB(index) {
        return this.shelf.getAABB(index);
    }
    draw(context) {
        this.shelf.draw(context);
        const size = this.calculateSize();
        const lockedAmount = (0, utils_1.remap)(this.lockingTime, 0, LockingShelf.LOCKING_TIME, 0, size.y);
        (0, canvas_helpers_1.rectangle)(context, this.position, (0, vec_1.vec2)(size.x, lockedAmount), LockingShelf.LOCKING_STYLE);
    }
}
exports.LockingShelf = LockingShelf;
LockingShelf.LOCKING_TIME = 0.3;
LockingShelf.LOCKING_STYLE = {
    stroke: false,
    fill: true,
    fillColor: 'rgba(255, 128, 0, 0.5)',
};


/***/ }),

/***/ "./src/actors/Product.ts":
/*!*******************************!*\
  !*** ./src/actors/Product.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Product = exports.isProductData = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const input_manager_1 = __importDefault(__webpack_require__(/*! @basementuniverse/input-manager */ "./node_modules/@basementuniverse/input-manager/build/index.js"));
const _2d_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/2d */ "./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js");
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const _1 = __webpack_require__(/*! . */ "./src/actors/index.ts");
const Game_1 = __importDefault(__webpack_require__(/*! ../Game */ "./src/Game.ts"));
const GameScene_1 = __webpack_require__(/*! ../GameScene */ "./src/GameScene.ts");
function isProductData(data) {
    return (typeof data === 'object' &&
        typeof data.id === 'string' &&
        typeof data.name === 'string' &&
        typeof data.image === 'string' &&
        Array.isArray(data.matches) &&
        data.matches.every((match) => typeof match === 'string') &&
        (data.points === undefined || typeof data.points === 'number'));
}
exports.isProductData = isProductData;
class Product extends _1.Actor {
    constructor(level, id, name, image, matches, points = Product.DEFAULT_POINTS) {
        super(level);
        this.id = id;
        this.name = name;
        this.image = image;
        this.matches = matches;
        this.points = points;
        this.size = (0, vec_1.vec2)();
        this.hovered = false;
        this.finishedMoving = true;
        this.dragging = false;
        this.dragOffset = null;
        this.targetPosition = null;
        this.actualPosition = (0, vec_1.vec2)();
        this.moveTime = 0;
        this.targetRotation = null;
        this.actualRotation = 0;
        this.velocity = (0, vec_1.vec2)();
        this.previousPosition = null;
        this.landingTime = 0;
        this.previousShelfAndSlot = null;
        this.disappearing = false;
        this.startedDisappearing = false;
        this.finishedDisappearing = false;
        this.disappearingTime = 0;
        this.disappearingDelay = 0;
        this.locked = false;
    }
    static fromData(level, data) {
        if (!isProductData(data)) {
            throw new Error('Invalid product data');
        }
        return new Product(level, data.id, data.name, data.image, data.matches, data.points);
    }
    static calculateSize() {
        const size = (0, vec_1.vec2)();
        size.x = Game_1.default.screen.x / GameScene_1.GameScene.SCREEN_WIDTH_PRODUCTS;
        size.y = size.x * Product.ASPECT_RATIO;
        return size;
    }
    set positionImmediate(value) {
        this.actualPosition = vec_1.vec2.cpy(value);
        this.targetPosition = null;
        this.dragging = false;
        this.finishedMoving = true;
        this.landingTime = 0;
        this.previousShelfAndSlot = null;
    }
    update(dt, level, camera, shelf, slotIndex) {
        var _a, _b;
        this.size = Product.calculateSize();
        const mouseWorldPosition = camera.screenToWorld(input_manager_1.default.mousePosition);
        this.previousPosition = vec_1.vec2.cpy(this.actualPosition);
        if (this.previousShelfAndSlot === null) {
            this.previousShelfAndSlot = { shelf, slotIndex };
        }
        const intersects = (0, _2d_1.pointInAABB)(mouseWorldPosition, this.getAABB()).intersects;
        this.hovered = intersects || this.dragging;
        if (input_manager_1.default.mousePressed() &&
            intersects &&
            shelf.canPickUpProductAtIndex(this, slotIndex) &&
            !this.locked) {
            this.dragging = true;
            this.finishedMoving = false;
            this.dragOffset = vec_1.vec2.sub(mouseWorldPosition, this.actualPosition);
            level.startDraggingProduct(shelf, slotIndex, this);
        }
        if (this.dragging && input_manager_1.default.mouseDown()) {
            this.targetPosition = vec_1.vec2.sub(mouseWorldPosition, (_a = this.dragOffset) !== null && _a !== void 0 ? _a : (0, vec_1.vec2)());
            this.moveTime = Product.MOVE_COOLDOWN_TIME;
        }
        this.moveTime = (0, utils_1.clamp)(this.moveTime - dt, 0, Product.MOVE_COOLDOWN_TIME);
        if (!this.dragging) {
            this.targetPosition = vec_1.vec2.add(shelf.position, vec_1.vec2.mul((0, vec_1.vec2)(this.size.x, 0), slotIndex));
            if (this.moveTime === 0) {
                this.finishedMoving = true;
                this.actualPosition = vec_1.vec2.cpy(this.targetPosition);
            }
            if (this.previousShelfAndSlot &&
                (this.previousShelfAndSlot.shelf !== shelf ||
                    this.previousShelfAndSlot.slotIndex !== slotIndex) &&
                vec_1.vec2.len(vec_1.vec2.sub(this.actualPosition, this.targetPosition)) <
                    Product.LANDING_ANIMATION_START_RANGE) {
                this.landingTime = Product.LANDING_ANIMATION_TIME;
                this.previousShelfAndSlot = { shelf, slotIndex };
            }
        }
        this.landingTime = (0, utils_1.clamp)(this.landingTime - dt, 0, Product.LANDING_ANIMATION_TIME);
        if (this.disappearing) {
            this.disappearingDelay = (0, utils_1.clamp)(this.disappearingDelay - dt, 0, Infinity);
            if (!this.startedDisappearing && this.disappearingDelay <= 0) {
                this.startedDisappearing = true;
            }
            if (this.startedDisappearing) {
                this.disappearingTime = (0, utils_1.clamp)(this.disappearingTime - dt, 0, Product.DISAPPEARING_ANIMATION_TIME);
            }
            if (this.disappearingTime <= 0) {
                this.finishedDisappearing = true;
            }
        }
        if (this.targetPosition) {
            if ((0, utilities_1.vectorsAlmostEqual)(this.actualPosition, this.targetPosition)) {
                this.actualPosition = vec_1.vec2.cpy(this.targetPosition);
                if (!this.dragging) {
                    this.finishedMoving = true;
                }
            }
            else {
                const delta = vec_1.vec2.sub(this.targetPosition, this.actualPosition);
                this.actualPosition = vec_1.vec2.add(this.actualPosition, vec_1.vec2.mul(delta, Product.MOVE_EASE_AMOUNT));
            }
        }
        this.velocity = vec_1.vec2.sub(this.actualPosition, (_b = this.previousPosition) !== null && _b !== void 0 ? _b : (0, vec_1.vec2)());
        if (this.dragging || !this.finishedMoving) {
            this.targetRotation = this.velocity.x * Product.DRAG_ROTATION_AMOUNT;
        }
        else {
            this.targetRotation = 0;
        }
        this.actualRotation = (0, utils_1.clamp)(this.actualRotation +
            (this.targetRotation - this.actualRotation) *
                Product.ROTATION_EASE_AMOUNT, -Product.MAX_ROTATION, Product.MAX_ROTATION);
    }
    disappear(delay = 0) {
        if (this.disappearing) {
            return;
        }
        this.disappearing = true;
        this.startedDisappearing = false;
        this.finishedDisappearing = false;
        this.disappearingTime = Product.DISAPPEARING_ANIMATION_TIME;
        this.disappearingDelay = delay;
    }
    getAABB() {
        return {
            position: this.actualPosition,
            size: this.size,
        };
    }
    matchesProduct(other) {
        return this.matches.includes(other.id);
    }
    draw(context) {
        const halfSize = vec_1.vec2.div(this.size, 2);
        context.save();
        context.translate(this.actualPosition.x + halfSize.x, this.actualPosition.y + halfSize.y);
        context.rotate(this.actualRotation);
        if (this.landingTime > 0) {
            let size = vec_1.vec2.cpy(this.size);
            size.x =
                1 +
                    Math.sin((0, utils_1.remap)(this.landingTime, 0, Product.LANDING_ANIMATION_TIME, 0, Math.PI)) *
                        Product.LANDING_ANIMATION_X_SCALE_AMOUNT;
            size.y =
                1 +
                    Math.sin((0, utils_1.remap)(this.landingTime, 0, Product.LANDING_ANIMATION_TIME, 0, Math.PI)) *
                        Product.LANDING_ANIMATION_Y_SCALE_AMOUNT;
            context.translate(0, (this.size.y * (1 - size.y)) / 2);
            context.scale(size.x, size.y);
        }
        if (this.disappearing && this.startedDisappearing) {
            let scale;
            if (this.disappearingTime >=
                Product.DISAPPEARING_ANIMATION_TIME -
                    Product.DISAPPEARING_ANIMATION_GROW_TIME) {
                scale = (0, utils_1.remap)(this.disappearingTime, Product.DISAPPEARING_ANIMATION_TIME, Product.DISAPPEARING_ANIMATION_TIME -
                    Product.DISAPPEARING_ANIMATION_GROW_TIME, 1, Product.DISAPPEARING_ANIMATION_SCALE_AMOUNT);
            }
            else {
                scale = (0, utils_1.remap)(this.disappearingTime, Product.DISAPPEARING_ANIMATION_TIME -
                    Product.DISAPPEARING_ANIMATION_GROW_TIME, 0, Product.DISAPPEARING_ANIMATION_SCALE_AMOUNT, 0);
            }
            context.scale(scale, scale);
        }
        (0, canvas_helpers_1.rectangle)(context, vec_1.vec2.mul(halfSize, -0.5), vec_1.vec2.scale(this.size, 0.5), {
            ...Product.STYLE,
            fillColor: !this.finishedMoving
                ? 'yellow'
                : this.hovered
                    ? Product.BACKGROUND_HOVER_COLOR
                    : Product.BACKGROUND_COLOR,
        });
        if (this.name) {
            context.fillStyle = 'black';
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(this.name, 0, 0);
        }
        if (this.locked) {
            context.fillStyle = 'red';
            context.font = 'bold 16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('LOCKED', 0, 20);
        }
        context.restore();
    }
    drawOutline(context) {
        const size = Product.calculateSize();
        const halfSize = vec_1.vec2.div(size, 2);
        context.save();
        context.translate(this.actualPosition.x, this.actualPosition.y);
        (0, canvas_helpers_1.rectangle)(context, (0, vec_1.vec2)(), size, Product.OUTLINE_STYLE);
        if (this.name) {
            context.fillStyle = Product.OUTLINE_STYLE.strokeColor;
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(this.name, halfSize.x, halfSize.y);
        }
        context.restore();
    }
}
exports.Product = Product;
Product.DEFAULT_POINTS = 1;
Product.ASPECT_RATIO = 1.5;
Product.STYLE = {
    fill: true,
    stroke: false,
};
Product.OUTLINE_STYLE = {
    fill: false,
    stroke: true,
    strokeColor: 'rgba(255, 255, 255, 0.8)',
    lineStyle: 'dotted',
};
Product.BACKGROUND_COLOR = 'white';
Product.BACKGROUND_HOVER_COLOR = 'green';
Product.MOVE_EASE_AMOUNT = 0.35;
Product.MOVE_COOLDOWN_TIME = 0.75;
Product.DRAG_ROTATION_AMOUNT = 0.02;
Product.ROTATION_EASE_AMOUNT = 0.35;
Product.MAX_ROTATION = Math.PI / 4;
Product.LANDING_ANIMATION_TIME = 0.4;
Product.LANDING_ANIMATION_START_RANGE = 5;
Product.LANDING_ANIMATION_X_SCALE_AMOUNT = 0.2;
Product.LANDING_ANIMATION_Y_SCALE_AMOUNT = -0.3;
Product.DISAPPEARING_ANIMATION_TIME = 0.5;
Product.DISAPPEARING_ANIMATION_SCALE_AMOUNT = 1.2;
Product.DISAPPEARING_ANIMATION_GROW_TIME = 0.2;


/***/ }),

/***/ "./src/actors/Shelf.ts":
/*!*****************************!*\
  !*** ./src/actors/Shelf.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shelf = exports.isShelfProductsData = exports.isShelfData = void 0;
const canvas_helpers_1 = __webpack_require__(/*! @basementuniverse/canvas-helpers */ "./node_modules/@basementuniverse/canvas-helpers/build/index.js");
const _2d_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/2d */ "./node_modules/@basementuniverse/intersection-helpers/build/2d/index.js");
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const utils_1 = __webpack_require__(/*! @basementuniverse/utils */ "./node_modules/@basementuniverse/utils/utils.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const _1 = __webpack_require__(/*! . */ "./src/actors/index.ts");
const ProductFactory_1 = __webpack_require__(/*! ../ProductFactory */ "./src/ProductFactory.ts");
function isShelfData(data) {
    return (typeof data === 'object' &&
        isShelfProductsData(data.products) &&
        (data.offset === undefined || (0, utilities_1.isVec2)(data.offset)) &&
        (data.slotCount === undefined || typeof data.slotCount === 'number') &&
        (data.matchCount === undefined || typeof data.matchCount === 'number') &&
        (data.ignore === undefined || typeof data.ignore === 'boolean') &&
        (data.reference === undefined || typeof data.reference === 'string'));
}
exports.isShelfData = isShelfData;
function isShelfProductsData(data) {
    return (Array.isArray(data) &&
        data.every(product => typeof product === 'string' || product === null));
}
exports.isShelfProductsData = isShelfProductsData;
class Shelf extends _1.Actor {
    constructor(level, products, offset = (0, vec_1.vec2)(), slotCount = Shelf.DEFAULT_SLOT_COUNT, matchCount = Shelf.DEFAULT_MATCH_COUNT, ignore = false, reference, addToLevel = true) {
        super(level);
        this.products = products;
        this.offset = offset;
        this.slotCount = slotCount;
        this.matchCount = matchCount;
        this.ignore = ignore;
        this.reference = reference;
        this.statsUpdated = false;
        if (addToLevel) {
            level.shelves.push(this);
        }
    }
    static fromData(level, data) {
        if (!isShelfData(data)) {
            throw new Error('Invalid shelf data');
        }
        const products = data.products.map(productId => productId !== null ? ProductFactory_1.ProductFactory.createProduct(level, productId) : null);
        return new Shelf(level, products, data.offset || (0, vec_1.vec2)(), data.slotCount || Shelf.DEFAULT_SLOT_COUNT, data.matchCount || Shelf.DEFAULT_MATCH_COUNT, data.ignore || false, data.reference || undefined);
    }
    calculateSize() {
        const productSize = _1.Product.calculateSize();
        const size = (0, vec_1.vec2)();
        size.x = productSize.x * this.slotCount;
        size.y = productSize.y;
        return size;
    }
    update(dt, level, camera) {
        this.products.forEach((product, index) => {
            product === null || product === void 0 ? void 0 : product.update(dt, level, camera, this, index);
        });
        this.products = this.products.map(product => {
            if (product && product.finishedDisappearing) {
                return null;
            }
            return product;
        });
        const match = this.checkForMatches();
        if (match.found) {
            match.matches.forEach((product, index) => {
                if (product) {
                    product.disappear(index * Shelf.DISAPPEAR_DELAY);
                }
            });
        }
        if (!this.statsUpdated) {
            if (match.found) {
                match.matches.forEach(product => {
                    if (product) {
                        level.stats.productMatches[product.id].total++;
                        level.stats.totalMatches++;
                    }
                });
                this.statsUpdated = true;
            }
            if (this.shelfIsComplete()) {
                level.stats.totalCompletedShelves++;
                this.statsUpdated = true;
            }
        }
    }
    findShelfSlot(product) {
        const aabb = product.getAABB();
        const shelfSlots = (0, utils_1.times)(index => ({
            index,
            aabb: this.getAABB(index),
        }), this.slotCount)
            .filter(slot => this.canDropProductAtIndex(product, slot.index))
            .filter(slot => (0, _2d_1.aabbsOverlap)(aabb, slot.aabb).intersects)
            .map(slot => ({
            ...slot,
            distance: (0, _2d_1.distance)(vec_1.vec2.add(slot.aabb.position, vec_1.vec2.div(slot.aabb.size, 2)), vec_1.vec2.add(aabb.position, vec_1.vec2.div(aabb.size, 2))),
        }))
            .sort((a, b) => a.distance - b.distance);
        const closestSlot = shelfSlots[0];
        if (closestSlot) {
            return {
                valid: true,
                slotIndex: closestSlot.index,
                product: this.products[closestSlot.index],
                distance: closestSlot.distance,
            };
        }
        return { valid: false };
    }
    canPickUpProductAtIndex(_product, index) {
        if (index < 0 || index >= this.slotCount) {
            return false;
        }
        if (this.products[index] === null) {
            return false;
        }
        return true;
    }
    canDropProductAtIndex(_product, index) {
        if (index < 0 || index >= this.slotCount) {
            return false;
        }
        if (this.products[index] !== null) {
            return false;
        }
        return true;
    }
    shelfIsEmpty() {
        return this.products.every(product => product === null);
    }
    shelfIsComplete() {
        return this.shelfIsEmpty();
    }
    checkForMatches() {
        const validProducts = this.products.filter(product => product !== null && !product.disappearing);
        const allMatches = this.findMatchingGroups(validProducts);
        return {
            found: allMatches.length > 0,
            matches: allMatches[0],
        };
    }
    findMatchingGroups(products) {
        const matches = [];
        for (let i = 0; i < products.length; i++) {
            const startProduct = products[i];
            const group = this.growMatchingGroup([startProduct], products);
            if (group.length >= this.matchCount) {
                matches.push(group.slice(0, this.matchCount));
            }
        }
        return matches;
    }
    growMatchingGroup(currentGroup, availableProducts) {
        if (currentGroup.length >= this.matchCount) {
            return currentGroup;
        }
        const matchingProducts = availableProducts.filter(product => !currentGroup.includes(product) &&
            currentGroup.every(groupProduct => product.matchesProduct(groupProduct)));
        if (matchingProducts.length === 0) {
            return currentGroup;
        }
        return this.growMatchingGroup([...currentGroup, matchingProducts[0]], availableProducts);
    }
    getAABB(index) {
        if (index === undefined) {
            return {
                position: this.position,
                size: this.calculateSize(),
            };
        }
        const productSize = _1.Product.calculateSize();
        return {
            position: vec_1.vec2.add(this.position, (0, vec_1.vec2)(productSize.x * index, 0)),
            size: productSize,
        };
    }
    addProductAtIndex(index, product) {
        if (index < 0 || index >= this.slotCount) {
            return false;
        }
        if (this.products[index] !== null) {
            return false;
        }
        this.products[index] = product;
        this.statsUpdated = false;
        return true;
    }
    removeProductAtIndex(index) {
        if (index < 0 || index >= this.slotCount) {
            return null;
        }
        const product = this.products[index];
        this.products[index] = null;
        this.statsUpdated = false;
        return product;
    }
    lockProductAtIndex(index, locked = true) {
        if (index < 0 || index >= this.slotCount) {
            return null;
        }
        const product = this.products[index];
        if (product === null) {
            return null;
        }
        product.locked = locked;
        return product.locked;
    }
    draw(context, drawProducts = true) {
        context.save();
        (0, canvas_helpers_1.rectangle)(context, this.position, this.calculateSize(), Shelf.STYLE);
        if (drawProducts) {
            this.products.forEach(product => {
                if (product === null) {
                    return;
                }
                if (product.dragging) {
                    return;
                }
                product.draw(context);
            });
        }
        context.restore();
    }
}
exports.Shelf = Shelf;
Shelf.DEFAULT_SLOT_COUNT = 3;
Shelf.DEFAULT_MATCH_COUNT = 3;
Shelf.DISAPPEAR_DELAY = 0.2;
Shelf.STYLE = {
    strokeColor: 'white',
    lineWidth: 4,
    stroke: true,
    fill: false,
};


/***/ }),

/***/ "./src/actors/SupplyShelf.ts":
/*!***********************************!*\
  !*** ./src/actors/SupplyShelf.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SupplyShelf = exports.isSupplyShelfData = void 0;
const utilities_1 = __webpack_require__(/*! @basementuniverse/intersection-helpers/utilities */ "./node_modules/@basementuniverse/intersection-helpers/build/utilities/index.js");
const vec_1 = __webpack_require__(/*! @basementuniverse/vec */ "./node_modules/@basementuniverse/vec/vec.js");
const _1 = __webpack_require__(/*! . */ "./src/actors/index.ts");
const ShelfFactory_1 = __webpack_require__(/*! ../ShelfFactory */ "./src/ShelfFactory.ts");
function isSupplyShelfData(data) {
    return (typeof data === 'object' &&
        (0, ShelfFactory_1.isAbstractShelfData)(data.shelf, [
            'shelf',
            'deep-shelf',
            'disappearing-shelf',
            'locking-shelf',
        ]) &&
        (data.offset === undefined || (0, utilities_1.isVec2)(data.offset)));
}
exports.isSupplyShelfData = isSupplyShelfData;
class SupplyShelf extends _1.Shelf {
    constructor(level, shelf, offset = (0, vec_1.vec2)()) {
        shelf.canDropProductAtIndex = (_product, _index) => false;
        super(level, [], offset, undefined, undefined, true, undefined, false);
        this.shelf = shelf;
        this.offset = offset;
    }
    static fromData(level, data) {
        if (!isSupplyShelfData(data)) {
            throw new Error('Invalid supply shelf data');
        }
        const shelf = ShelfFactory_1.ShelfFactory.createShelf(level, data.shelf);
        return new SupplyShelf(level, shelf, data.offset || (0, vec_1.vec2)());
    }
    update(dt, level, camera) {
        this.shelf.position = this.position;
        this.shelf.update(dt, level, camera);
    }
    findShelfSlot(_product) {
        return { valid: false };
    }
    canPickUpProductAtIndex(_product, _index) {
        return false;
    }
    canDropProductAtIndex(_product, _index) {
        return false;
    }
    shelfIsEmpty() {
        return true;
    }
    shelfIsComplete() {
        return this.shelf.shelfIsComplete();
    }
    getAABB(index) {
        return this.shelf.getAABB(index);
    }
    draw(context) {
        this.shelf.draw(context);
    }
}
exports.SupplyShelf = SupplyShelf;


/***/ }),

/***/ "./src/actors/index.ts":
/*!*****************************!*\
  !*** ./src/actors/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Actor */ "./src/actors/Actor.ts"), exports);
__exportStar(__webpack_require__(/*! ./Carousel */ "./src/actors/Carousel.ts"), exports);
__exportStar(__webpack_require__(/*! ./ClosingShelf */ "./src/actors/ClosingShelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./Collapse */ "./src/actors/Collapse.ts"), exports);
__exportStar(__webpack_require__(/*! ./DeepShelf */ "./src/actors/DeepShelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./DisappearingShelf */ "./src/actors/DisappearingShelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./DisplayShelf */ "./src/actors/DisplayShelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./LockingShelf */ "./src/actors/LockingShelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./Product */ "./src/actors/Product.ts"), exports);
__exportStar(__webpack_require__(/*! ./Shelf */ "./src/actors/Shelf.ts"), exports);
__exportStar(__webpack_require__(/*! ./SupplyShelf */ "./src/actors/SupplyShelf.ts"), exports);


/***/ }),

/***/ "./src/config.json":
/*!*************************!*\
  !*** ./src/config.json ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"title":"KataSort Prototype","showFPS":true}');

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FPS_MIN = exports.SIMULATE_SLOW_LOADING = exports.DEBUG = void 0;
exports.DEBUG = true;
exports.SIMULATE_SLOW_LOADING = false;
exports.FPS_MIN = 1 / 30;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Game_1 = __importDefault(__webpack_require__(/*! ./Game */ "./src/Game.ts"));
window.onload = () => {
    const game = new Game_1.default(document.querySelector('#game'));
    game.initialise();
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixnQkFBZ0Isb0RBQW9EO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlEQUFpRDtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSxzR0FBc0c7QUFDaEsscUJBQXFC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YUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3BCLENBQUMsQ0FBQzs7Ozs7OztVQ0xGO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7VUV0QkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvYnVpbGQvMmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvYnVpbGQvdXRpbGl0aWVzL2luZGV4LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3NjZW5lLW1hbmFnZXIvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL21heC5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvbWQ1LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci9uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL25pbC5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3JlZ2V4LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci9ybmcuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3NoYTEuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjEuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3YxVG9WNi5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjMuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3Y1LmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci92Ni5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdjZUb1YxLmpzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9janMtYnJvd3Nlci92Ny5qcyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvY2pzLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2Nqcy1icm93c2VyL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvR2FtZS50cyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL3NyYy9HYW1lU2NlbmUudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvTGV2ZWwudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvTG9hZGluZ1NjZW5lLnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL1Byb2R1Y3RGYWN0b3J5LnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL1NoZWxmRmFjdG9yeS50cyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL3NyYy9hY3RvcnMvQWN0b3IudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvYWN0b3JzL0Nhcm91c2VsLnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL2FjdG9ycy9DbG9zaW5nU2hlbGYudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvYWN0b3JzL0NvbGxhcHNlLnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL2FjdG9ycy9EZWVwU2hlbGYudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvYWN0b3JzL0Rpc2FwcGVhcmluZ1NoZWxmLnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL2FjdG9ycy9EaXNwbGF5U2hlbGYudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvYWN0b3JzL0xvY2tpbmdTaGVsZi50cyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL3NyYy9hY3RvcnMvUHJvZHVjdC50cyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL3NyYy9hY3RvcnMvU2hlbGYudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvYWN0b3JzL1N1cHBseVNoZWxmLnRzIiwid2VicGFjazovL2dvb2RzLXNvcnQtcHJvdG90eXBlLy4vc3JjL2FjdG9ycy9pbmRleC50cyIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS8uL3NyYy9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9nb29kcy1zb3J0LXByb3RvdHlwZS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vZ29vZHMtc29ydC1wcm90b3R5cGUvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICovXFxuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xcblxcbi8qKlxcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcXG4gKi9cXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBpbnRlcnBvbGF0aW9uQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtpbnRlcnBvbGF0aW9uQ2FsbGJhY2t9IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbiA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayB0aW1lc0NhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7dGltZXNDYWxsYmFja30gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIDIgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xcblxcbi8qKlxcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgbGVycCxcXG4gICAgdW5sZXJwLFxcbiAgICBibGVycCxcXG4gICAgcmVtYXAsXFxuICAgIHNtb290aHN0ZXAsXFxuICAgIHJhZGlhbnMsXFxuICAgIGRlZ3JlZXMsXFxuICAgIHJhbmRvbUJldHdlZW4sXFxuICAgIHJhbmRvbUludEJldHdlZW4sXFxuICAgIGNsdFJhbmRvbSxcXG4gICAgY2x0UmFuZG9tSW50LFxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcXG4gICAgbGVycEFycmF5LFxcbiAgICBkb3QsXFxuICAgIGZhY3RvcmlhbCxcXG4gICAgcGVybXV0YXRpb24sXFxuICAgIGNvbWJpbmF0aW9uLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIGNodW5rLFxcbiAgICBzaHVmZmxlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcImNvbnN0IHsgdGltZXMsIGNodW5rLCBkb3QgfSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG5mdW5jdGlvbiBjbGFtcChhLCBtaW4gPSAwLCBtYXggPSAxKSB7XFxuICAgIHJldHVybiBhIDwgbWluID8gbWluIDogKGEgPiBtYXggPyBtYXggOiBhKTtcXG59XFxuY2xhc3MgQ2FtZXJhIHtcXG4gICAgY29uc3RydWN0b3IocG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuc2l6ZSA9ICgwLCB2ZWNfMS52ZWMpKCk7XFxuICAgICAgICB0aGlzLl9hY3R1YWxQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKCk7XFxuICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIHRoaXMuX2FjdHVhbFNjYWxlID0gMTtcXG4gICAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAxO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIENhbWVyYS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICB9XFxuICAgIGdldCBwb3NpdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldFBvc2l0aW9uO1xcbiAgICB9XFxuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xcbiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHZhbHVlO1xcbiAgICB9XFxuICAgIHNldCBwb3NpdGlvbkltbWVkaWF0ZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgICAgIHRoaXMudGFyZ2V0UG9zaXRpb24gPSB2YWx1ZTtcXG4gICAgfVxcbiAgICBnZXQgYWN0dWFsUG9zaXRpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsUG9zaXRpb247XFxuICAgIH1cXG4gICAgZ2V0IHNjYWxlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0U2NhbGU7XFxuICAgIH1cXG4gICAgZ2V0IGFjdHVhbFNjYWxlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbFNjYWxlO1xcbiAgICB9XFxuICAgIHNldCBzY2FsZSh2YWx1ZSkge1xcbiAgICAgICAgdGhpcy50YXJnZXRTY2FsZSA9IGNsYW1wKHZhbHVlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgIH1cXG4gICAgc2V0IHNjYWxlSW1tZWRpYXRlKHZhbHVlKSB7XFxuICAgICAgICB0aGlzLl9hY3R1YWxTY2FsZSA9IGNsYW1wKHZhbHVlLCB0aGlzLm9wdGlvbnMubWluU2NhbGUsIHRoaXMub3B0aW9ucy5tYXhTY2FsZSk7XFxuICAgICAgICB0aGlzLnRhcmdldFNjYWxlID0gdGhpcy5fYWN0dWFsU2NhbGU7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCBzY3JlZW4gYm91bmRzIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNhbWVyYSBwb3NpdGlvbiBhbmQgc2NhbGVcXG4gICAgICovXFxuICAgIGdldCBib3VuZHMoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHRvcDogdGhpcy5fYWN0dWFsUG9zaXRpb24ueSAtICh0aGlzLnNpemUueSAvIDIpIC8gdGhpcy5fYWN0dWFsU2NhbGUsXFxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLl9hY3R1YWxQb3NpdGlvbi55ICsgKHRoaXMuc2l6ZS55IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLl9hY3R1YWxQb3NpdGlvbi54IC0gKHRoaXMuc2l6ZS54IC8gMikgLyB0aGlzLl9hY3R1YWxTY2FsZSxcXG4gICAgICAgICAgICByaWdodDogdGhpcy5fYWN0dWFsUG9zaXRpb24ueCArICh0aGlzLnNpemUueCAvIDIpIC8gdGhpcy5fYWN0dWFsU2NhbGVcXG4gICAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnQgYSBzY3JlZW4gcG9zaXRpb24gdG8gYSB3b3JsZCBwb3NpdGlvblxcbiAgICAgKi9cXG4gICAgc2NyZWVuVG9Xb3JsZChwb3NpdGlvbikge1xcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5ib3VuZHM7XFxuICAgICAgICByZXR1cm4gdmVjXzEudmVjLmFkZCh7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMudG9wIH0sIHZlY18xLnZlYy5tdWwocG9zaXRpb24sIDEgLyB0aGlzLmFjdHVhbFNjYWxlKSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENvbnZlcnQgYSB3b3JsZCBwb3NpdGlvbiB0byBhIHNjcmVlbiBwb3NpdGlvblxcbiAgICAgKi9cXG4gICAgd29ybGRUb1NjcmVlbihwb3NpdGlvbikge1xcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5ib3VuZHM7XFxuICAgICAgICByZXR1cm4gdmVjXzEudmVjLm11bCh2ZWNfMS52ZWMuc3ViKHBvc2l0aW9uLCB7IHg6IGJvdW5kcy5sZWZ0LCB5OiBib3VuZHMudG9wIH0pLCB0aGlzLmFjdHVhbFNjYWxlKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVXBkYXRlIHRoZSBjYW1lcmFcXG4gICAgICovXFxuICAgIHVwZGF0ZShzY3JlZW4pIHtcXG4gICAgICAgIHRoaXMuc2l6ZSA9ICgwLCB2ZWNfMS52ZWMpKHNjcmVlbik7XFxuICAgICAgICAvLyBNYXliZSBjbGFtcCBwb3NpdGlvbiB0byBib3VuZHNcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzKSB7XFxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuU2NhbGVkID0gdmVjXzEudmVjLm1hcCh2ZWNfMS52ZWMubXVsKHRoaXMuc2l6ZSwgMSAvIHRoaXMuX2FjdHVhbFNjYWxlKSwgTWF0aC5jZWlsKTtcXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2NhbGVkIHNjcmVlbiBzaXplIGlzIGxhcmdlciB0aGFuIGFsbG93ZWQgYm91bmRzLCB3ZSByZXNpemVcXG4gICAgICAgICAgICAvLyB0aGUgYm91bmRzIHRvIHByZXZlbnQgaml0dGVyaW5nXFxuICAgICAgICAgICAgY29uc3QgYWN0dWFsQm91bmRzID0ge1xcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuYm91bmRzLFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgaWYgKHNjcmVlblNjYWxlZC54ID4gYWN0dWFsQm91bmRzLnJpZ2h0IC0gYWN0dWFsQm91bmRzLmxlZnQpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzV2lkdGggPSBhY3R1YWxCb3VuZHMucmlnaHQgLSBhY3R1YWxCb3VuZHMubGVmdDtcXG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZkRpZmYgPSAoc2NyZWVuU2NhbGVkLnggLSBib3VuZHNXaWR0aCkgLyAyO1xcbiAgICAgICAgICAgICAgICBhY3R1YWxCb3VuZHMubGVmdCAtPSBoYWxmRGlmZjtcXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRzLnJpZ2h0ICs9IGhhbGZEaWZmO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoc2NyZWVuU2NhbGVkLnkgPiBhY3R1YWxCb3VuZHMuYm90dG9tIC0gYWN0dWFsQm91bmRzLnRvcCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBhY3R1YWxCb3VuZHMuYm90dG9tIC0gYWN0dWFsQm91bmRzLnRvcDtcXG4gICAgICAgICAgICAgICAgY29uc3QgaGFsZkRpZmYgPSAoc2NyZWVuU2NhbGVkLnkgLSBib3VuZHNIZWlnaHQpIC8gMjtcXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRzLnRvcCAtPSBoYWxmRGlmZjtcXG4gICAgICAgICAgICAgICAgYWN0dWFsQm91bmRzLmJvdHRvbSArPSBoYWxmRGlmZjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29uc3QgaGFsZlNjcmVlblNjYWxlZCA9IHZlY18xLnZlYy5tYXAodmVjXzEudmVjLm11bChzY3JlZW5TY2FsZWQsIDEgLyAyKSwgTWF0aC5jZWlsKTtcXG4gICAgICAgICAgICBjb25zdCBtaW5Qb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGFjdHVhbEJvdW5kcy5sZWZ0ICsgaGFsZlNjcmVlblNjYWxlZC54LCBhY3R1YWxCb3VuZHMudG9wICsgaGFsZlNjcmVlblNjYWxlZC55KTtcXG4gICAgICAgICAgICBjb25zdCBtYXhQb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGFjdHVhbEJvdW5kcy5yaWdodCAtIGhhbGZTY3JlZW5TY2FsZWQueCwgYWN0dWFsQm91bmRzLmJvdHRvbSAtIGhhbGZTY3JlZW5TY2FsZWQueSk7XFxuICAgICAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbi54ID0gY2xhbXAodGhpcy50YXJnZXRQb3NpdGlvbi54LCBtaW5Qb3NpdGlvbi54LCBtYXhQb3NpdGlvbi54KTtcXG4gICAgICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnkgPSBjbGFtcCh0aGlzLnRhcmdldFBvc2l0aW9uLnksIG1pblBvc2l0aW9uLnksIG1heFBvc2l0aW9uLnkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgZCA9IHZlY18xLnZlYy5zdWIodGhpcy5fYWN0dWFsUG9zaXRpb24sIHRoaXMudGFyZ2V0UG9zaXRpb24pO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsUG9zaXRpb24gPSB2ZWNfMS52ZWMuYWRkKHRoaXMucG9zaXRpb24sIHZlY18xLnZlYy5tdWwoZCwgdGhpcy5vcHRpb25zLm1vdmVFYXNlQW1vdW50KSk7XFxuICAgICAgICBjb25zdCBzID0gY2xhbXAodGhpcy50YXJnZXRTY2FsZSwgdGhpcy5vcHRpb25zLm1pblNjYWxlLCB0aGlzLm9wdGlvbnMubWF4U2NhbGUpO1xcbiAgICAgICAgdGhpcy5fYWN0dWFsU2NhbGUgPSBzICsgKHRoaXMuX2FjdHVhbFNjYWxlIC0gcykgKiB0aGlzLm9wdGlvbnMuc2NhbGVFYXNlQW1vdW50O1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTZXQgdGhlIGNhbWVyYSB0cmFuc2Zvcm1zIG9uIGEgY2FudmFzIGNvbnRleHRcXG4gICAgICovXFxuICAgIHNldFRyYW5zZm9ybXMoY29udGV4dCkge1xcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XFxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgodGhpcy5zaXplLnggLyAyKSAtIHRoaXMuX2FjdHVhbFBvc2l0aW9uLnggKiB0aGlzLl9hY3R1YWxTY2FsZSwgKHRoaXMuc2l6ZS55IC8gMikgLSB0aGlzLl9hY3R1YWxQb3NpdGlvbi55ICogdGhpcy5fYWN0dWFsU2NhbGUpO1xcbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLl9hY3R1YWxTY2FsZSwgdGhpcy5fYWN0dWFsU2NhbGUpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIGNhbWVyYSBhbmQgdGhlbiBzZXQgdHJhbnNmb3JtcyBvbiBhIGNhbnZhcyBjb250ZXh0XFxuICAgICAqL1xcbiAgICBkcmF3KGNvbnRleHQsIHNjcmVlbikge1xcbiAgICAgICAgdGhpcy51cGRhdGUoc2NyZWVuKTtcXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3Jtcyhjb250ZXh0KTtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBDYW1lcmE7XFxuQ2FtZXJhLmRlZmF1bHRPcHRpb25zID0ge1xcbiAgICBhbGxvd1NjYWxlOiB0cnVlLFxcbiAgICBtaW5TY2FsZTogMC41LFxcbiAgICBtYXhTY2FsZTogNCxcXG4gICAgbW92ZUVhc2VBbW91bnQ6IDAuMSxcXG4gICAgc2NhbGVFYXNlQW1vdW50OiAwLjEsXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEvLi9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBjYW4ndCBiZSBpbmxpbmVkIGJlY2F1c2UgdGhlIGV2YWwgZGV2dG9vbCBpcyB1c2VkLlxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2luZGV4LnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiLCIvKlxuICogQVRURU5USU9OOiBUaGUgXCJldmFsXCIgZGV2dG9vbCBoYXMgYmVlbiB1c2VkIChtYXliZSBieSBkZWZhdWx0IGluIG1vZGU6IFwiZGV2ZWxvcG1lbnRcIikuXG4gKiBUaGlzIGRldnRvb2wgaXMgbmVpdGhlciBtYWRlIGZvciBwcm9kdWN0aW9uIG5vciBmb3IgcmVhZGFibGUgb3V0cHV0IGZpbGVzLlxuICogSXQgdXNlcyBcImV2YWwoKVwiIGNhbGxzIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHNvdXJjZSBmaWxlIGluIHRoZSBicm93c2VyIGRldnRvb2xzLlxuICogSWYgeW91IGFyZSB0cnlpbmcgdG8gcmVhZCB0aGUgb3V0cHV0IGZpbGUsIHNlbGVjdCBhIGRpZmZlcmVudCBkZXZ0b29sIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vZGV2dG9vbC8pXG4gKiBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IGRldnRvb2wgd2l0aCBcImRldnRvb2w6IGZhbHNlXCIuXG4gKiBJZiB5b3UgYXJlIGxvb2tpbmcgZm9yIHByb2R1Y3Rpb24tcmVhZHkgb3V0cHV0IGZpbGVzLCBzZWUgbW9kZTogXCJwcm9kdWN0aW9uXCIgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9tb2RlLykuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwiLyoqXFxuICogQG92ZXJ2aWV3IEEgbGlicmFyeSBvZiB1c2VmdWwgZnVuY3Rpb25zXFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG4vKipcXG4gKiBNZW1vaXplIGEgZnVuY3Rpb25cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG1lbW9pemVkIHZlcnNpb24gb2YgdGhlIGZ1bmN0aW9uXFxuICovXFxuY29uc3QgbWVtb2l6ZSA9IGYgPT4ge1xcbiAgdmFyIGNhY2hlID0ge307XFxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xcbiAgICByZXR1cm4gY2FjaGVbYXJnc10gPz8gKGNhY2hlW2FyZ3NdID0gZi5hcHBseSh0aGlzLCBhcmdzKSk7XFxuICB9O1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXIgYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlciBiXFxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBudW1iZXJzIGEgYW5kIGIgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcXG4gKi9cXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XFxuXFxuLyoqXFxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgdG8gY2xhbXBcXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgbnVtYmVyXFxuICovXFxuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBmcmFjdGlvbmFsIHBhcnRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIG51bWJlclxcbiAqL1xcbmNvbnN0IGZyYWMgPSBhID0+IGEgPj0gMCA/IGEgLSBNYXRoLmZsb29yKGEpIDogYSAtIE1hdGguY2VpbChhKTtcXG5cXG4vKipcXG4gKiBSb3VuZCBuIHRvIGQgZGVjaW1hbCBwbGFjZXNcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIHRvIHJvdW5kXFxuICogQHBhcmFtIHtudW1iZXJ9IFtkPTBdIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcm91bmRlZCBudW1iZXJcXG4gKi9cXG5jb25zdCByb3VuZCA9IChuLCBkID0gMCkgPT4ge1xcbiAgY29uc3QgcCA9IE1hdGgucG93KDEwLCBkKTtcXG4gIHJldHVybiBNYXRoLnJvdW5kKG4gKiBwICsgTnVtYmVyLkVQU0lMT04pIC8gcDtcXG59XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBJbnRlcnBvbGF0aW9uRnVuY3Rpb25cXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtJbnRlcnBvbGF0aW9uRnVuY3Rpb259IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBucHIgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gZmFjdG9yaWFsKG4gLSByKTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuQ3JcXG4gKi9cXG5jb25zdCBuY3IgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gKGZhY3RvcmlhbChyKSAqIGZhY3RvcmlhbChuIC0gcikpO1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFsbCBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGFuIGFycmF5XFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogcGVybXV0YXRpb25zKFsxLCAyLCAzXSwgMik7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCAyXSxcXG4gKiAgIFsxLCAzXSxcXG4gKiAgIFsyLCAxXSxcXG4gKiAgIFsyLCAzXSxcXG4gKiAgIFszLCAxXSxcXG4gKiAgIFszLCAyXVxcbiAqIF1cXG4gKiBgYGBcXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBwZXJtdXRhdGlvblxcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gQW4gYXJyYXkgb2YgcGVybXV0YXRpb24gYXJyYXlzXFxuICovXFxuY29uc3QgcGVybXV0YXRpb25zID0gKGEsIHIpID0+IHtcXG4gIGlmIChyID09PSAxKSB7XFxuICAgIHJldHVybiBhLm1hcChpdGVtID0+IFtpdGVtXSk7XFxuICB9XFxuXFxuICByZXR1cm4gYS5yZWR1Y2UoXFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcXG4gICAgICAuLi5hY2MsXFxuICAgICAgLi4ucGVybXV0YXRpb25zKGEuc2xpY2UoMCwgaSkuY29uY2F0KGEuc2xpY2UoaSArIDEpKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXFxuICAgIF0sXFxuICAgIFtdXFxuICApO1xcbn1cXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbGwgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxcbiAqXFxuICogQGV4YW1wbGVcXG4gKiBgYGBqc1xcbiAqIGNvbWJpbmF0aW9ucyhbMSwgMiwgM10sIDIpO1xcbiAqIGBgYFxcbiAqXFxuICogT3V0cHV0OlxcbiAqIGBgYGpzb25cXG4gKiBbXFxuICogICBbMSwgMl0sXFxuICogICBbMSwgM10sXFxuICogICBbMiwgM11cXG4gKiBdXFxuICogYGBgXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY2hvb3NlIGluIGVhY2ggY29tYmluYXRpb25cXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGNvbWJpbmF0aW9uIGFycmF5c1xcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9ucyA9IChhLCByKSA9PiB7XFxuICBpZiAociA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xcbiAgfVxcblxcbiAgcmV0dXJuIGEucmVkdWNlKFxcbiAgICAoYWNjLCBpdGVtLCBpKSA9PiBbXFxuICAgICAgLi4uYWNjLFxcbiAgICAgIC4uLmNvbWJpbmF0aW9ucyhhLnNsaWNlKGkgKyAxKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXFxuICAgIF0sXFxuICAgIFtdXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgY2FydGVzaWFuIHByb2R1Y3Qgb2YgYXJyYXlzXFxuICpcXG4gKiBAZXhhbXBsZVxcbiAqIGBgYGpzXFxuICogY2FydGVzaWFuKFsxLCAyLCAzXSwgWydhJywgJ2InXSk7XFxuICogYGBgXFxuICpcXG4gKiBPdXRwdXQ6XFxuICogYGBganNvblxcbiAqIFtcXG4gKiAgIFsxLCBcXFwiYVxcXCJdLFxcbiAqICAgWzEsIFxcXCJiXFxcIl0sXFxuICogICBbMiwgXFxcImFcXFwiXSxcXG4gKiAgIFsyLCBcXFwiYlxcXCJdLFxcbiAqICAgWzMsIFxcXCJhXFxcIl0sXFxuICogICBbMywgXFxcImJcXFwiXVxcbiAqIF1cXG4gKiBgYGBcXG4gKi9cXG5jb25zdCBjYXJ0ZXNpYW4gPSAoLi4uYXJyKSA9PlxcbiAgYXJyLnJlZHVjZShcXG4gICAgKGEsIGIpID0+IGEuZmxhdE1hcChjID0+IGIubWFwKGQgPT4gWy4uLmMsIGRdKSksXFxuICAgIFtbXV1cXG4gICk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhcnJheSB2YWx1ZXNcXG4gKiBAY2FsbGJhY2sgVGltZXNGdW5jdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBhcnJheSBpbmRleFxcbiAqIEByZXR1cm4geyp9IFRoZSBhcnJheSB2YWx1ZVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhIG5ldyBhcnJheSB3aXRoIGxlbmd0aCBuIGJ5IGNhbGxpbmcgZnVuY3Rpb24gZihpKSBvbiBlYWNoIGVsZW1lbnRcXG4gKiBAcGFyYW0ge1RpbWVzRnVuY3Rpb259IGZcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTwqPn1cXG4gKi9cXG5jb25zdCB0aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyAwLT4obiAtIDEpXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIGFycmF5XFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW4gYXJyYXkgb2YgaW50ZWdlcnMgMC0+KG4gLSAxKVxcbiAqL1xcbmNvbnN0IHJhbmdlID0gbiA9PiB0aW1lcyhpID0+IGksIG4pO1xcblxcbi8qKlxcbiAqIFppcCBtdWx0aXBsZSBhcnJheXMgdG9nZXRoZXIsIGkuZS4gKFsxLCAyLCAzXSwgW2EsIGIsIGNdKSA9PiBbWzEsIGFdLCBbMiwgYl0sIFszLCBjXV1cXG4gKiBAcGFyYW0gey4uLkFycmF5PCo+fSBhIFRoZSBhcnJheXMgdG8gemlwXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fVxcbiAqL1xcbmNvbnN0IHppcCA9ICguLi5hKSA9PiB0aW1lcyhpID0+IGEubWFwKGEgPT4gYVtpXSksIE1hdGgubWF4KC4uLmEubWFwKGEgPT4gYS5sZW5ndGgpKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGFycmF5W2ldIHdpdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHdyYXBwaW5nXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYSBUaGUgYXJyYXkgdG8gYWNjZXNzXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHBvc2l0aXZlbHkvbmVnYXRpdmVseSB3cmFwcGVkIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gQW4gZWxlbWVudCBmcm9tIHRoZSBhcnJheVxcbiAqL1xcbmNvbnN0IGF0ID0gKGEsIGkpID0+IGFbaSA8IDAgPyBhLmxlbmd0aCAtIChNYXRoLmFicyhpICsgMSkgJSBhLmxlbmd0aCkgLSAxIDogaSAlIGEubGVuZ3RoXTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSB3aXRob3V0IHJlbW92aW5nIGl0XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4geyp9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcXG4gKi9cXG5jb25zdCBwZWVrID0gKGEpID0+IHtcXG4gIGlmICghYS5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIH1cXG5cXG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIGluZGV4IGZvciBhIGdpdmVuIHBvc2l0aW9uIGluIGFuIHVucm9sbGVkIDJkIGFycmF5XFxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeSBwb3NpdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgMmQgYXJyYXlcXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggaW4gdGhlIHVucm9sbGVkIGFycmF5XFxuICovXFxuY29uc3QgaW5kID0gKHgsIHksIHcpID0+IHggKyB5ICogdztcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHBvc2l0aW9uIGZvciBhIGdpdmVuIGluZGV4IGluIGFuIHVucm9sbGVkIDJkIGFycmF5XFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4XFxuICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSAyZCBhcnJheVxcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgcG9zaXRpb24gYXMgYSAyLXR1cGxlXFxuICovXFxuY29uc3QgcG9zID0gKGksIHcpID0+IFtpICUgdywgTWF0aC5mbG9vcihpIC8gdyldO1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG4vKipcXG4gKiBGbGF0dGVuIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIHVzZSBmb3IgY29uY2F0ZW5hdGluZyBrZXlzXFxuICogQHJldHVybiB7b2JqZWN0fSBBIGZsYXR0ZW5lZCBvYmplY3RcXG4gKi9cXG5jb25zdCBmbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcXG4gICAgaWYgKG9ba2V5XSBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgLi4uYWNjLFxcbiAgICAgICAgW2tleV06IG9ba2V5XS50b0lTT1N0cmluZygpLFxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8ICFvW2tleV0pIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgLi4uYWNjLFxcbiAgICAgICAgW2tleV06IG9ba2V5XSxcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQob1trZXldLCBjb25jYXRlbmF0b3IpO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIC4uLmFjYyxcXG4gICAgICAuLi5PYmplY3Qua2V5cyhmbGF0dGVuZWQpLnJlZHVjZShcXG4gICAgICAgIChjaGlsZEFjYywgY2hpbGRLZXkpID0+ICh7XFxuICAgICAgICAgIC4uLmNoaWxkQWNjLFxcbiAgICAgICAgICBbYCR7a2V5fSR7Y29uY2F0ZW5hdG9yfSR7Y2hpbGRLZXl9YF06IGZsYXR0ZW5lZFtjaGlsZEtleV0sXFxuICAgICAgICB9KSxcXG4gICAgICAgIHt9XFxuICAgICAgKSxcXG4gICAgfTtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIFVuZmxhdHRlbiBhbiBvYmplY3RcXG4gKiBAcGFyYW0ge29iamVjdH0gb1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byBjaGVjayBmb3IgaW4gY29uY2F0ZW5hdGVkIGtleXNcXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIHVuLWZsYXR0ZW5lZCBvYmplY3RcXG4gKi9cXG5jb25zdCB1bmZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XFxuICBsZXQgcmVzdWx0ID0ge30sIHRlbXAsIHN1YnN0cmluZ3MsIHByb3BlcnR5LCBpO1xcblxcbiAgZm9yIChwcm9wZXJ0eSBpbiBvKSB7XFxuICAgIHN1YnN0cmluZ3MgPSBwcm9wZXJ0eS5zcGxpdChjb25jYXRlbmF0b3IpO1xcbiAgICB0ZW1wID0gcmVzdWx0O1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgICBpZiAoIShzdWJzdHJpbmdzW2ldIGluIHRlbXApKSB7XFxuICAgICAgICBpZiAoaXNGaW5pdGUoc3Vic3RyaW5nc1tpICsgMV0pKSB7XFxuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSBbXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdGVtcCA9IHRlbXBbc3Vic3RyaW5nc1tpXV07XFxuICAgIH1cXG4gICAgdGVtcFtzdWJzdHJpbmdzW3N1YnN0cmluZ3MubGVuZ3RoIC0gMV1dID0gb1twcm9wZXJ0eV07XFxuICB9XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogQSBzcGxpdCBwcmVkaWNhdGVcXG4gKiBAY2FsbGJhY2sgU3BsaXRQcmVkaWNhdGVcXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWVcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcnJheSBzaG91bGQgc3BsaXQgYXQgdGhpcyBpbmRleFxcbiAqL1xcblxcbi8qKlxcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gc3ViLWFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFycmF5XFxuICogQHBhcmFtIHtTcGxpdFByZWRpY2F0ZX0gcHJlZGljYXRlXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheXNcXG4gKi9cXG5jb25zdCBzcGxpdCA9IChhcnJheSwgcHJlZGljYXRlKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIGxldCBjdXJyZW50ID0gW107XFxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5KSB7XFxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XFxuICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoKSB7XFxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcXG4gICAgICB9XFxuICAgICAgY3VycmVudCA9IFt2YWx1ZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcbiAgcmVzdWx0LnB1c2goY3VycmVudCk7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogUGx1Y2sga2V5cyBmcm9tIGFuIG9iamVjdFxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGtleXMgVGhlIGtleXMgdG8gcGx1Y2sgZnJvbSB0aGUgb2JqZWN0XFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGx1Y2tlZCBrZXlzXFxuICovXFxuY29uc3QgcGx1Y2sgPSAobywgLi4ua2V5cykgPT4ge1xcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxcbiAgICAocmVzdWx0LCBrZXkpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFtrZXldOiBvW2tleV0gfSksXFxuICAgIHt9XFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogRXhjbHVkZSBrZXlzIGZyb20gYW4gb2JqZWN0XFxuICogQHBhcmFtIHtvYmplY3R9IG9cXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBleGNsdWRlIGZyb20gdGhlIG9iamVjdFxcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGtleXMgZXhjZXB0IGV4Y2x1ZGVkIGtleXNcXG4gKi9cXG5jb25zdCBleGNsdWRlID0gKG8sIC4uLmtleXMpID0+IHtcXG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXFxuICAgIE9iamVjdC5lbnRyaWVzKG8pLmZpbHRlcigoW2tleV0pID0+ICFrZXlzLmluY2x1ZGVzKGtleSkpXFxuICApO1xcbn07XFxuXFxuaWYgKHRydWUpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0ge1xcbiAgICBtZW1vaXplLFxcbiAgICBmbG9hdEVxdWFscyxcXG4gICAgY2xhbXAsXFxuICAgIGZyYWMsXFxuICAgIHJvdW5kLFxcbiAgICBsZXJwLFxcbiAgICB1bmxlcnAsXFxuICAgIGJsZXJwLFxcbiAgICByZW1hcCxcXG4gICAgc21vb3Roc3RlcCxcXG4gICAgcmFkaWFucyxcXG4gICAgZGVncmVlcyxcXG4gICAgcmFuZG9tQmV0d2VlbixcXG4gICAgcmFuZG9tSW50QmV0d2VlbixcXG4gICAgY2x0UmFuZG9tLFxcbiAgICBjbHRSYW5kb21JbnQsXFxuICAgIHdlaWdodGVkUmFuZG9tLFxcbiAgICBsZXJwQXJyYXksXFxuICAgIGRvdCxcXG4gICAgZmFjdG9yaWFsLFxcbiAgICBucHIsXFxuICAgIG5jcixcXG4gICAgcGVybXV0YXRpb25zLFxcbiAgICBjb21iaW5hdGlvbnMsXFxuICAgIGNhcnRlc2lhbixcXG4gICAgdGltZXMsXFxuICAgIHJhbmdlLFxcbiAgICB6aXAsXFxuICAgIGF0LFxcbiAgICBwZWVrLFxcbiAgICBpbmQsXFxuICAgIHBvcyxcXG4gICAgY2h1bmssXFxuICAgIHNodWZmbGUsXFxuICAgIGZsYXQsXFxuICAgIHVuZmxhdCxcXG4gICAgc3BsaXQsXFxuICAgIHBsdWNrLFxcbiAgICBleGNsdWRlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIEBvdmVydmlldyBBIHNtYWxsIHZlY3RvciBhbmQgbWF0cml4IGxpYnJhcnlcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbmNvbnN0IF92ZWNfdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xcbmNvbnN0IF92ZWNfY2h1bmsgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5jb25zdCBfdmVjX2RvdCA9IChhLCBiKSA9PiBhLnJlZHVjZSgobiwgdiwgaSkgPT4gbiArIHYgKiBiW2ldLCAwKTtcXG5jb25zdCBfdmVjX2lzX3ZlYzIgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYTtcXG5jb25zdCBfdmVjX2lzX3ZlYzMgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYSAmJiAneicgaW4gYTtcXG5cXG4vKipcXG4gKiBBIDJkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzJcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IDJkIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyAyZCB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYzIoMywgMik7IC8vICgzLCAyKVxcbiAqIGxldCBiID0gdmVjMig0KTsgICAgLy8gKDQsIDQpXFxuICogbGV0IGMgPSB2ZWMyKGEpOyAgICAvLyAoMywgMilcXG4gKiBsZXQgZCA9IHZlYzIoKTsgICAgIC8vICgwLCAwKVxcbiAqL1xcbmNvbnN0IHZlYzIgPSAoeCwgeSkgPT4ge1xcbiAgaWYgKCF4ICYmICF5KSB7XFxuICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwIH07XFxuICB9XFxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHggfTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcXG4gKi9cXG52ZWMyLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgdmVjdG9yXFxuICovXFxudmVjMi5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMiguLi5jb21wb25lbnRzLnNsaWNlKDAsIDIpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYzIudXggPSAoKSA9PiB2ZWMyKDEsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjMi51eSA9ICgpID0+IHZlYzIoMCwgMSk7XFxuXFxuLyoqXFxuICogQWRkIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKyBiXFxuICovXFxudmVjMi5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC0gYlxcbiAqL1xcbnZlYzIuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogU2NhbGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXFxuICovXFxudmVjMi5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzIubXVsXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxcbiAqL1xcbnZlYzIuc2NhbGUgPSAoYSwgYikgPT4gdmVjMi5tdWwoYSwgYik7XFxuXFxuLyoqXFxuICogRGl2aWRlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC8gYlxcbiAqL1xcbnZlYzIuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYikgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzIubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMyLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjMn0gXmFcXG4gKi9cXG52ZWMyLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYzIubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYzIoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMyLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFuc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjMi5yb3QgPSAoYSwgcikgPT4ge1xcbiAgbGV0IHMgPSBNYXRoLnNpbihyKSxcXG4gICAgYyA9IE1hdGguY29zKHIpO1xcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XFxufTtcXG5cXG4vKipcXG4gKiBGYXN0IG1ldGhvZCB0byByb3RhdGUgYSB2ZWN0b3IgYnkgLTkwLCA5MCBvciAxODAgZGVncmVlc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIDEgZm9yIDkwIGRlZ3JlZXMgKGN3KSwgLTEgZm9yIC05MCBkZWdyZWVzIChjY3cpLCAyIG9yIC0yIGZvciAxODAgZGVncmVlc1xcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMyLnJvdGYgPSAoYSwgcikgPT4ge1xcbiAgc3dpdGNoIChyKSB7XFxuICAgIGNhc2UgMTogcmV0dXJuIHZlYzIoYS55LCAtYS54KTtcXG4gICAgY2FzZSAtMTogcmV0dXJuIHZlYzIoLWEueSwgYS54KTtcXG4gICAgY2FzZSAyOiBjYXNlIC0yOiByZXR1cm4gdmVjMigtYS54LCAtYS55KTtcXG4gICAgZGVmYXVsdDogcmV0dXJuIGE7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsYXIgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDDlyBiXFxuICovXFxudmVjMi5jcm9zcyA9IChhLCBiKSA9PiB7XFxuICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMyLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMi5yYWQgPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLngpO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjMn0gQSBjb3B5IG9mIHZlY3RvciBhXFxuICovXFxudmVjMi5jcHkgPSBhID0+IHZlYzIoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgMmQgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlYzJNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXFxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjMk1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMyfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxudmVjMi5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMyLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xcblxcbi8qKlxcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXFxuICpcXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxcbiAqIC0gYHhgIG9yIGB5YFxcbiAqIC0gYHVgIG9yIGB2YCAoYWxpYXNlcyBmb3IgYHhgIGFuZCBgeWAsIHJlc3BlY3RpdmVseSlcXG4gKiAtIGBYYCwgYFlgLCBgVWAsIGBWYCAobmVnYXRlZCB2ZXJzaW9ucyBvZiB0aGUgYWJvdmUpXFxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXFxuICpcXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9Jy4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMyKDMsIC0yKTtcXG4gKiB2ZWMyLnN3aXooYSwgJ3gnKTsgICAgLy8gWzNdXFxuICogdmVjMi5zd2l6KGEsICd5eCcpOyAgIC8vIFstMiwgM11cXG4gKiB2ZWMyLnN3aXooYSwgJ3hZJyk7ICAgLy8gWzMsIDJdXFxuICogdmVjMi5zd2l6KGEsICdZeScpOyAgIC8vIFsyLCAtMl1cXG4gKiB2ZWMyLnN3aXooYSwgJ3gueCcpOyAgLy8gWzMsIC0yLCAzXVxcbiAqIHZlYzIuc3dpeihhLCAneTAxeCcpOyAvLyBbLTIsIDAsIDEsIDNdXFxuICovXFxudmVjMi5zd2l6ID0gKGEsIHMgPSAnLi4nKSA9PiB7XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcXG4gICAgc3dpdGNoIChjKSB7XFxuICAgICAgY2FzZSAneCc6IGNhc2UgJ3UnOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcXG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogcmVzdWx0LnB1c2goLWEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcXG4gICAgICBjYXNlICcuJzogcmVzdWx0LnB1c2goW2EueCwgYS55XVtpXSA/PyAwKTsgYnJlYWs7XFxuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDJkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMyZFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzMmR9IFRoZSBtYWduaXR1ZGUgYW5kIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMyLnBvbGFyID0gYSA9PiAoeyByOiB2ZWMyLmxlbihhKSwgdGhldGE6IE1hdGguYXRhbjIoYS55LCBhLngpIH0pO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcXG4gKi9cXG52ZWMyLmZyb21Qb2xhciA9IChyLCB0aGV0YSkgPT4gdmVjMihyICogTWF0aC5jb3ModGhldGEpLCByICogTWF0aC5zaW4odGhldGEpKTtcXG5cXG4vKipcXG4gKiBBIDNkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzNcXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHogVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgM2QgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjM3x2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciB0aGUgeiBjb21wb25lbnQgaWYgeCBpcyBhIHZlYzJcXG4gKiBAcGFyYW0ge251bWJlcn0gW3pdIFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSBuZXcgM2QgdmVjdG9yXFxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMzKDMsIDIsIDEpOyAgICAgICAvLyAoMywgMiwgMSlcXG4gKiBsZXQgYiA9IHZlYzMoNCwgNSk7ICAgICAgICAgIC8vICg0LCA1LCAwKVxcbiAqIGxldCBjID0gdmVjMyg2KTsgICAgICAgICAgICAgLy8gKDYsIDYsIDYpXFxuICogbGV0IGQgPSB2ZWMzKGEpOyAgICAgICAgICAgICAvLyAoMywgMiwgMSlcXG4gKiBsZXQgZSA9IHZlYzMoKTsgICAgICAgICAgICAgIC8vICgwLCAwLCAwKVxcbiAqIGxldCBmID0gdmVjMyh2ZWMyKDEsIDIpLCAzKTsgLy8gKDEsIDIsIDMpXFxuICogbGV0IGcgPSB2ZWMzKHZlYzIoNCwgNSkpOyAgICAvLyAoNCwgNSwgMClcXG4gKi9cXG5jb25zdCB2ZWMzID0gKHgsIHksIHopID0+IHtcXG4gIGlmICgheCAmJiAheSAmJiAheikge1xcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB6OiAwIH07XFxuICB9XFxuICBpZiAoX3ZlY19pc192ZWMzKHgpKSB7XFxuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeC56IHx8IDAgfTtcXG4gIH1cXG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcXG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB5IHx8IDAgfTtcXG4gIH1cXG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCwgejogeiA/PyB4IH07XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjMy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnksIGEuel07XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjM30gQSBuZXcgdmVjdG9yXFxuICovXFxudmVjMy5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMyguLi5jb21wb25lbnRzLnNsaWNlKDAsIDMpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMCwgMClcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxcbiAqL1xcbnZlYzMudXggPSAoKSA9PiB2ZWMzKDEsIDAsIDApO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXFxuICovXFxudmVjMy51eSA9ICgpID0+IHZlYzMoMCwgMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXFxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMCwgMSlcXG4gKi9cXG52ZWMzLnV6ID0gKCkgPT4gdmVjMygwLCAwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSArIGJcXG4gKi9cXG52ZWMzLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpLCB6OiBhLnogKyAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLSBiXFxuICovXFxudmVjMy5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSwgejogYS56IC0gKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXFxuICogQHJldHVybiB7dmVjM30gYSAqIGJcXG4gKi9cXG52ZWMzLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpLCB6OiBhLnogKiAoYi56ID8/IGIpIH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMy5tdWxcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXFxuICovXFxudmVjMy5zY2FsZSA9IChhLCBiKSA9PiB2ZWMzLm11bChhLCBiKTtcXG5cXG4vKipcXG4gKiBEaXZpZGUgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLyBiXFxuICovXFxudmVjMy5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSwgejogYS56IC8gKGIueiA/PyBiKSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjMy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkgKyBhLnogKiBhLnopO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYzMubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KSArIE1hdGguYWJzKGEueik7XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjM30gXmFcXG4gKi9cXG52ZWMzLm5vciA9IGEgPT4ge1xcbiAgbGV0IGxlbiA9IHZlYzMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4sIHo6IGEueiAvIGxlbiB9IDogdmVjMygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxcbiAqL1xcbnZlYzMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSByb3RhdGlvbiBtYXRyaXhcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge21hdH0gbSBUaGUgcm90YXRpb24gbWF0cml4XFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90ID0gKGEsIG0pID0+IHZlYzMoXFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMSkpLCBhKSxcXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAyKSksIGEpLFxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDMpKSwgYSlcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB4IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eCA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54LFxcbiAgYS55ICogTWF0aC5jb3MocikgLSBhLnogKiBNYXRoLnNpbihyKSxcXG4gIGEueSAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3MocilcXG4pO1xcblxcbi8qKlxcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB5IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYzMucm90eSA9IChhLCByKSA9PiB2ZWMzKFxcbiAgYS54ICogTWF0aC5jb3MocikgKyBhLnogKiBNYXRoLnNpbihyKSxcXG4gIGEueSxcXG4gIC1hLnggKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeiBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHogPSAoYSwgcikgPT4gdmVjMyhcXG4gIGEueCAqIE1hdGguY29zKHIpIC0gYS55ICogTWF0aC5zaW4ociksXFxuICBhLnggKiBNYXRoLnNpbihyKSArIGEueSAqIE1hdGguY29zKHIpLFxcbiAgYS56XFxuKTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSBxdWF0ZXJuaW9uXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxIFRoZSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdHEgPSAodiwgcSkgPT4ge1xcbiAgaWYgKHEubGVuZ3RoICE9PSA0KSB7XFxuICAgIHJldHVybiB2ZWMzKCk7XFxuICB9XFxuXFxuICBjb25zdCBkID0gTWF0aC5zcXJ0KHFbMF0gKiBxWzBdICsgcVsxXSAqIHFbMV0gKyBxWzJdICogcVsyXSArIHFbM10gKiBxWzNdKTtcXG4gIGlmIChkID09PSAwKSB7XFxuICAgIHJldHVybiB2ZWMzKCk7XFxuICB9XFxuXFxuICBjb25zdCB1cSA9IFtxWzBdIC8gZCwgcVsxXSAvIGQsIHFbMl0gLyBkLCBxWzNdIC8gZF07XFxuICBjb25zdCB1ID0gdmVjMyguLi51cS5zbGljZSgwLCAzKSk7XFxuICBjb25zdCBzID0gdXFbM107XFxuICByZXR1cm4gdmVjMy5hZGQoXFxuICAgIHZlYzMuYWRkKFxcbiAgICAgIHZlYzMubXVsKHUsIDIgKiB2ZWMzLmRvdCh1LCB2KSksXFxuICAgICAgdmVjMy5tdWwodiwgcyAqIHMgLSB2ZWMzLmRvdCh1LCB1KSlcXG4gICAgKSxcXG4gICAgdmVjMy5tdWwodmVjMy5jcm9zcyh1LCB2KSwgMiAqIHMpXFxuICApO1xcbn07XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIHVzaW5nIEV1bGVyIGFuZ2xlc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxcbiAqIEBwYXJhbSB7dmVjM30gZSBUaGUgRXVsZXIgYW5nbGVzIHRvIHJvdGF0ZSBieVxcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcXG4gKi9cXG52ZWMzLnJvdGEgPSAoYSwgZSkgPT4gdmVjMy5yb3R6KHZlYzMucm90eSh2ZWMzLnJvdHgoYSwgZS54KSwgZS55KSwgZS56KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlYzN9IGEgw5cgYlxcbiAqL1xcbnZlYzMuY3Jvc3MgPSAoYSwgYikgPT4gdmVjMyhcXG4gIGEueSAqIGIueiAtIGEueiAqIGIueSxcXG4gIGEueiAqIGIueCAtIGEueCAqIGIueixcXG4gIGEueCAqIGIueSAtIGEueSAqIGIueFxcbik7XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcXG4gKi9cXG52ZWMzLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEueiA9PT0gYi56O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeCBheGlzXFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xcbiAqL1xcbnZlYzMucmFkeCA9IGEgPT4gTWF0aC5hdGFuMihhLnosIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB5IGF4aXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjMy5yYWR5ID0gYSA9PiBNYXRoLmF0YW4yKGEueCwgYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHogYXhpc1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMzLnJhZHogPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLnopO1xcblxcbi8qKlxcbiAqIENvcHkgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjM30gQSBjb3B5IG9mIHZlY3RvciBhXFxuICovXFxudmVjMy5jcHkgPSBhID0+IHZlYzMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgM2QgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlYzNNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXFxuICogQHBhcmFtIHsneCcgfCAneScgfCAneid9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHgsIHkgb3IgeilcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjM01hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxudmVjMy5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpLCB6OiBmKGEueiwgJ3onKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjMy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9JHtzfSR7YS56fWA7XFxuXFxuLyoqXFxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcXG4gKlxcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XFxuICogLSBgeGAsIGB5YCBvciBgemBcXG4gKiAtIGB1YCwgYHZgIG9yIGB3YCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxcbiAqIC0gYHJgLCBgZ2Agb3IgYGJgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXFxuICogLSBgWGAsIGBZYCwgYFpgLCBgVWAsIGBWYCwgYFdgLCBgUmAsIGBHYCwgYEJgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcXG4gKiAtIGAwYCBvciBgMWAgKHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdW5jaGFuZ2VkKVxcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcXG4gKlxcbiAqIEFueSBvdGhlciBjaGFyYWN0ZXJzIHdpbGwgZGVmYXVsdCB0byAwXFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XFxuICogbGV0IGEgPSB2ZWMzKDMsIC0yLCAxKTtcXG4gKiB2ZWMzLnN3aXooYSwgJ3gnKTsgICAgIC8vIFszXVxcbiAqIHZlYzMuc3dpeihhLCAnenl4Jyk7ICAgLy8gWzEsIC0yLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneFlaJyk7ICAgLy8gWzMsIDIsIC0xXVxcbiAqIHZlYzMuc3dpeihhLCAnWnp4Jyk7ICAgLy8gWy0xLCAxLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneC54Jyk7ICAgLy8gWzMsIC0yLCAzXVxcbiAqIHZlYzMuc3dpeihhLCAneTAxengnKTsgLy8gWy0yLCAwLCAxLCAxLCAzXVxcbiAqL1xcbnZlYzMuc3dpeiA9IChhLCBzID0gJy4uLicpID0+IHtcXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xcbiAgcy5zcGxpdCgnJykuZm9yRWFjaCgoYywgaSkgPT4ge1xcbiAgICBzd2l0Y2ggKGMpIHtcXG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IGNhc2UgJ3InOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcXG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IGNhc2UgJ2cnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcXG4gICAgICBjYXNlICd6JzogY2FzZSAndyc6IGNhc2UgJ2InOiByZXN1bHQucHVzaChhLnopOyBicmVhaztcXG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IGNhc2UgJ1InOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XFxuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiBjYXNlICdHJzogcmVzdWx0LnB1c2goLWEueSk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJ1onOiBjYXNlICdXJzogY2FzZSAnQic6IHJlc3VsdC5wdXNoKC1hLnopOyBicmVhaztcXG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xcbiAgICAgIGNhc2UgJzEnOiByZXN1bHQucHVzaCgxKTsgYnJlYWs7XFxuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueSwgYS56XVtpXSA/PyAwKTsgYnJlYWs7XFxuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcbi8qKlxcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDNkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMzZFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBhbmdsZSBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBoaSBUaGUgcGFuIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczNkfSBUaGUgbWFnbml0dWRlLCB0aWx0IGFuZCBwYW4gb2YgdGhlIHZlY3RvclxcbiAqL1xcbnZlYzMucG9sYXIgPSBhID0+IHtcXG4gIGxldCByID0gdmVjMy5sZW4oYSksXFxuICAgIHRoZXRhID0gTWF0aC5hY29zKGEueSAvIHIpLFxcbiAgICBwaGkgPSBNYXRoLmF0YW4yKGEueiwgYS54KTtcXG4gIHJldHVybiB7IHIsIHRoZXRhLCBwaGkgfTtcXG59O1xcblxcbi8qKlxcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBvZiB0aGUgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ9IHBoaSBUaGUgcGFuIG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXFxuICovXFxudmVjMy5mcm9tUG9sYXIgPSAociwgdGhldGEsIHBoaSkgPT4ge1xcbiAgY29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XFxuICByZXR1cm4gdmVjMyhcXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5jb3MocGhpKSxcXG4gICAgciAqIE1hdGguY29zKHRoZXRhKSxcXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5zaW4ocGhpKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIEEgbWF0cml4XFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXhcXG4gKiBAcGFyYW0ge251bWJlcn0gW209NF0gVGhlIG51bWJlciBvZiByb3dzXFxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VudHJpZXM9W11dIE1hdHJpeCB2YWx1ZXMgaW4gcmVhZGluZyBvcmRlclxcbiAqIEByZXR1cm4ge21hdH0gQSBuZXcgbWF0cml4XFxuICovXFxuY29uc3QgbWF0ID0gKG0gPSA0LCBuID0gNCwgZW50cmllcyA9IFtdKSA9PiAoe1xcbiAgbSwgbixcXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcXG59KTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxcbiAqL1xcbm1hdC5pZGVudGl0eSA9IG4gPT4gbWF0KG4sIG4sIEFycmF5KG4gKiBuKS5maWxsKDApLm1hcCgodiwgaSkgPT4gKyhNYXRoLmZsb29yKGkgLyBuKSA9PT0gaSAlIG4pKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGVudHJ5IGZyb20gYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuZ2V0ID0gKGEsIGksIGopID0+IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl07XFxuXFxuLyoqXFxuICogU2V0IGFuIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5zZXQgPSAoYSwgaSwgaiwgdikgPT4geyBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dID0gdjsgfTtcXG5cXG4vKipcXG4gKiBHZXQgYSByb3cgZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIHJvdyBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSb3cgbSBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LnJvdyA9IChhLCBtKSA9PiB7XFxuICBjb25zdCBzID0gKG0gLSAxKSAqIGEubjtcXG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjb2x1bW4gZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDb2x1bW4gbiBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LmNvbCA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cmljZXMgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsID0gKGEsIGIpID0+IHtcXG4gIGlmIChhLm4gIT09IGIubSkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IG1hdChhLm0sIGIubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQocmVzdWx0LCBpLCBqLCBfdmVjX2RvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBNdWx0aXBseSBhIG1hdHJpeCBieSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHt2ZWMyfHZlYzN8bnVtYmVyW119IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWMyfHZlYzN8bnVtYmVyW118ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggYW5kIHZlY3RvciBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWx2ID0gKGEsIGIpID0+IHtcXG4gIGxldCBuLCBiYiwgcnQ7XFxuICBpZiAoX3ZlY19pc192ZWMzKGIpKSB7XFxuICAgIGJiID0gdmVjMy5jb21wb25lbnRzKGIpO1xcbiAgICBuID0gMztcXG4gICAgcnQgPSB2ZWMzLmZyb21Db21wb25lbnRzO1xcbiAgfSBlbHNlIGlmIChfdmVjX2lzX3ZlYzIoYikpIHtcXG4gICAgYmIgPSB2ZWMyLmNvbXBvbmVudHMoYik7XFxuICAgIG4gPSAyO1xcbiAgICBydCA9IHZlYzIuZnJvbUNvbXBvbmVudHM7XFxuICB9IGVsc2Uge1xcbiAgICBiYiA9IGI7XFxuICAgIG4gPSBiLmxlbmd0aCA/PyAwO1xcbiAgICBydCA9IHYgPT4gdjtcXG4gIH1cXG4gIGlmIChhLm4gIT09IG4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCByZXN1bHQgPSBbXTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIHJlc3VsdC5wdXNoKF92ZWNfZG90KG1hdC5yb3coYSwgaSksIGJiKSk7XFxuICB9XFxuICByZXR1cm4gcnQocmVzdWx0KTtcXG59XFxuXFxuLyoqXFxuICogU2NhbGUgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7bWF0fSBhICogYlxcbiAqL1xcbm1hdC5zY2FsZSA9IChhLCBiKSA9PiBtYXQubWFwKGEsIHYgPT4gdiAqIGIpO1xcblxcbi8qKlxcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gdHJhbnNwb3NlXFxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XFxuICovXFxubWF0LnRyYW5zID0gYSA9PiBtYXQoYS5uLCBhLm0sIF92ZWNfdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubWlub3IgPSAoYSwgaSwgaikgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZW50cmllcyA9IFtdO1xcbiAgZm9yIChsZXQgaWkgPSAxOyBpaSA8PSBhLm07IGlpKyspIHtcXG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XFxuICAgIGZvciAobGV0IGpqID0gMTsgamogPD0gYS5uOyBqaisrKSB7XFxuICAgICAgaWYgKGpqID09PSBqKSB7IGNvbnRpbnVlOyB9XFxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQuZGV0ID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBpZiAoYS5tID09PSAxKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF07XFxuICB9XFxuICBpZiAoYS5tID09PSAyKSB7XFxuICAgIHJldHVybiBhLmVudHJpZXNbMF0gKiBhLmVudHJpZXNbM10gLSBhLmVudHJpZXNbMV0gKiBhLmVudHJpZXNbMl07XFxuICB9XFxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcXG4gIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xcbiAgICBzaWduICo9IC0xO1xcbiAgfVxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogTm9ybWFsaXNlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBub3JtYWxpc2VcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxcbiAqL1xcbm1hdC5pbnYgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgaWYgKGQgPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XFxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtYXRyaWNlcyBhIGFuZCBiIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xcblxcbi8qKlxcbiAqIENvcHkgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvcHlcXG4gKiBAcmV0dXJuIHttYXR9IEEgY29weSBvZiBtYXRyaXggYVxcbiAqL1xcbm1hdC5jcHkgPSBhID0+IG1hdChhLm0sIGEubiwgWy4uLmEuZW50cmllc10pO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQGNhbGxiYWNrIG1hdHJpeE1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgZW50cnkgaW5kZXhcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIGFycmF5IG9mIG1hdHJpeCBlbnRyaWVzXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXggYW5kIGJ1aWxkIGEgbmV3IG1hdHJpeCBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gTWF0cml4IGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW21zPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciBjb2x1bW5zXFxuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxcXG4nXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3Igcm93c1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxcbiAqL1xcbm1hdC5zdHIgPSAoYSwgbXMgPSAnLCAnLCBucyA9ICdcXFxcbicpID0+IF92ZWNfY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjMiwgdmVjMywgbWF0IH07XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NhbnZhcy1oZWxwZXJzLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy53aXRoQ29udGV4dCA9IHdpdGhDb250ZXh0O1xcbmV4cG9ydHMubGluZSA9IGxpbmU7XFxuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xcbmV4cG9ydHMuYXJyb3cgPSBhcnJvdztcXG5leHBvcnRzLmNpcmNsZSA9IGNpcmNsZTtcXG5leHBvcnRzLnJlY3RhbmdsZSA9IHJlY3RhbmdsZTtcXG5leHBvcnRzLnBvbHlnb24gPSBwb2x5Z29uO1xcbmV4cG9ydHMucGF0aCA9IHBhdGg7XFxuY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1xcXCIpO1xcbmNvbnN0IHZlY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdmVjICovIFxcXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXFxcIik7XFxuY29uc3QgREVGQVVMVF9TVFlMRV9PUFRJT05TID0ge1xcbiAgICBiYXRjaDogZmFsc2UsXFxuICAgIGZpbGw6IGZhbHNlLFxcbiAgICBmaWxsQ29sb3I6IG51bGwsXFxuICAgIGdyYWRpZW50OiBudWxsLFxcbiAgICBzdHJva2U6IHRydWUsXFxuICAgIHN0cm9rZUNvbG9yOiBudWxsLFxcbiAgICBsaW5lV2lkdGg6IDEsXFxuICAgIGxpbmVTdHlsZTogJ3NvbGlkJyxcXG4gICAgbGluZURhc2g6IG51bGwsXFxuICAgIGNyb3NzU3R5bGU6ICd4JyxcXG4gICAgcm91bmRlZDogZmFsc2UsXFxuICAgIGFycm93OiB7XFxuICAgICAgICB0eXBlOiAnY2FyZXQnLFxcbiAgICAgICAgc2l6ZTogNSxcXG4gICAgfSxcXG59O1xcbmNvbnN0IERFRkFVTFRfTElORV9EQVNIRVMgPSB7XFxuICAgIHNvbGlkOiBbXSxcXG4gICAgZGFzaGVkOiBbNSwgNV0sXFxuICAgIGRvdHRlZDogWzEsIDNdLFxcbn07XFxuY29uc3QgQkVaSUVSX01BVFJJQ0VTID0ge1xcbiAgICAxOiAoMCwgdmVjXzEubWF0KSgyLCAyLCBbLTEsIDEsIDEsIDBdKSxcXG4gICAgMjogKDAsIHZlY18xLm1hdCkoMywgMywgWzEsIC0yLCAxLCAtMiwgMiwgMCwgMSwgMCwgMF0pLFxcbiAgICAzOiAoMCwgdmVjXzEubWF0KSg0LCA0LCBbLTEsIDMsIC0zLCAxLCAzLCAtNiwgMywgMCwgLTMsIDMsIDAsIDAsIDEsIDAsIDAsIDBdKSxcXG59O1xcbmNvbnN0IEJFWklFUl9DT0VGRklDSUVOVFMgPSAodCwgb3JkZXIpID0+ICh7XFxuICAgIDE6IFt0LCAxXSxcXG4gICAgMjogW3QgKiB0LCB0LCAxXSxcXG4gICAgMzogW3QgKiB0ICogdCwgdCAqIHQsIHQsIDFdLFxcbn1bb3JkZXJdKTtcXG5jb25zdCBDQVRNVUxMX1JPTV9CQVNJU19GVU5DVElPTlMgPSBbXFxuICAgICh0LCB0ZW5zaW9uKSA9PiAtdGVuc2lvbiAqIE1hdGgucG93KHQsIDMpICsgMiAqIHRlbnNpb24gKiBNYXRoLnBvdyh0LCAyKSAtIHRlbnNpb24gKiB0LFxcbiAgICAodCwgdGVuc2lvbikgPT4gKDIgLSB0ZW5zaW9uKSAqIE1hdGgucG93KHQsIDMpICsgKHRlbnNpb24gLSAzKSAqIE1hdGgucG93KHQsIDIpICsgMSxcXG4gICAgKHQsIHRlbnNpb24pID0+ICh0ZW5zaW9uIC0gMikgKiBNYXRoLnBvdyh0LCAzKSArXFxuICAgICAgICAoMyAtIDIgKiB0ZW5zaW9uKSAqIE1hdGgucG93KHQsIDIpICtcXG4gICAgICAgIHRlbnNpb24gKiB0LFxcbiAgICAodCwgdGVuc2lvbikgPT4gdGVuc2lvbiAqIE1hdGgucG93KHQsIDMpIC0gdGVuc2lvbiAqIE1hdGgucG93KHQsIDIpLFxcbl07XFxuY29uc3QgQ0FUTVVMTF9ST01fQkFTSVNfVkVDVE9SID0gKHQsIHRlbnNpb24pID0+IENBVE1VTExfUk9NX0JBU0lTX0ZVTkNUSU9OUy5tYXAoZiA9PiBmKHQsIHRlbnNpb24pKTtcXG4vKipcXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSBDb2xvciBvYmplY3RcXG4gKi9cXG5mdW5jdGlvbiBpc0NvbG9yT2JqZWN0KGNvbG9yKSB7XFxuICAgIHJldHVybiAodHlwZW9mIGNvbG9yID09PSAnb2JqZWN0JyAmJlxcbiAgICAgICAgJ3InIGluIGNvbG9yICYmXFxuICAgICAgICAnZycgaW4gY29sb3IgJiZcXG4gICAgICAgICdiJyBpbiBjb2xvciAmJlxcbiAgICAgICAgKHR5cGVvZiBjb2xvci5hID09PSAnbnVtYmVyJyB8fCAhKCdhJyBpbiBjb2xvcikpKTtcXG59XFxuLyoqXFxuICogQ29udmVydCBhIGNvbG9yIG9iamVjdCB0byBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IFxcXCJyZ2JhKHIsIGcsIGIsIGEpXFxcIlxcbiAqL1xcbmZ1bmN0aW9uIGNvbG91clRvU3RyaW5nKGNvbG9yKSB7XFxuICAgIHZhciBfYTtcXG4gICAgcmV0dXJuIGByZ2JhKCR7Y29sb3Iucn0sICR7Y29sb3IuZ30sICR7Y29sb3IuYn0sICR7KF9hID0gY29sb3IuYSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMX0pYDtcXG59XFxuLyoqXFxuICogUHJlcGFyZSBhIGNvbG9yIHZhbHVlIChzdHJpbmcgb3IgQ29sb3Igb2JqZWN0KSBmb3IgdXNlIGluIHN0eWxlc1xcbiAqL1xcbmZ1bmN0aW9uIHByZXBhcmVDb2xvcihjb2xvcikge1xcbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLy8gQXNzdW1lIGl0J3MgYWxyZWFkeSBhIHZhbGlkIENTUyBjb2xvciBzdHJpbmdcXG4gICAgICAgIHJldHVybiBjb2xvcjtcXG4gICAgfVxcbiAgICBlbHNlIGlmIChpc0NvbG9yT2JqZWN0KGNvbG9yKSkge1xcbiAgICAgICAgLy8gQ29udmVydCBDb2xvciBvYmplY3QgdG8gQ1NTIGNvbG9yIHN0cmluZ1xcbiAgICAgICAgcmV0dXJuIGNvbG91clRvU3RyaW5nKGNvbG9yKTtcXG4gICAgfVxcbiAgICAvLyBJZiBpdCdzIG5laXRoZXIsIGRlZmF1bHQgdG8gYmxhY2tcXG4gICAgcmV0dXJuICdibGFjayc7XFxufVxcbi8qKlxcbiAqIFByZXBhcmUgYSBncmFkaWVudCBmb3IgdXNlIGluIHN0eWxlc1xcbiAqXFxuICogUmV0dXJucyBhIENhbnZhc0dyYWRpZW50IG9iamVjdCBvciBudWxsIGlmIG5vIGdyYWRpZW50IGlzIHNwZWNpZmllZFxcbiAqL1xcbmZ1bmN0aW9uIHByZXBhcmVHcmFkaWVudChjb250ZXh0LCBzdHlsZSkge1xcbiAgICBpZiAoIXN0eWxlKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBsZXQgZ3JhZGllbnQ7XFxuICAgIGlmIChzdHlsZS50eXBlID09PSAnbGluZWFyJykge1xcbiAgICAgICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0eWxlLnN0YXJ0LngsIHN0eWxlLnN0YXJ0LnksIHN0eWxlLmVuZC54LCBzdHlsZS5lbmQueSk7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoc3R5bGUuc3RhcnQueCwgc3R5bGUuc3RhcnQueSwgMCwgc3R5bGUuc3RhcnQueCwgc3R5bGUuc3RhcnQueSwgdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoc3R5bGUuZW5kLCBzdHlsZS5zdGFydCkpIC8gMik7XFxuICAgIH1cXG4gICAgZm9yIChjb25zdCBzdG9wIG9mIHN0eWxlLmNvbG9yU3RvcHMpIHtcXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLnBvc2l0aW9uLCBwcmVwYXJlQ29sb3Ioc3RvcC5jb2xvcikpO1xcbiAgICB9XFxuICAgIHJldHVybiBncmFkaWVudDtcXG59XFxuLyoqXFxuICogR2V0IGEgY29tcGxldGUgc3R5bGUgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMgZmlsbGVkIGluXFxuICovXFxuZnVuY3Rpb24gZ2V0U3R5bGUoc3R5bGUpIHtcXG4gICAgdmFyIF9hO1xcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TVFlMRV9PUFRJT05TLCB7XFxuICAgICAgICAuLi4oc3R5bGUgIT09IG51bGwgJiYgc3R5bGUgIT09IHZvaWQgMCA/IHN0eWxlIDoge30pLFxcbiAgICAgICAgbGluZURhc2g6IHN0eWxlICYmIHN0eWxlLmxpbmVEYXNoICE9PSB1bmRlZmluZWRcXG4gICAgICAgICAgICA/IHN0eWxlLmxpbmVEYXNoXFxuICAgICAgICAgICAgOiAoc3R5bGUgPT09IG51bGwgfHwgc3R5bGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlLmxpbmVTdHlsZSkgPT09IHVuZGVmaW5lZFxcbiAgICAgICAgICAgICAgICA/IFtdXFxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9MSU5FX0RBU0hFU1soX2EgPSBzdHlsZS5saW5lU3R5bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdzb2xpZCddLFxcbiAgICB9KTtcXG59XFxuLyoqXFxuICogUGFzcyBpbiBhIGNvbnRleHQgYW5kIHNvbWUgbnVtYmVyIG9mIGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBjb250ZXh0IGFzIHRoZWlyXFxuICogZmlyc3QgYXJndW1lbnQsIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgZG9uJ3QgcmVxdWlyZSB0aGVcXG4gKiBjb250ZXh0IGFyZ3VtZW50XFxuICpcXG4gKiBJZiBvbmx5IG9uZSBmdW5jdGlvbiBpcyBwYXNzZWQsIHRoaXMgd2lsbCByZXR1cm4gYSBzaW5nbGUgZnVuY3Rpb25cXG4gKi9cXG5mdW5jdGlvbiB3aXRoQ29udGV4dChjb250ZXh0LCAuLi5mdW5jdGlvbnMpIHtcXG4gICAgY29uc3QgcmVzdWx0ID0gZnVuY3Rpb25zLm1hcChmID0+IHtcXG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xcbiAgICAgICAgICAgIGYoY29udGV4dCwgLi4uYXJncyk7XFxuICAgICAgICB9O1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XFxufVxcbi8qKlxcbiAqIERyYXcgYSBzdHJhaWdodCBsaW5lIHNlZ21lbnQgYmV0d2VlbiB0d28gcG9pbnRzXFxuICovXFxuZnVuY3Rpb24gbGluZShjb250ZXh0LCBzdGFydCwgZW5kLCBzdHlsZSkge1xcbiAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgLy8gQXBwbHkgc3R5bGVzXFxuICAgIGNvbnN0IGFjdHVhbFN0eWxlID0gZ2V0U3R5bGUoc3R5bGUpO1xcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lV2lkdGggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYWN0dWFsU3R5bGUubGluZVdpZHRoO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lRGFzaCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChhY3R1YWxTdHlsZS5saW5lRGFzaCk7XFxuICAgIH1cXG4gICAgLy8gSWYgdGhpcyBpcyBhIGJhdGNoIG9wZXJhdGlvbiwgZG9uJ3QgYmVnaW4gYSBuZXcgcGF0aCBzbyB3ZSBjYW4gYWRkIHRvIGFueVxcbiAgICAvLyBleGlzdGluZyBwYXRoIGFuZCBkcmF3IG11bHRpcGxlIGxpbmVzIGluIG9uZSBnb1xcbiAgICBpZiAoIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICB9XFxuICAgIGNvbnRleHQubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xcbiAgICBjb250ZXh0LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xcbiAgICAvLyBTdHJva2UgdGhlIHBhdGggaWYgcmVxdWlyZWRcXG4gICAgLy8gQWRkaXRpb25hbGx5LCBpZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCB3ZSBkb24ndCBzdHJva2UgcmlnaHQgYXdheSBzb1xcbiAgICAvLyB0aGF0IHdlIGNhbiBhZGQgbW9yZSBsaW5lcyB0byB0aGUgc2FtZSBwYXRoIGlmIHdlIHdhbnRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYSBjcm9zcyBhdCBhIGdpdmVuIHBvc2l0aW9uIHdpdGggYSBzcGVjaWZpZWQgc2l6ZVxcbiAqL1xcbmZ1bmN0aW9uIGNyb3NzKGNvbnRleHQsIHBvc2l0aW9uLCBzaXplLCBzdHlsZSkge1xcbiAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgLy8gQXBwbHkgc3R5bGVzXFxuICAgIGNvbnN0IGFjdHVhbFN0eWxlID0gZ2V0U3R5bGUoc3R5bGUpO1xcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lV2lkdGggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYWN0dWFsU3R5bGUubGluZVdpZHRoO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lRGFzaCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChhY3R1YWxTdHlsZS5saW5lRGFzaCk7XFxuICAgIH1cXG4gICAgLy8gSWYgdGhpcyBpcyBhIGJhdGNoIG9wZXJhdGlvbiwgZG9uJ3QgYmVnaW4gYSBuZXcgcGF0aCBzbyB3ZSBjYW4gYWRkIHRvIGFueVxcbiAgICAvLyBleGlzdGluZyBwYXRoIGFuZCBkcmF3IG11bHRpcGxlIGxpbmVzIGluIG9uZSBnb1xcbiAgICBpZiAoIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICB9XFxuICAgIC8vIERyYXcgdGhlIGNyb3NzXFxuICAgIGNvbnN0IGhhbGZTaXplID0gc2l6ZSAvIDI7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5jcm9zc1N0eWxlID09PSAnKycpIHtcXG4gICAgICAgIC8vIFBsdXMgc2lnbiBjcm9zc1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCAtIGhhbGZTaXplLCBwb3NpdGlvbi55KTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55IC0gaGFsZlNpemUpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgfVxcbiAgICBlbHNlIGlmIChhY3R1YWxTdHlsZS5jcm9zc1N0eWxlID09PSAneCcpIHtcXG4gICAgICAgIC8vIFggY3Jvc3NcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgfVxcbiAgICAvLyBTdHJva2UgdGhlIHBhdGggaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYW4gYXJyb3cgZnJvbSBhIHN0YXJ0IHBvaW50IHRvIGFuIGVuZCBwb2ludCB3aXRoIGFuIG9wdGlvbmFsIGFycm93aGVhZFxcbiAqIGF0IHRoZSBlbmRcXG4gKlxcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCBkcmF3aW5nIHNpbmNlIGl0IHJlcXVpcmVzXFxuICogYmVnaW5uaW5nIGEgbmV3IHBhdGggZm9yIHRoZSBhcnJvd2hlYWRcXG4gKi9cXG5mdW5jdGlvbiBhcnJvdyhjb250ZXh0LCBzdGFydCwgZW5kLCBzdHlsZSkge1xcbiAgICB2YXIgX2E7XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBBcnJvd3MgZG9uJ3Qgc3VwcG9ydCBiYXRjaCBkcmF3aW5nIHNpbmNlIHdlIGhhdmUgdG8gYmVnaW4gYSBuZXcgcGF0aFxcbiAgICAvLyB3aGVuIGRyYXdpbmcgdGhlIGFycm93aGVhZFxcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAvLyBEcmF3IHRoZSBsaW5lIHNlZ21lbnRcXG4gICAgY29udGV4dC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XFxuICAgIGNvbnRleHQubGluZVRvKGVuZC54LCBlbmQueSk7XFxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIC8vIERyYXcgdGhlIGFycm93aGVhZCBpZiBzcGVjaWZpZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmFycm93KSB7XFxuICAgICAgICBjb25zdCBhcnJvd1NpemUgPSAoX2EgPSBhY3R1YWxTdHlsZS5hcnJvdy5zaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxMDtcXG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gYXJyb3dTaXplIC8gMjtcXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdmVjXzEudmVjMi5yYWQodmVjXzEudmVjMi5zdWIoZW5kLCBzdGFydCkpO1xcbiAgICAgICAgY29uc3QgYXJyb3dUeXBlID0gYWN0dWFsU3R5bGUuYXJyb3cudHlwZTtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoZW5kLngsIGVuZC55KTtcXG4gICAgICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcXG4gICAgICAgIGlmICh0eXBlb2YgYXJyb3dUeXBlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgYXJyb3dUeXBlKGNvbnRleHQsIGFycm93U2l6ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChhcnJvd1R5cGUgPT09ICdjYXJldCcpIHtcXG4gICAgICAgICAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oYWxmU2l6ZSk7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYXJyb3dTaXplLCAwKTtcXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBoYWxmU2l6ZSk7XFxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGFycm93VHlwZSA9PT0gJ2NoZXZyb24nKSB7XFxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygtaGFsZlNpemUsIC1oYWxmU2l6ZSk7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgMCk7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLWhhbGZTaXplLCBoYWxmU2l6ZSk7XFxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbn1cXG4vKipcXG4gKiBEcmF3IGEgY2lyY2xlIGF0IGEgc3BlY2lmaWVkIGNlbnRlciBwb2ludCB3aXRoIGEgZ2l2ZW4gcmFkaXVzXFxuICovXFxuZnVuY3Rpb24gY2lyY2xlKGNvbnRleHQsIGNlbnRlciwgcmFkaXVzLCBzdHlsZSkge1xcbiAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgLy8gQXBwbHkgc3R5bGVzXFxuICAgIGNvbnN0IGFjdHVhbFN0eWxlID0gZ2V0U3R5bGUoc3R5bGUpO1xcbiAgICBpZiAoYWN0dWFsU3R5bGUuZmlsbENvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5maWxsQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5ncmFkaWVudCkge1xcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBwcmVwYXJlR3JhZGllbnQoY29udGV4dCwgYWN0dWFsU3R5bGUuZ3JhZGllbnQpO1xcbiAgICAgICAgaWYgKGdyYWRpZW50KSB7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuc3Ryb2tlQ29sb3IpO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lV2lkdGggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYWN0dWFsU3R5bGUubGluZVdpZHRoO1xcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5saW5lRGFzaCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChhY3R1YWxTdHlsZS5saW5lRGFzaCk7XFxuICAgIH1cXG4gICAgLy8gSWYgdGhpcyBpcyBhIGJhdGNoIG9wZXJhdGlvbiwgZG9uJ3QgYmVnaW4gYSBuZXcgcGF0aCBzbyB3ZSBjYW4gYWRkIHRvIGFueVxcbiAgICAvLyBleGlzdGluZyBwYXRoIGFuZCBkcmF3IG11bHRpcGxlIHNoYXBlcyBpbiBvbmUgZ29cXG4gICAgaWYgKCFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgfVxcbiAgICAvLyBEcmF3IHRoZSBjaXJjbGVcXG4gICAgY29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcXG4gICAgLy8gRmlsbCB0aGUgY2lyY2xlIGlmIHJlcXVpcmVkXFxuICAgIGlmIChhY3R1YWxTdHlsZS5maWxsICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5maWxsKCk7XFxuICAgIH1cXG4gICAgLy8gU3Ryb2tlIHRoZSBjaXJjbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYSByZWN0YW5nbGUgYXQgYSBzcGVjaWZpZWQgcG9zaXRpb24gd2l0aCBhIGdpdmVuIHNpemVcXG4gKi9cXG5mdW5jdGlvbiByZWN0YW5nbGUoY29udGV4dCwgcG9zaXRpb24sIHNpemUsIHN0eWxlKSB7XFxuICAgIHZhciBfYTtcXG4gICAgY29udGV4dC5zYXZlKCk7XFxuICAgIC8vIEFwcGx5IHN0eWxlc1xcbiAgICBjb25zdCBhY3R1YWxTdHlsZSA9IGdldFN0eWxlKHN0eWxlKTtcXG4gICAgaWYgKGFjdHVhbFN0eWxlLmZpbGxDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwcmVwYXJlQ29sb3IoYWN0dWFsU3R5bGUuZmlsbENvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUuZ3JhZGllbnQpIHtcXG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gcHJlcGFyZUdyYWRpZW50KGNvbnRleHQsIGFjdHVhbFN0eWxlLmdyYWRpZW50KTtcXG4gICAgICAgIGlmIChncmFkaWVudCkge1xcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnQ7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLnN0cm9rZUNvbG9yKTtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZVdpZHRoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGFjdHVhbFN0eWxlLmxpbmVXaWR0aDtcXG4gICAgfVxcbiAgICBpZiAoYWN0dWFsU3R5bGUubGluZURhc2ggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goYWN0dWFsU3R5bGUubGluZURhc2gpO1xcbiAgICB9XFxuICAgIC8vIElmIHRoaXMgaXMgYSBiYXRjaCBvcGVyYXRpb24sIGRvbid0IGJlZ2luIGEgbmV3IHBhdGggc28gd2UgY2FuIGFkZCB0byBhbnlcXG4gICAgLy8gZXhpc3RpbmcgcGF0aCBhbmQgZHJhdyBtdWx0aXBsZSBzaGFwZXMgaW4gb25lIGdvXFxuICAgIGlmICghYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIH1cXG4gICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlXFxuICAgIGlmIChhY3R1YWxTdHlsZS5yb3VuZGVkKSB7XFxuICAgICAgICBjb250ZXh0LnJvdW5kUmVjdChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBzaXplLngsIHNpemUueSwgKF9hID0gYWN0dWFsU3R5bGUuYm9yZGVyUmFkaXVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKTtcXG4gICAgfVxcbiAgICBlbHNlIHtcXG4gICAgICAgIGNvbnRleHQucmVjdChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBzaXplLngsIHNpemUueSk7XFxuICAgIH1cXG4gICAgLy8gRmlsbCB0aGUgcmVjdGFuZ2xlIGlmIHJlcXVpcmVkXFxuICAgIGlmIChhY3R1YWxTdHlsZS5maWxsICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5maWxsKCk7XFxuICAgIH1cXG4gICAgLy8gU3Ryb2tlIHRoZSByZWN0YW5nbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYSBwb2x5Z29uIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdmVydGljZXNcXG4gKi9cXG5mdW5jdGlvbiBwb2x5Z29uKGNvbnRleHQsIHZlcnRpY2VzLCBzdHlsZSkge1xcbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5maWxsQ29sb3IgIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcHJlcGFyZUNvbG9yKGFjdHVhbFN0eWxlLmZpbGxDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmdyYWRpZW50KSB7XFxuICAgICAgICBjb25zdCBncmFkaWVudCA9IHByZXBhcmVHcmFkaWVudChjb250ZXh0LCBhY3R1YWxTdHlsZS5ncmFkaWVudCk7XFxuICAgICAgICBpZiAoZ3JhZGllbnQpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBJZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCBkb24ndCBiZWdpbiBhIG5ldyBwYXRoIHNvIHdlIGNhbiBhZGQgdG8gYW55XFxuICAgIC8vIGV4aXN0aW5nIHBhdGggYW5kIGRyYXcgbXVsdGlwbGUgc2hhcGVzIGluIG9uZSBnb1xcbiAgICBpZiAoIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICB9XFxuICAgIC8vIERyYXcgdGhlIHBvbHlnb24gcGF0aFxcbiAgICBjb250ZXh0Lm1vdmVUbyh2ZXJ0aWNlc1swXS54LCB2ZXJ0aWNlc1swXS55KTtcXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgY29udGV4dC5saW5lVG8odmVydGljZXNbaV0ueCwgdmVydGljZXNbaV0ueSk7XFxuICAgIH1cXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcXG4gICAgLy8gRmlsbCB0aGUgcmVjdGFuZ2xlIGlmIHJlcXVpcmVkXFxuICAgIGlmIChhY3R1YWxTdHlsZS5maWxsICYmICFhY3R1YWxTdHlsZS5iYXRjaCkge1xcbiAgICAgICAgY29udGV4dC5maWxsKCk7XFxuICAgIH1cXG4gICAgLy8gU3Ryb2tlIHRoZSByZWN0YW5nbGUgaWYgcmVxdWlyZWRcXG4gICAgaWYgKGFjdHVhbFN0eWxlLnN0cm9rZSAmJiAhYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XFxufVxcbi8qKlxcbiAqIERyYXcgYSBwYXRoIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdmVydGljZXNcXG4gKi9cXG5mdW5jdGlvbiBwYXRoKGNvbnRleHQsIHZlcnRpY2VzLCBzdHlsZSkge1xcbiAgICB2YXIgX2EsIF9iLCBfYztcXG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDIpXFxuICAgICAgICByZXR1cm47XFxuICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAvLyBBcHBseSBzdHlsZXNcXG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSBnZXRTdHlsZShzdHlsZSk7XFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2VDb2xvciAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHByZXBhcmVDb2xvcihhY3R1YWxTdHlsZS5zdHJva2VDb2xvcik7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVXaWR0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBhY3R1YWxTdHlsZS5saW5lV2lkdGg7XFxuICAgIH1cXG4gICAgaWYgKGFjdHVhbFN0eWxlLmxpbmVEYXNoICE9PSBudWxsKSB7XFxuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGFjdHVhbFN0eWxlLmxpbmVEYXNoKTtcXG4gICAgfVxcbiAgICAvLyBJZiB0aGlzIGlzIGEgYmF0Y2ggb3BlcmF0aW9uLCBkb24ndCBiZWdpbiBhIG5ldyBwYXRoXFxuICAgIGlmICghYWN0dWFsU3R5bGUuYmF0Y2gpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIH1cXG4gICAgLy8gSGFuZGxlIGRpZmZlcmVudCBwYXRoIHR5cGVzXFxuICAgIGNvbnN0IHBhdGhUeXBlID0gKF9hID0gYWN0dWFsU3R5bGUucGF0aFR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdsaW5lYXInO1xcbiAgICBpZiAocGF0aFR5cGUgPT09ICdsaW5lYXInKSB7XFxuICAgICAgICAvLyBTaW1wbGUgbGluZWFyIHBhdGhcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHZlcnRpY2VzWzBdLngsIHZlcnRpY2VzWzBdLnkpO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHZlcnRpY2VzW2ldLngsIHZlcnRpY2VzW2ldLnkpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGVsc2UgaWYgKHBhdGhUeXBlID09PSAnYmV6aWVyJykge1xcbiAgICAgICAgY29uc3Qgb3JkZXIgPSAoMCwgdXRpbHNfMS5jbGFtcCkoKF9iID0gYWN0dWFsU3R5bGUuYmV6aWVyT3JkZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDMsIDEsIDMpO1xcbiAgICAgICAgLy8gRHJhdyBiZXppZXIgY3VydmUgc2VnbWVudHNcXG4gICAgICAgIGNvbnN0IHNlZ21lbnRTaXplID0gb3JkZXIgKyAxO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyBzZWdtZW50U2l6ZSA8PSB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gb3JkZXIpIHtcXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50UG9pbnRzID0gdmVydGljZXMuc2xpY2UoaSwgaSArIHNlZ21lbnRTaXplKTtcXG4gICAgICAgICAgICAvLyBEcmF3IGZpcnN0IHBvaW50IG9mIHNlZ21lbnRcXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhzZWdtZW50UG9pbnRzWzBdLngsIHNlZ21lbnRQb2ludHNbMF0ueSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIERyYXcgYmV6aWVyIGN1cnZlIHRocm91Z2ggcG9pbnRzXFxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPD0gMTsgdCArPSAwLjAxKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHEgPSB2ZWNfMS5tYXQubXVsdihCRVpJRVJfTUFUUklDRVNbb3JkZXJdLCBCRVpJRVJfQ09FRkZJQ0lFTlRTKHQsIG9yZGVyKSk7XFxuICAgICAgICAgICAgICAgIGlmIChxID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHAgPSAoMCwgdmVjXzEudmVjMikoKTtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50U2l6ZTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBwLnggKz0gc2VnbWVudFBvaW50c1tqXS54ICogcVtqXTtcXG4gICAgICAgICAgICAgICAgICAgIHAueSArPSBzZWdtZW50UG9pbnRzW2pdLnkgKiBxW2pdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAueCwgcC55KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZWxzZSBpZiAocGF0aFR5cGUgPT09ICdjYXRtdWxsLXJvbScpIHtcXG4gICAgICAgIGNvbnN0IHRlbnNpb24gPSAoX2MgPSBhY3R1YWxTdHlsZS5jYXRtdWxsUm9tVGVuc2lvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMC41O1xcbiAgICAgICAgLy8gTmVlZCBhdCBsZWFzdCA0IHBvaW50cyBmb3IgQ2F0bXVsbC1Sb21cXG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPj0gNCkge1xcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHZlcnRpY2VzWzFdLngsIHZlcnRpY2VzWzFdLnkpO1xcbiAgICAgICAgICAgIC8vIERyYXcgY3VydmUgc2VnbWVudHNcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlcnRpY2VzLmxlbmd0aCAtIDI7IGkrKykge1xcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpIC0gMV0sXFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXSxcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2kgKyAxXSxcXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2kgKyAyXSxcXG4gICAgICAgICAgICAgICAgXTtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPD0gMTsgdCArPSAwLjAxKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gKDAsIHV0aWxzXzEuZG90KShwb2ludHMubWFwKHAgPT4gcC54KSwgQ0FUTVVMTF9ST01fQkFTSVNfVkVDVE9SKHQsIHRlbnNpb24pKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAoMCwgdXRpbHNfMS5kb3QpKHBvaW50cy5tYXAocCA9PiBwLnkpLCBDQVRNVUxMX1JPTV9CQVNJU19WRUNUT1IodCwgdGVuc2lvbikpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gbGluZWFyIGlmIG5vdCBlbm91Z2ggcG9pbnRzXFxuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odmVydGljZXNbMF0ueCwgdmVydGljZXNbMF0ueSk7XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh2ZXJ0aWNlc1tpXS54LCB2ZXJ0aWNlc1tpXS55KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgLy8gU3Ryb2tlIHRoZSBwYXRoIGlmIHJlcXVpcmVkXFxuICAgIGlmIChhY3R1YWxTdHlsZS5zdHJva2UgJiYgIWFjdHVhbFN0eWxlLmJhdGNoKSB7XFxuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICB9XFxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycy8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9jb250ZW50LWxvYWRlcnMvYXVkaW8ubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy9hdWRpby5sb2FkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuQXVkaW9Mb2FkZXIgPSB2b2lkIDA7XFxuY29uc3QgQXVkaW9Mb2FkZXIgPSBhc3luYyAodXJsKSA9PiB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICBjb25zdCBhdWRpbyA9IG5ldyBBdWRpbyh1cmwpO1xcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsICgpID0+IHtcXG4gICAgICAgICAgICByZXNvbHZlKGF1ZGlvKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XFxuICAgICAgICAgICAgcmVqZWN0KGBFcnJvciBsb2FkaW5nIGF1ZGlvIFxcXCIke3VybH1cXFwiYCk7XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufTtcXG5leHBvcnRzLkF1ZGlvTG9hZGVyID0gQXVkaW9Mb2FkZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvY29udGVudC1tYW5hZ2VyLy4vY29udGVudC1sb2FkZXJzL2F1ZGlvLmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2ZvbnQubG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuRm9udExvYWRlciA9IHZvaWQgMDtcXG5jb25zdCBGb250TG9hZGVyID0gYXN5bmMgKHVybCwgZmFtaWx5KSA9PiB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlKGZhbWlseSwgYHVybCgke3VybH0pYCk7XFxuICAgICAgICBmb250LmxvYWQoKVxcbiAgICAgICAgICAgIC50aGVuKGZvbnQgPT4ge1xcbiAgICAgICAgICAgIGRvY3VtZW50LmZvbnRzLmFkZChmb250KTtcXG4gICAgICAgICAgICByZXNvbHZlKGZvbnQpO1xcbiAgICAgICAgfSlcXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xcbiAgICAgICAgICAgIHJlamVjdChgRXJyb3IgbG9hZGluZyBmb250IFxcXCIke3VybH1cXFwiYCk7XFxuICAgICAgICB9KTtcXG4gICAgfSk7XFxufTtcXG5leHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtbG9hZGVycy9mb250LmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL2ltYWdlLmxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jb250ZW50LWxvYWRlcnMvaW1hZ2UubG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLkltYWdlTG9hZGVyID0gdm9pZCAwO1xcbmNvbnN0IEltYWdlTG9hZGVyID0gYXN5bmMgKHVybCkgPT4ge1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcXG4gICAgICAgIGltYWdlLnNyYyA9IHVybDtcXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XFxuICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKCkgPT4ge1xcbiAgICAgICAgICAgIHJlamVjdChgRXJyb3IgbG9hZGluZyBpbWFnZSBcXFwiJHt1cmx9XFxcImApO1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn07XFxuZXhwb3J0cy5JbWFnZUxvYWRlciA9IEltYWdlTG9hZGVyO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtbG9hZGVycy9pbWFnZS5sb2FkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2NvbnRlbnQtbG9hZGVycy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiXFxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XFxuICAgIGlmICghZGVzYyB8fCAoXFxcImdldFxcXCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XFxuICAgIH1cXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xcbiAgICBvW2syXSA9IG1ba107XFxufSkpO1xcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcXFwiZGVmYXVsdFxcXCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xcbn07XFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2F1ZGlvLmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvYXVkaW8ubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZvbnQubG9hZGVyICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9mb250LmxvYWRlci50c1xcXCIpLCBleHBvcnRzKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbWFnZS5sb2FkZXIgKi8gXFxcIi4vY29udGVudC1sb2FkZXJzL2ltYWdlLmxvYWRlci50c1xcXCIpLCBleHBvcnRzKTtcXG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9qc29uLmxvYWRlciAqLyBcXFwiLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHNcXFwiKSwgZXhwb3J0cyk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGV4dC5sb2FkZXIgKi8gXFxcIi4vY29udGVudC1sb2FkZXJzL3RleHQubG9hZGVyLnRzXFxcIiksIGV4cG9ydHMpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtbG9hZGVycy9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1sb2FkZXJzL2pzb24ubG9hZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1sb2FkZXJzL2pzb24ubG9hZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuSlNPTkxvYWRlciA9IHZvaWQgMDtcXG5jb25zdCBKU09OTG9hZGVyID0gYXN5bmMgKHVybE9yRGF0YSkgPT4ge1xcbiAgICBpZiAodHlwZW9mIHVybE9yRGF0YSA9PT0gJ3N0cmluZycgJiZcXG4gICAgICAgIHVybE9yRGF0YS5zdGFydHNXaXRoKCdodHRwJykpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICAgICAgd2luZG93LmZldGNoKHVybE9yRGF0YSwge1xcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xcbiAgICAgICAgICAgICAgICByZXNvbHZlKGpzb24pO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJlamVjdChgRXJyb3IgbG9hZGluZyBqc29uIFxcXCIke3VybE9yRGF0YX1cXFwiYCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gdXJsT3JEYXRhO1xcbn07XFxuZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXIvLi9jb250ZW50LWxvYWRlcnMvanNvbi5sb2FkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2NvbnRlbnQtbG9hZGVycy90ZXh0LmxvYWRlci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnQtbG9hZGVycy90ZXh0LmxvYWRlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlRleHRMb2FkZXIgPSB2b2lkIDA7XFxuY29uc3QgVGV4dExvYWRlciA9IGFzeW5jICh1cmxPclRleHQpID0+IHtcXG4gICAgaWYgKHVybE9yVGV4dC5zdGFydHNXaXRoKCdodHRwJykpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICAgICAgd2luZG93LmZldGNoKHVybE9yVGV4dCwge1xcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcsXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJlamVjdChgRXJyb3IgbG9hZGluZyB0ZXh0IFxcXCIke3VybE9yVGV4dH1cXFwiYCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gdXJsT3JUZXh0LnRvU3RyaW5nKCk7XFxufTtcXG5leHBvcnRzLlRleHRMb2FkZXIgPSBUZXh0TG9hZGVyO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtbG9hZGVycy90ZXh0LmxvYWRlci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1wcm9jZXNzb3JzL2ltYWdlLW5hbWUucHJvY2Vzc29yLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1wcm9jZXNzb3JzL2ltYWdlLW5hbWUucHJvY2Vzc29yLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuSW1hZ2VOYW1lUHJvY2Vzc29yID0gdm9pZCAwO1xcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xcbiAgICBpbWFnZU5hbWVGaWVsZE5hbWU6ICdpbWFnZU5hbWUnLFxcbiAgICBpbWFnZUZpZWxkTmFtZTogJ2ltYWdlJyxcXG59O1xcbmNvbnN0IEltYWdlTmFtZVByb2Nlc3NvciA9IGFzeW5jIChjb250ZW50LCBpdGVtLCBvcHRpb25zKSA9PiB7XFxuICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xcbiAgICBpZiAodHlwZW9mIGl0ZW0uY29udGVudCA9PT0gJ29iamVjdCcgJiZcXG4gICAgICAgIGl0ZW0uY29udGVudCAhPT0gbnVsbCkge1xcbiAgICAgICAgY29uc3QgcHJvY2Vzc09iamVjdCA9IChvKSA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gYWN0dWFsT3B0aW9ucy5pbWFnZU5hbWVGaWVsZE5hbWUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlTmFtZSA9IG9ba2V5XTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlSXRlbSA9IChfYSA9IGNvbnRlbnRbaW1hZ2VOYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VJdGVtKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb1thY3R1YWxPcHRpb25zLmltYWdlRmllbGROYW1lXSA9IGltYWdlSXRlbTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb1trZXldO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvW2tleV0gPT09ICdvYmplY3QnICYmXFxuICAgICAgICAgICAgICAgICAgICBvW2tleV0gIT09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NPYmplY3Qob1trZXldKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgICBwcm9jZXNzT2JqZWN0KGl0ZW0uY29udGVudCk7XFxuICAgIH1cXG59O1xcbmV4cG9ydHMuSW1hZ2VOYW1lUHJvY2Vzc29yID0gSW1hZ2VOYW1lUHJvY2Vzc29yO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtcHJvY2Vzc29ycy9pbWFnZS1uYW1lLnByb2Nlc3Nvci50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vY29udGVudC1wcm9jZXNzb3JzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vY29udGVudC1wcm9jZXNzb3JzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJcXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcXG4gICAgaWYgKCFkZXNjIHx8IChcXFwiZ2V0XFxcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XFxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcXG4gICAgfVxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XFxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XFxuICAgIG9bazJdID0gbVtrXTtcXG59KSk7XFxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XFxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFxcXCJkZWZhdWx0XFxcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XFxufTtcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW1hZ2UtbmFtZS5wcm9jZXNzb3IgKi8gXFxcIi4vY29udGVudC1wcm9jZXNzb3JzL2ltYWdlLW5hbWUucHJvY2Vzc29yLnRzXFxcIiksIGV4cG9ydHMpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2NvbnRlbnQtcHJvY2Vzc29ycy9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuZXhwb3J0cy5Db250ZW50SXRlbVN0YXR1cyA9IGV4cG9ydHMuQ29udGVudE1hbmFnZXJTdGF0dXMgPSBleHBvcnRzLkNvbnRlbnRJdGVtVHlwZSA9IHZvaWQgMDtcXG5jb25zdCBjb250ZW50X2xvYWRlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGVudC1sb2FkZXJzICovIFxcXCIuL2NvbnRlbnQtbG9hZGVycy9pbmRleC50c1xcXCIpO1xcbmNvbnN0IGNvbnRlbnRfcHJvY2Vzc29yc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250ZW50LXByb2Nlc3NvcnMgKi8gXFxcIi4vY29udGVudC1wcm9jZXNzb3JzL2luZGV4LnRzXFxcIik7XFxudmFyIENvbnRlbnRJdGVtVHlwZTtcXG4oZnVuY3Rpb24gKENvbnRlbnRJdGVtVHlwZSkge1xcbiAgICBDb250ZW50SXRlbVR5cGVbXFxcIkpTT05cXFwiXSA9IFxcXCJqc29uXFxcIjtcXG4gICAgQ29udGVudEl0ZW1UeXBlW1xcXCJGb250XFxcIl0gPSBcXFwiZm9udFxcXCI7XFxuICAgIENvbnRlbnRJdGVtVHlwZVtcXFwiSW1hZ2VcXFwiXSA9IFxcXCJpbWFnZVxcXCI7XFxuICAgIENvbnRlbnRJdGVtVHlwZVtcXFwiQXVkaW9cXFwiXSA9IFxcXCJhdWRpb1xcXCI7XFxuICAgIENvbnRlbnRJdGVtVHlwZVtcXFwiVGV4dFxcXCJdID0gXFxcInRleHRcXFwiO1xcbn0pKENvbnRlbnRJdGVtVHlwZSA9IGV4cG9ydHMuQ29udGVudEl0ZW1UeXBlIHx8IChleHBvcnRzLkNvbnRlbnRJdGVtVHlwZSA9IHt9KSk7XFxudmFyIENvbnRlbnRNYW5hZ2VyU3RhdHVzO1xcbihmdW5jdGlvbiAoQ29udGVudE1hbmFnZXJTdGF0dXMpIHtcXG4gICAgQ29udGVudE1hbmFnZXJTdGF0dXNbXFxcIklkbGVcXFwiXSA9IFxcXCJpZGxlXFxcIjtcXG4gICAgQ29udGVudE1hbmFnZXJTdGF0dXNbXFxcIkxvYWRpbmdcXFwiXSA9IFxcXCJsb2FkaW5nXFxcIjtcXG4gICAgQ29udGVudE1hbmFnZXJTdGF0dXNbXFxcIlByb2Nlc3NpbmdcXFwiXSA9IFxcXCJwcm9jZXNzaW5nXFxcIjtcXG4gICAgQ29udGVudE1hbmFnZXJTdGF0dXNbXFxcIlJlYWR5XFxcIl0gPSBcXFwicmVhZHlcXFwiO1xcbn0pKENvbnRlbnRNYW5hZ2VyU3RhdHVzID0gZXhwb3J0cy5Db250ZW50TWFuYWdlclN0YXR1cyB8fCAoZXhwb3J0cy5Db250ZW50TWFuYWdlclN0YXR1cyA9IHt9KSk7XFxudmFyIENvbnRlbnRJdGVtU3RhdHVzO1xcbihmdW5jdGlvbiAoQ29udGVudEl0ZW1TdGF0dXMpIHtcXG4gICAgQ29udGVudEl0ZW1TdGF0dXNbXFxcIklkbGVcXFwiXSA9IFxcXCJpZGxlXFxcIjtcXG4gICAgQ29udGVudEl0ZW1TdGF0dXNbXFxcIkxvYWRpbmdcXFwiXSA9IFxcXCJsb2FkaW5nXFxcIjtcXG4gICAgQ29udGVudEl0ZW1TdGF0dXNbXFxcIkxvYWRlZFxcXCJdID0gXFxcImxvYWRlZFxcXCI7XFxuICAgIENvbnRlbnRJdGVtU3RhdHVzW1xcXCJQcm9jZXNzaW5nXFxcIl0gPSBcXFwicHJvY2Vzc2luZ1xcXCI7XFxuICAgIENvbnRlbnRJdGVtU3RhdHVzW1xcXCJQcm9jZXNzZWRcXFwiXSA9IFxcXCJwcm9jZXNzZWRcXFwiO1xcbn0pKENvbnRlbnRJdGVtU3RhdHVzID0gZXhwb3J0cy5Db250ZW50SXRlbVN0YXR1cyB8fCAoZXhwb3J0cy5Db250ZW50SXRlbVN0YXR1cyA9IHt9KSk7XFxuY29uc3QgZGVmYXVsdENvbnRlbnRMb2FkZXJzID0ge1xcbiAgICBbQ29udGVudEl0ZW1UeXBlLkpTT05dOiBjb250ZW50X2xvYWRlcnNfMS5KU09OTG9hZGVyLFxcbiAgICBbQ29udGVudEl0ZW1UeXBlLkZvbnRdOiBjb250ZW50X2xvYWRlcnNfMS5Gb250TG9hZGVyLFxcbiAgICBbQ29udGVudEl0ZW1UeXBlLkltYWdlXTogY29udGVudF9sb2FkZXJzXzEuSW1hZ2VMb2FkZXIsXFxuICAgIFtDb250ZW50SXRlbVR5cGUuQXVkaW9dOiBjb250ZW50X2xvYWRlcnNfMS5BdWRpb0xvYWRlcixcXG4gICAgW0NvbnRlbnRJdGVtVHlwZS5UZXh0XTogY29udGVudF9sb2FkZXJzXzEuVGV4dExvYWRlcixcXG59O1xcbmNvbnN0IGRlZmF1bHRDb250ZW50UHJvY2Vzc29ycyA9IHtcXG4gICAgaW1hZ2VOYW1lOiBjb250ZW50X3Byb2Nlc3NvcnNfMS5JbWFnZU5hbWVQcm9jZXNzb3IsXFxufTtcXG5hc3luYyBmdW5jdGlvbiBzbGVlcChtcykge1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XFxufVxcbmZ1bmN0aW9uIGNsYW1wKGEsIG1pbiA9IDAsIG1heCA9IDEpIHtcXG4gICAgcmV0dXJuIGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcbn1cXG5mdW5jdGlvbiByYW5kb21CZXR3ZWVuKG1pbiwgbWF4KSB7XFxuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XFxufVxcbmNvbnN0IE1JTl9TTEVFUF9USU1FID0gMTAwMDtcXG5jb25zdCBNQVhfU0xFRVBfVElNRSA9IDMwMDA7XFxuY2xhc3MgQ29udGVudE1hbmFnZXIge1xcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRlbnRMaXN0ID0gW107XFxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmVzcyA9IDA7XFxuICAgICAgICB0aGlzLmN1cnJlbnRUb3RhbFByb2dyZXNzID0gMDtcXG4gICAgICAgIHRoaXMuY29udGVudCA9IHt9O1xcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDb250ZW50TWFuYWdlclN0YXR1cy5JZGxlO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ29udGVudE1hbmFnZXIuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7XFxuICAgICAgICAgICAgbG9hZGVyczoge1xcbiAgICAgICAgICAgICAgICAuLi5Db250ZW50TWFuYWdlci5kZWZhdWx0T3B0aW9ucy5sb2FkZXJzLFxcbiAgICAgICAgICAgICAgICAuLi4oKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvYWRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KSxcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHByb2Nlc3NvcnM6IHtcXG4gICAgICAgICAgICAgICAgLi4uKChfYiA9IENvbnRlbnRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLnByb2Nlc3NvcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KSxcXG4gICAgICAgICAgICAgICAgLi4uKChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcm9jZXNzb3JzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSksXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBjb250ZW50IG1hbmFnZXIgYW5kIHByb3ZpZGUgY29uZmlndXJhdGlvbiBvcHRpb25zXFxuICAgICAqL1xcbiAgICBzdGF0aWMgaW5pdGlhbGlzZShvcHRpb25zKSB7XFxuICAgICAgICBpZiAoQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBtYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIENvbnRlbnRNYW5hZ2VyLmluc3RhbmNlID0gbmV3IENvbnRlbnRNYW5hZ2VyKG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBkaXNwb3NlKCkge1xcbiAgICAgICAgaWYgKENvbnRlbnRNYW5hZ2VyLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnQgbWFuYWdlciBub3QgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGRlbGV0ZSBDb250ZW50TWFuYWdlci5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XFxuICAgICAgICBpZiAoQ29udGVudE1hbmFnZXIuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCBtYW5hZ2VyIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIENvbnRlbnRNYW5hZ2VyLmluc3RhbmNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDdXJyZW50IGxvYWRpbmcgcHJvZ3Jlc3MsIHJlcHJlc2VudGVkIGFzIGEgdW5pdCBzY2FsYXIgWzAsIDFdXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IHByb2dyZXNzKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBDb250ZW50TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmdldFByb2dyZXNzKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEN1cnJlbnQgY29udGVudCBtYW5hZ2VyIHN0YXR1c1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGdldCBzdGF0dXMoKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IENvbnRlbnRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhdHVzO1xcbiAgICB9XFxuICAgIGdldFByb2dyZXNzKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRDb250ZW50TGlzdC5sZW5ndGggfHwgdGhpcy5jdXJyZW50VG90YWxQcm9ncmVzcyA9PT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGNsYW1wKHRoaXMuY3VycmVudFByb2dyZXNzIC8gdGhpcy5jdXJyZW50VG90YWxQcm9ncmVzcyk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIExvYWQgY29udGVudCBpdGVtc1xcbiAgICAgKlxcbiAgICAgKiBFeGlzdGluZyBjb250ZW50IGl0ZW1zIHdpbGwgYmUgcmV0YWluZWQsIGFuZCBhbnkgY29udGVudCBpdGVtcyB3aGljaFxcbiAgICAgKiBhbHJlYWR5IGV4aXN0IHdpbGwgYmUgcmUtbG9hZGVkXFxuICAgICAqL1xcbiAgICBzdGF0aWMgYXN5bmMgbG9hZChpdGVtcykge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcXG4gICAgICAgIGlmICghaXRlbXMgfHwgaXRlbXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBDb250ZW50TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5vcHRpb25zLmxvYWRlcnMgfHxcXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhpbnN0YW5jZS5vcHRpb25zLmxvYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29udGVudCBsb2FkZXJzIGRlZmluZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGluc3RhbmNlLmN1cnJlbnRDb250ZW50TGlzdCA9IGl0ZW1zO1xcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IHRhc2tzIHdlIG5lZWQgdG8gcGVyZm9ybVxcbiAgICAgICAgY29uc3QgY291bnRUb3RhbFRvTG9hZCA9IGl0ZW1zLmxlbmd0aDtcXG4gICAgICAgIGNvbnN0IGNvdW50VG90YWxUb1Byb2Nlc3MgPSBpdGVtcy5yZWR1Y2UoKGEsIGMpID0+IHsgdmFyIF9hOyByZXR1cm4gYSArICgoX2EgPSBjLnByb2Nlc3NvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5sZW5ndGg7IH0sIDApO1xcbiAgICAgICAgaW5zdGFuY2UuY3VycmVudFByb2dyZXNzID0gMDtcXG4gICAgICAgIGluc3RhbmNlLmN1cnJlbnRUb3RhbFByb2dyZXNzID0gY291bnRUb3RhbFRvTG9hZCArIGNvdW50VG90YWxUb1Byb2Nlc3M7XFxuICAgICAgICAvLyBMb2FkIGl0ZW1zXFxuICAgICAgICBpbnN0YW5jZS5zdGF0dXMgPSBDb250ZW50TWFuYWdlclN0YXR1cy5Mb2FkaW5nO1xcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XFxuICAgICAgICAgICAgaWYgKCEoaXRlbS50eXBlIGluIGluc3RhbmNlLm9wdGlvbnMubG9hZGVycykpIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb250ZW50IGxvYWRlciBkZWZpbmVkIGZvciB0eXBlIFxcXCIke2l0ZW0udHlwZX1cXFwiYCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5vcHRpb25zLnNpbXVsYXRlU2xvd0xvYWRpbmcpIHtcXG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmFuZG9tQmV0d2VlbigoX2EgPSBpbnN0YW5jZS5vcHRpb25zLnNsb3dMb2FkaW5nVGltZU1pbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTUlOX1NMRUVQX1RJTUUsIChfYiA9IGluc3RhbmNlLm9wdGlvbnMuc2xvd0xvYWRpbmdUaW1lTWF4KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBNQVhfU0xFRVBfVElNRSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBjb250ZW50SXRlbSA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxcbiAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgIHN0YXR1czogQ29udGVudEl0ZW1TdGF0dXMuTG9hZGluZyxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbnRlbnRbaXRlbS5uYW1lXSA9IGNvbnRlbnRJdGVtO1xcbiAgICAgICAgICAgIGNvbnRlbnRJdGVtLmNvbnRlbnQgPSBhd2FpdCBpbnN0YW5jZS5vcHRpb25zLmxvYWRlcnNbaXRlbS50eXBlXSguLi5pdGVtLmFyZ3MpO1xcbiAgICAgICAgICAgIGNvbnRlbnRJdGVtLnN0YXR1cyA9IENvbnRlbnRJdGVtU3RhdHVzLkxvYWRlZDtcXG4gICAgICAgICAgICBpbnN0YW5jZS5jdXJyZW50UHJvZ3Jlc3MrKztcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIFByb2Nlc3MgaXRlbXNcXG4gICAgICAgIGluc3RhbmNlLnN0YXR1cyA9IENvbnRlbnRNYW5hZ2VyU3RhdHVzLlByb2Nlc3Npbmc7XFxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJvY2Vzc29ycyB8fCBpdGVtLnByb2Nlc3NvcnMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLm9wdGlvbnMucHJvY2Vzc29ycyB8fFxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhpbnN0YW5jZS5vcHRpb25zLnByb2Nlc3NvcnMpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgcHJvY2Vzc29ycyBkZWZpbmVkJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRJdGVtID0gaW5zdGFuY2UuY29udGVudFtpdGVtLm5hbWVdO1xcbiAgICAgICAgICAgIGlmICghY29udGVudEl0ZW0pIHtcXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcG9pbnQ7IHRoZSBpdGVtIHdpbGwgaGF2ZSBiZWVuIGxvYWRlZFxcbiAgICAgICAgICAgICAgICAvLyBhbmQgYWRkZWQgdG8gdGhlIGluc3RhbmNlJ3MgY29udGVudCBkaWN0aW9uYXJ5Li4uIGJ1dCBqdXN0IGluIGNhc2VcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBpdGVtIHdpdGggbmFtZSBcXFwiJHtpdGVtLm5hbWV9XFxcImApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2Uub3B0aW9ucy5zaW11bGF0ZVNsb3dQcm9jZXNzaW5nKSB7XFxuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHJhbmRvbUJldHdlZW4oKF9jID0gaW5zdGFuY2Uub3B0aW9ucy5zbG93UHJvY2Vzc2luZ1RpbWVNaW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IE1JTl9TTEVFUF9USU1FLCAoX2QgPSBpbnN0YW5jZS5vcHRpb25zLnNsb3dQcm9jZXNzaW5nVGltZU1heCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogTUFYX1NMRUVQX1RJTUUpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uc3RhdHVzID0gQ29udGVudEl0ZW1TdGF0dXMuUHJvY2Vzc2luZztcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBpdGVtLnByb2Nlc3NvcnMpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCEocHJvY2Vzc29yLm5hbWUgaW4gaW5zdGFuY2Uub3B0aW9ucy5wcm9jZXNzb3JzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb250ZW50IHByb2Nlc3NvciBkZWZpbmVkIHdpdGggbmFtZSBcXFwiJHtwcm9jZXNzb3IubmFtZX1cXFwiYCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uub3B0aW9ucy5wcm9jZXNzb3JzW3Byb2Nlc3Nvci5uYW1lXShpbnN0YW5jZS5jb250ZW50LCBjb250ZW50SXRlbSwgLi4uKChfZSA9IHByb2Nlc3Nvci5hcmdzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBbXSkpO1xcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jdXJyZW50UHJvZ3Jlc3MrKztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29udGVudEl0ZW0uc3RhdHVzID0gQ29udGVudEl0ZW1TdGF0dXMuUHJvY2Vzc2VkO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5zdGFuY2Uuc3RhdHVzID0gQ29udGVudE1hbmFnZXJTdGF0dXMuUmVhZHk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFJldHJpZXZlIGEgY29udGVudCBpdGVtIGJ5IG5hbWVcXG4gICAgICovXFxuICAgIHN0YXRpYyBnZXQobmFtZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBDb250ZW50TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaWYgKCEobmFtZSBpbiBpbnN0YW5jZS5jb250ZW50KSkge1xcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5vcHRpb25zLnRocm93T25Ob3RGb3VuZCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRlbnQgaXRlbSBcXFwiJHtuYW1lfVxcXCIgbm90IGZvdW5kYCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuY29udGVudFtuYW1lXS5jb250ZW50O1xcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IENvbnRlbnRNYW5hZ2VyO1xcbkNvbnRlbnRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zID0ge1xcbiAgICBsb2FkZXJzOiBkZWZhdWx0Q29udGVudExvYWRlcnMsXFxuICAgIHByb2Nlc3NvcnM6IGRlZmF1bHRDb250ZW50UHJvY2Vzc29ycyxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlci8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICovXFxuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xcblxcbi8qKlxcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcXG4gKi9cXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBpbnRlcnBvbGF0aW9uQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtpbnRlcnBvbGF0aW9uQ2FsbGJhY2t9IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbiA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayB0aW1lc0NhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7dGltZXNDYWxsYmFja30gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIDIgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xcblxcbi8qKlxcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgbGVycCxcXG4gICAgdW5sZXJwLFxcbiAgICBibGVycCxcXG4gICAgcmVtYXAsXFxuICAgIHNtb290aHN0ZXAsXFxuICAgIHJhZGlhbnMsXFxuICAgIGRlZ3JlZXMsXFxuICAgIHJhbmRvbUJldHdlZW4sXFxuICAgIHJhbmRvbUludEJldHdlZW4sXFxuICAgIGNsdFJhbmRvbSxcXG4gICAgY2x0UmFuZG9tSW50LFxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcXG4gICAgbGVycEFycmF5LFxcbiAgICBkb3QsXFxuICAgIGZhY3RvcmlhbCxcXG4gICAgcGVybXV0YXRpb24sXFxuICAgIGNvbWJpbmF0aW9uLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIGNodW5rLFxcbiAgICBzaHVmZmxlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvZGVidWcvLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwiY29uc3QgeyB0aW1lcywgY2h1bmssIGRvdCB9ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXFxcIik7XFxuXFxuLyoqXFxuICogQG92ZXJ2aWV3IEEgbGlicmFyeSBvZiB1c2VmdWwgZnVuY3Rpb25zXFxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cXG4gKi9cXG5cXG4vKipcXG4gKiBBIDJkIHZlY3RvclxcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlY1xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgdmVjdG9yXFxuICogQHBhcmFtIHtudW1iZXJ8dmVjfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcXG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjfSBBIG5ldyB2ZWN0b3JcXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5WYXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cXG4gKiBsZXQgYSA9IHZlYygzLCAyKTsgIC8vICgzLCAyKVxcbiAqIGxldCBiID0gdmVjKDQpOyAgICAgLy8gKDQsIDQpXFxuICogbGV0IGMgPSB2ZWMoYSk7ICAgICAvLyAoMywgMilcXG4gKiBsZXQgZCA9IHZlYygpOyAgICAgIC8vICgwLCAwKVxcbiAqL1xcbmNvbnN0IHZlYyA9ICh4LCB5KSA9PiAoIXggJiYgIXkgP1xcbiAgeyB4OiAwLCB5OiAwIH0gOiAodHlwZW9mIHggPT09ICdvYmplY3QnID9cXG4gICAgeyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfSA6ICh5ID09PSBudWxsIHx8IHkgPT09IHVuZGVmaW5lZCA/XFxuICAgICAgeyB4OiB4LCB5OiB4IH0gOiB7IHg6IHgsIHk6IHkgfSlcXG4gIClcXG4pO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxcbiAqL1xcbnZlYy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqIEByZXR1cm4ge3ZlY30gQSB1bml0IHZlY3RvciAoMSwgMClcXG4gKi9cXG52ZWMudXggPSAoKSA9PiB2ZWMoMSwgMCk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxcbiAqL1xcbnZlYy51eSA9ICgpID0+IHZlYygwLCAxKTtcXG5cXG4vKipcXG4gKiBBZGQgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgKyBiXFxuICovXFxudmVjLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyBiLngsIHk6IGEueSArIGIueSB9KTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgKiBiXFxuICovXFxudmVjLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiBiLCB5OiBhLnkgKiBiIH0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7dmVjfSBhIC0gYlxcbiAqL1xcbnZlYy5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gYi54LCB5OiBhLnkgLSBiLnkgfSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XFxuICovXFxudmVjLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge3ZlY30gXmFcXG4gKi9cXG52ZWMubm9yID0gYSA9PiB7XFxuICBsZXQgbGVuID0gdmVjLmxlbihhKTtcXG4gIHJldHVybiBsZW4gPyB7IHg6IGEueCAvIGxlbiwgeTogYS55IC8gbGVuIH0gOiB2ZWMoKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEBwYXJhbSB7dmVjfSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxudmVjLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XFxuXFxuLyoqXFxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFuc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xcbiAqIEByZXR1cm4ge3ZlY30gQSByb3RhdGVkIHZlY3RvclxcbiAqL1xcbnZlYy5yb3QgPSAoYSwgcikgPT4ge1xcbiAgbGV0IHMgPSBNYXRoLnNpbihyKSxcXG4gICAgYyA9IE1hdGguY29zKHIpO1xcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XFxufVxcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbnZlYy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXFxuICovXFxudmVjLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XFxuXFxuLyoqXFxuICogQ29weSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxcbiAqIEByZXR1cm4ge3ZlY30gQSBjb3B5IG9mIHZlY3RvciBhXFxuICovXFxudmVjLmNweSA9IGEgPT4gdmVjKGEpO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvclxcbiAqIEBjYWxsYmFjayB2ZWN0b3JNYXBDYWxsYmFja1xcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXFxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN0b3JNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXFxuICogQHJldHVybiB7dmVjfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxudmVjLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XFxuXFxuLyoqXFxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXFxuICovXFxudmVjLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xcblxcbi8qKlxcbiAqIEEgbWF0cml4XFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXhcXG4gKiBAcGFyYW0ge251bWJlcn0gW209NF0gVGhlIG51bWJlciBvZiByb3dzXFxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VudHJpZXM9W11dIE1hdHJpeCB2YWx1ZXMgaW4gcmVhZGluZyBvcmRlclxcbiAqIEByZXR1cm4ge21hdH0gQSBuZXcgbWF0cml4XFxuICovXFxuY29uc3QgbWF0ID0gKG0gPSA0LCBuID0gNCwgZW50cmllcyA9IFtdKSA9PiAoe1xcbiAgbSwgbixcXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcXG59KTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBtYXRyaXhcXG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxcbiAqL1xcbm1hdC5pZGVudGl0eSA9IG4gPT4gbWF0KG4sIG4sIEFycmF5KG4gKiBuKS5maWxsKDApLm1hcCgodiwgaSkgPT4gKyhNYXRoLmZsb29yKGkgLyBuKSA9PT0gaSAlIG4pKSk7XFxuXFxuLyoqXFxuICogR2V0IGFuIGVudHJ5IGZyb20gYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcXG4gKi9cXG5tYXQuZ2V0ID0gKGEsIGksIGopID0+IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl07XFxuXFxuLyoqXFxuICogU2V0IGFuIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5zZXQgPSAoYSwgaSwgaiwgdikgPT4geyBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dID0gdjsgfTtcXG5cXG4vKipcXG4gKiBHZXQgYSByb3cgZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIHJvdyBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSb3cgbSBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LnJvdyA9IChhLCBtKSA9PiB7XFxuICBjb25zdCBzID0gKG0gLSAxKSAqIGEubjtcXG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgYSBjb2x1bW4gZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDb2x1bW4gbiBmcm9tIG1hdHJpeCBhXFxuICovXFxubWF0LmNvbCA9IChhLCBuKSA9PiB0aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XFxuXFxuLyoqXFxuICogQWRkIG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcXG4gKi9cXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcXG4gKi9cXG5tYXQuc3ViID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgLSBiLmVudHJpZXNbaV0pO1xcblxcbi8qKlxcbiAqIE11bHRpcGx5IG1hdHJpY2VzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cmljZXMgY2Fubm90IGJlIG11bHRpcGxpZWRcXG4gKi9cXG5tYXQubXVsID0gKGEsIGIpID0+IHtcXG4gIGlmIChhLm4gIT09IGIubSkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IHJlc3VsdCA9IG1hdChhLm0sIGIubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQocmVzdWx0LCBpLCBqLCBkb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuLyoqXFxuICogU2NhbGUgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXFxuICogQHJldHVybiB7bWF0fSBhICogYlxcbiAqL1xcbm1hdC5zY2FsZSA9IChhLCBiKSA9PiBtYXQubWFwKGEsIHYgPT4gdiAqIGIpO1xcblxcbi8qKlxcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gdHJhbnNwb3NlXFxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XFxuICovXFxubWF0LnRyYW5zID0gYSA9PiBtYXQoYS5uLCBhLm0sIHRpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubWlub3IgPSAoYSwgaSwgaikgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZW50cmllcyA9IFtdO1xcbiAgZm9yIChsZXQgaWkgPSAxOyBpaSA8PSBhLm07IGlpKyspIHtcXG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XFxuICAgIGZvciAobGV0IGpqID0gMTsgamogPD0gYS5uOyBqaisrKSB7XFxuICAgICAgaWYgKGpqID09PSBqKSB7IGNvbnRpbnVlOyB9XFxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gfGF8IG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5kZXQgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGlmIChhLm0gPT09IDEpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcXG4gIH1cXG4gIGlmIChhLm0gPT09IDIpIHtcXG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcXG4gIH1cXG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcXG4gICAgdG90YWwgKz0gc2lnbiAqIGEuZW50cmllc1tqIC0gMV0gKiBtYXQuZGV0KG1hdC5taW5vcihhLCAxLCBqKSk7XFxuICAgIHNpZ24gKj0gLTE7XFxuICB9XFxuICByZXR1cm4gdG90YWw7XFxufTtcXG5cXG4vKipcXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcXG4gKi9cXG5tYXQubm9yID0gYSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBkID0gbWF0LmRldChhKTtcXG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggZnJvbSB3aGljaCB0byBnZXQgdGhlIGFkanVnYXRlXFxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxcbiAqL1xcbm1hdC5hZGogPSBhID0+IHtcXG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XFxuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xcbiAgICB9XFxuICB9XFxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcXG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxcbiAqL1xcbm1hdC5pbnYgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgaWYgKGQgPT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XFxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtYXRyaWNlcyBhIGFuZCBiIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZVxcbiAqL1xcbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xcblxcbi8qKlxcbiAqIENvcHkgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvcHlcXG4gKiBAcmV0dXJuIHttYXR9IEEgY29weSBvZiBtYXRyaXggYVxcbiAqL1xcbm1hdC5jcHkgPSBhID0+IG1hdChhLm0sIGEubiwgWy4uLmEuZW50cmllc10pO1xcblxcbi8qKlxcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4XFxuICogQGNhbGxiYWNrIG1hdHJpeE1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgZW50cnkgaW5kZXhcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIGFycmF5IG9mIG1hdHJpeCBlbnRyaWVzXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XFxuICovXFxuXFxuLyoqXFxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXggYW5kIGJ1aWxkIGEgbmV3IG1hdHJpeCBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gTWF0cml4IGEgbWFwcGVkIHRocm91Z2ggZlxcbiAqL1xcbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW21zPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciBjb2x1bW5zXFxuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxcXG4nXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3Igcm93c1xcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxcbiAqL1xcbm1hdC5zdHIgPSAoYSwgbXMgPSAnLCAnLCBucyA9ICdcXFxcbicpID0+IGNodW5rKGEuZW50cmllcywgYS5uKS5tYXAociA9PiByLmpvaW4obXMpKS5qb2luKG5zKTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IHZlYywgbWF0IH07XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2RlYnVnLy4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG5jbGFzcyBEZWJ1ZyB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdFZhbHVlKSB7XFxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5kZWZhdWx0T3B0aW9ucy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMuZGVmYXVsdFZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdENoYXJ0KSB7XFxuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Q2hhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5kZWZhdWx0T3B0aW9ucy5kZWZhdWx0Q2hhcnQsIG9wdGlvbnMuZGVmYXVsdENoYXJ0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVmYXVsdE1hcmtlcikge1xcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdE1hcmtlciA9IE9iamVjdC5hc3NpZ24oe30sIERlYnVnLmRlZmF1bHRPcHRpb25zLmRlZmF1bHRNYXJrZXIsIG9wdGlvbnMuZGVmYXVsdE1hcmtlcik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlZmF1bHRCb3JkZXIpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRCb3JkZXIgPSBPYmplY3QuYXNzaWduKHt9LCBEZWJ1Zy5kZWZhdWx0T3B0aW9ucy5kZWZhdWx0Qm9yZGVyLCBvcHRpb25zLmRlZmF1bHRCb3JkZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRGVidWcuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IE1hcCgpO1xcbiAgICAgICAgdGhpcy5jaGFydHMgPSBuZXcgTWFwKCk7XFxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBuZXcgTWFwKCk7XFxuICAgICAgICB0aGlzLmJvcmRlcnMgPSBuZXcgTWFwKCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGRlYnVnIHJlbmRlcmVyIGZvciBkaXNwbGF5aW5nIHZhbHVlcyBhbmQgbWFya2Vyc1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGluaXRpYWxpc2Uob3B0aW9ucyA9IHt9KSB7XFxuICAgICAgICBpZiAoRGVidWcuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVidWcgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgRGVidWcuaW5zdGFuY2UgPSBuZXcgRGVidWcob3B0aW9ucyk7XFxuICAgIH1cXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xcbiAgICAgICAgaWYgKERlYnVnLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYnVnIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIERlYnVnLmluc3RhbmNlO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTaG93IGEgZGVidWcgdmFsdWVcXG4gICAgICovXFxuICAgIHN0YXRpYyB2YWx1ZShsYWJlbCwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnZhbHVlcy5zZXQobGFiZWwsIE9iamVjdC5hc3NpZ24oe30sIGluc3RhbmNlLm9wdGlvbnMuZGVmYXVsdFZhbHVlLCAoX2EgPSBpbnN0YW5jZS52YWx1ZXMuZ2V0KGxhYmVsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7IGxhYmVsLCB2YWx1ZSB9KSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBkZWJ1ZyBjaGFydFxcbiAgICAgKi9cXG4gICAgc3RhdGljIGNoYXJ0KGxhYmVsLCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgICAgdmFyIF9hLCBfYjtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFydCA9IGluc3RhbmNlLmNoYXJ0cy5nZXQobGFiZWwpO1xcbiAgICAgICAgaW5zdGFuY2UuY2hhcnRzLnNldChsYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucy5kZWZhdWx0Q2hhcnQsIGN1cnJlbnRDaGFydCAhPT0gbnVsbCAmJiBjdXJyZW50Q2hhcnQgIT09IHZvaWQgMCA/IGN1cnJlbnRDaGFydCA6IHt9LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwge1xcbiAgICAgICAgICAgIGxhYmVsLFxcbiAgICAgICAgICAgIHZhbHVlczogWy4uLihfYSA9IGN1cnJlbnRDaGFydCA9PT0gbnVsbCB8fCBjdXJyZW50Q2hhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRDaGFydC52YWx1ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCB2YWx1ZV0uc2xpY2UoLSgoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsdWVCdWZmZXJTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRDaGFydC52YWx1ZUJ1ZmZlclNpemUpKSxcXG4gICAgICAgIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIGEgZGVidWcgY2hhcnRcXG4gICAgICovXFxuICAgIHN0YXRpYyByZW1vdmVDaGFydChsYWJlbCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UuY2hhcnRzLmRlbGV0ZShsYWJlbCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIFNob3cgYSBtYXJrZXIgaW4gd29ybGQgb3Igc2NyZWVuIHNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbWFya2VyKGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24sIG9wdGlvbnMpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gRGVidWcuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuc2V0KGxhYmVsLCBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZS5vcHRpb25zLmRlZmF1bHRNYXJrZXIsIChfYSA9IGluc3RhbmNlLm1hcmtlcnMuZ2V0KGxhYmVsKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCB7IGxhYmVsLCB2YWx1ZSwgcG9zaXRpb24gfSkpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTaG93IGEgYm9yZGVyIGluIHdvcmxkIG9yIHNjcmVlbiBzcGFjZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGJvcmRlcihsYWJlbCwgdmFsdWUsIHBvc2l0aW9uLCBvcHRpb25zKSB7XFxuICAgICAgICB2YXIgX2E7XFxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib3JkZXJTaGFwZSkgPT09ICdjaXJjbGUnICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBib3JkZXIgaWYgaXQncyBjaXJjdWxhciBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJhZGl1c1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvcmRlclNoYXBlKSAhPT0gJ2NpcmNsZScgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaXplKSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBib3JkZXIgaWYgaXQncyByZWN0YW5ndWxhciAoZGVmYXVsdCBpcyByZWN0YW5ndWxhcikgYnV0XFxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHNpemVcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpbnN0YW5jZS5ib3JkZXJzLnNldChsYWJlbCwgT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucy5kZWZhdWx0Qm9yZGVyLCAoX2EgPSBpbnN0YW5jZS5ib3JkZXJzLmdldChsYWJlbCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgeyBsYWJlbCwgdmFsdWUsIHBvc2l0aW9uIH0pKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVuZGVyIHRoZSBkZWJ1ZyB2YWx1ZXMgYW5kIG1hcmtlcnMgb250byBhIGNhbnZhc1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGRyYXcoY29udGV4dCwgdGFncywgY2xlYXIgPSB0cnVlKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IERlYnVnLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBEcmF3IHdvcmxkLXNwYWNlIG1hcmtlcnMgJiBib3JkZXJzXFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGluc3RhbmNlLm1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IG1hcmtlci50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobWFya2VyLnNwYWNlID09PSAnd29ybGQnKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdNYXJrZXIoY29udGV4dCwgbWFya2VyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuZm9yRWFjaChib3JkZXIgPT4ge1xcbiAgICAgICAgICAgIHZhciBfYTtcXG4gICAgICAgICAgICBpZiAodGFncyAmJiAhKChfYSA9IGJvcmRlci50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYm9yZGVyLnNwYWNlID09PSAnd29ybGQnKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICAgICAgLy8gRHJhdyB2YWx1ZXMsIGNoYXJ0cyBhbmQgc2NyZWVuLXNwYWNlIG1hcmtlcnMgJiBib3JkZXJzXFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xcbiAgICAgICAgbGV0IHBvc2l0aW9uO1xcbiAgICAgICAgbGV0IGxlZnRZID0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW47XFxuICAgICAgICBsZXQgcmlnaHRZID0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW47XFxuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gKGluc3RhbmNlLm9wdGlvbnMubGluZUhlaWdodCArXFxuICAgICAgICAgICAgaW5zdGFuY2Uub3B0aW9ucy5wYWRkaW5nICogMik7XFxuICAgICAgICBpbnN0YW5jZS52YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gdmFsdWUudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUodGFnID0+IHRhZ3MuaW5jbHVkZXModGFnKSkpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZS5hbGlnbikge1xcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKDAsIHZlY18xLnZlYykoaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIGxlZnRZKTtcXG4gICAgICAgICAgICAgICAgICAgIGxlZnRZICs9IGxpbmVIZWlnaHQgKyBpbnN0YW5jZS5vcHRpb25zLmxpbmVNYXJnaW47XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKShjb250ZXh0LmNhbnZhcy5jbGllbnRXaWR0aCAtIGluc3RhbmNlLm9wdGlvbnMubWFyZ2luLCByaWdodFkpO1xcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRZICs9IGxpbmVIZWlnaHQgKyBpbnN0YW5jZS5vcHRpb25zLmxpbmVNYXJnaW47XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW5zdGFuY2UuZHJhd0xhYmVsKGNvbnRleHQsIERlYnVnLnByZXBhcmVMYWJlbCgoX2IgPSB2YWx1ZS5sYWJlbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsIChfYyA9IHZhbHVlLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgdmFsdWUuc2hvd0xhYmVsLCB0cnVlKSwgcG9zaXRpb24sIHZhbHVlLmFsaWduLCAoX2QgPSB2YWx1ZS5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBpbnN0YW5jZS5vcHRpb25zLnBhZGRpbmcsIChfZSA9IHZhbHVlLmZvbnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGluc3RhbmNlLm9wdGlvbnMuZm9udCwgKF9mID0gdmFsdWUuZm9yZWdyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogaW5zdGFuY2Uub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3VyLCAoX2cgPSB2YWx1ZS5iYWNrZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBpbnN0YW5jZS5vcHRpb25zLmJhY2tncm91bmRDb2xvdXIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpbnN0YW5jZS5jaGFydHMuZm9yRWFjaChjaGFydCA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSBjaGFydC50YWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZSh0YWcgPT4gdGFncy5pbmNsdWRlcyh0YWcpKSkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJ0LmFsaWduKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjKShpbnN0YW5jZS5vcHRpb25zLm1hcmdpbiwgbGVmdFkpO1xcbiAgICAgICAgICAgICAgICAgICAgbGVmdFkgKz0gbGluZUhlaWdodCArIGluc3RhbmNlLm9wdGlvbnMubGluZU1hcmdpbjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMpKGNvbnRleHQuY2FudmFzLmNsaWVudFdpZHRoIC0gaW5zdGFuY2Uub3B0aW9ucy5tYXJnaW4sIHJpZ2h0WSk7XFxuICAgICAgICAgICAgICAgICAgICByaWdodFkgKz0gbGluZUhlaWdodCArIGluc3RhbmNlLm9wdGlvbnMubGluZU1hcmdpbjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnN0YW5jZS5kcmF3Q2hhcnQoY29udGV4dCwgRGVidWcucHJlcGFyZUxhYmVsKChfYiA9IGNoYXJ0LmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgJycsIGNoYXJ0LnNob3dMYWJlbCwgZmFsc2UpLCBwb3NpdGlvbiwgY2hhcnQuYWxpZ24sIChfYyA9IGNoYXJ0LnBhZGRpbmcpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGluc3RhbmNlLm9wdGlvbnMucGFkZGluZywgKF9kID0gY2hhcnQuZm9udCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogaW5zdGFuY2Uub3B0aW9ucy5mb250LCAoX2UgPSBjaGFydC5mb3JlZ3JvdW5kQ29sb3VyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBpbnN0YW5jZS5vcHRpb25zLmZvcmVncm91bmRDb2xvdXIsIChfZiA9IGNoYXJ0LmJhY2tncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGluc3RhbmNlLm9wdGlvbnMuYmFja2dyb3VuZENvbG91ciwgY2hhcnQuY2hhcnRCYWNrZ3JvdW5kQ29sb3VyLCBjaGFydC52YWx1ZXMsIGNoYXJ0LnZhbHVlQnVmZmVyU2l6ZSwgY2hhcnQudmFsdWVCdWZmZXJTdHJpZGUsIGNoYXJ0Lm1pblZhbHVlLCBjaGFydC5tYXhWYWx1ZSwgY2hhcnQuYmFyV2lkdGgsIGNoYXJ0LmJhckNvbG91cnMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpbnN0YW5jZS5tYXJrZXJzLmZvckVhY2gobWFya2VyID0+IHtcXG4gICAgICAgICAgICB2YXIgX2E7XFxuICAgICAgICAgICAgaWYgKHRhZ3MgJiYgISgoX2EgPSBtYXJrZXIudGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUodGFnID0+IHRhZ3MuaW5jbHVkZXModGFnKSkpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG1hcmtlci5zcGFjZSA9PT0gJ3NjcmVlbicpIHtcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZHJhd01hcmtlcihjb250ZXh0LCBtYXJrZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgaW5zdGFuY2UuYm9yZGVycy5mb3JFYWNoKGJvcmRlciA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hO1xcbiAgICAgICAgICAgIGlmICh0YWdzICYmICEoKF9hID0gYm9yZGVyLnRhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKHRhZyA9PiB0YWdzLmluY2x1ZGVzKHRhZykpKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChib3JkZXIuc3BhY2UgPT09ICdzY3JlZW4nKSB7XFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRyYXdCb3JkZXIoY29udGV4dCwgYm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICAgICAgLy8gQ2xlYXIgdmFsdWVzLCBtYXJrZXJzICYgYm9yZGVycyByZWFkeSBmb3IgbmV4dCBmcmFtZVxcbiAgICAgICAgaWYgKGNsZWFyKSB7XFxuICAgICAgICAgICAgaW5zdGFuY2UudmFsdWVzLmNsZWFyKCk7XFxuICAgICAgICAgICAgaW5zdGFuY2UubWFya2Vycy5jbGVhcigpO1xcbiAgICAgICAgICAgIGluc3RhbmNlLmJvcmRlcnMuY2xlYXIoKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBzdGF0aWMgY2xlYXIoY2xlYXJDaGFydHMgPSBmYWxzZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBEZWJ1Zy5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaW5zdGFuY2UudmFsdWVzLmNsZWFyKCk7XFxuICAgICAgICBpbnN0YW5jZS5tYXJrZXJzLmNsZWFyKCk7XFxuICAgICAgICBpZiAoY2xlYXJDaGFydHMpIHtcXG4gICAgICAgICAgICBpbnN0YW5jZS5jaGFydHMuY2xlYXIoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGluc3RhbmNlLmJvcmRlcnMuY2xlYXIoKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgcHJlcGFyZUxhYmVsKGxhYmVsLCB2YWx1ZSwgc2hvd0xhYmVsLCBzaG93VmFsdWUpIHtcXG4gICAgICAgIGNvbnN0IGFjdHVhbExhYmVsID0gKHNob3dMYWJlbCAmJiBsYWJlbCkgPyBsYWJlbCA6ICcnO1xcbiAgICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSAoISFzaG93VmFsdWUgJiYgdmFsdWUgIT09ICcnKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiAnJztcXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IChhY3R1YWxMYWJlbCAmJiBhY3R1YWxWYWx1ZSkgPyAnOiAnIDogJyc7XFxuICAgICAgICByZXR1cm4gYCR7YWN0dWFsTGFiZWx9JHtzZXBhcmF0b3J9JHthY3R1YWxWYWx1ZX1gO1xcbiAgICB9XFxuICAgIGRyYXdMYWJlbChjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbiwgYWxpZ24sIHBhZGRpbmcsIGZvbnQsIGZvcmVncm91bmRDb2xvdXIsIGJhY2tncm91bmRDb2xvdXIpIHtcXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XFxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kU2l6ZSA9IHtcXG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB4ID0gYWxpZ24gPT09ICdyaWdodCdcXG4gICAgICAgICAgICA/IChwb3NpdGlvbi54IC0gYmFja2dyb3VuZFNpemUud2lkdGgpXFxuICAgICAgICAgICAgOiBwb3NpdGlvbi54O1xcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggLSBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgYmFja2dyb3VuZFNpemUud2lkdGgsIGJhY2tncm91bmRTaXplLmhlaWdodCk7XFxuICAgICAgICAvLyBEcmF3IHRleHRcXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZm9yZWdyb3VuZENvbG91cjtcXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgcG9zaXRpb24ueSk7XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3Q2hhcnQoY29udGV4dCwgbGFiZWwsIHBvc2l0aW9uLCBhbGlnbiwgcGFkZGluZywgZm9udCwgZm9yZWdyb3VuZENvbG91ciwgYmFja2dyb3VuZENvbG91ciwgY2hhcnRCYWNrZ3JvdW5kQ29sb3VyLCB2YWx1ZXMsIHZhbHVlQnVmZmVyU2l6ZSwgdmFsdWVCdWZmZXJTdHJpZGUsIG1pblZhbHVlLCBtYXhWYWx1ZSwgYmFyV2lkdGgsIGJhckNvbG91cnMpIHtcXG4gICAgICAgIHZhciBfYSwgX2I7XFxuICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XFxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xcbiAgICAgICAgY29uc3QgY2hhcnRTaXplID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCAqIE1hdGguY2VpbCh2YWx1ZUJ1ZmZlclNpemUgLyBNYXRoLm1heCh2YWx1ZUJ1ZmZlclN0cmlkZSwgMSkpLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCBsYWJlbFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQsXFxuICAgICAgICB9O1xcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZFNpemUgPSB7XFxuICAgICAgICAgICAgd2lkdGg6IChsYWJlbFNpemUud2lkdGggK1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nICtcXG4gICAgICAgICAgICAgICAgY2hhcnRTaXplLndpZHRoKSArIHBhZGRpbmcgKiAyLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcHRpb25zLmxpbmVIZWlnaHQgKyBwYWRkaW5nICogMixcXG4gICAgICAgIH07XFxuICAgICAgICBjb25zdCB4ID0gYWxpZ24gPT09ICdyaWdodCdcXG4gICAgICAgICAgICA/IChwb3NpdGlvbi54IC0gYmFja2dyb3VuZFNpemUud2lkdGgpXFxuICAgICAgICAgICAgOiBwb3NpdGlvbi54O1xcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXFxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHggLSBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZywgYmFja2dyb3VuZFNpemUud2lkdGgsIGJhY2tncm91bmRTaXplLmhlaWdodCk7XFxuICAgICAgICAvLyBEcmF3IGxhYmVsXFxuICAgICAgICBpZiAobGFiZWwpIHtcXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZvcmVncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dChsYWJlbCwgeCwgcG9zaXRpb24ueSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBEcmF3IGNoYXJ0XFxuICAgICAgICBpZiAoY2hhcnRCYWNrZ3JvdW5kQ29sb3VyKSB7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjaGFydEJhY2tncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4ICsgcGFkZGluZyArIGxhYmVsU2l6ZS53aWR0aCArIHBhZGRpbmcsIHBvc2l0aW9uLnkgLSBwYWRkaW5nLCBjaGFydFNpemUud2lkdGgsIGNoYXJ0U2l6ZS5oZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBtYXhWYWx1ZSAtIG1pblZhbHVlO1xcbiAgICAgICAgY29uc3QgYmFyT2Zmc2V0ID0gKDAsIHZlY18xLnZlYykoeCArIHBhZGRpbmcgKyBsYWJlbFNpemUud2lkdGggKyBwYWRkaW5nLCBwb3NpdGlvbi55IC0gcGFkZGluZyk7XFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGguY2VpbCh2YWx1ZXMubGVuZ3RoIC8gTWF0aC5tYXgodmFsdWVCdWZmZXJTdHJpZGUsIDEpKTsgaSsrKSB7XFxuICAgICAgICAgICAgbGV0IHZhbHVlO1xcbiAgICAgICAgICAgIGlmICh2YWx1ZUJ1ZmZlclN0cmlkZSA8PSAxKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNcXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpICogdmFsdWVCdWZmZXJTdHJpZGUsIChpICsgMSkgKiB2YWx1ZUJ1ZmZlclN0cmlkZSlcXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHZhbHVlQnVmZmVyU3RyaWRlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjb25zdCBiYXJTaXplID0gKDAsIHZlY18xLnZlYykoYmFyV2lkdGgsIE1hdGgucm91bmQoY2hhcnRTaXplLmhlaWdodCAqICh2YWx1ZSAtIG1pblZhbHVlKSAvIHJhbmdlKSk7XFxuICAgICAgICAgICAgY29uc3QgYmFyUG9zaXRpb24gPSB2ZWNfMS52ZWMuYWRkKGJhck9mZnNldCwgKDAsIHZlY18xLnZlYykoKHZhbHVlcy5sZW5ndGggPCB2YWx1ZUJ1ZmZlclNpemVcXG4gICAgICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHZhbHVlQnVmZmVyU2l6ZSAtIHZhbHVlcy5sZW5ndGgpIC8gdmFsdWVCdWZmZXJTdHJpZGUpICogYmFyV2lkdGhcXG4gICAgICAgICAgICAgICAgOiAwKSArIGkgKiBiYXJXaWR0aCwgY2hhcnRTaXplLmhlaWdodCAtIGJhclNpemUueSkpO1xcbiAgICAgICAgICAgIGNvbnN0IGJhckNvbG91ciA9IChfYiA9IChiYXJDb2xvdXJzXFxuICAgICAgICAgICAgICAgID8gKF9hID0gWy4uLmJhckNvbG91cnNdLnJldmVyc2UoKS5maW5kKGMgPT4gdmFsdWVzW2ldID49IGMub2Zmc2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbG91clxcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZvcmVncm91bmRDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBiYXJDb2xvdXI7XFxuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChiYXJQb3NpdGlvbi54LCBiYXJQb3NpdGlvbi55LCBiYXJTaXplLngsIGJhclNpemUueSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgfVxcbiAgICBkcmF3TWFya2VyKGNvbnRleHQsIG1hcmtlcikge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IChfYSA9IG1hcmtlci5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIGlmIChtYXJrZXIuc2hvd0xhYmVsIHx8IG1hcmtlci5zaG93VmFsdWUpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gbWFya2VyLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gbWFya2VyLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgbWFya2VyLnNob3dMYWJlbCwgbWFya2VyLnNob3dWYWx1ZSksIHZlY18xLnZlYy5hZGQocG9zaXRpb24gIT09IG51bGwgJiYgcG9zaXRpb24gIT09IHZvaWQgMCA/IHBvc2l0aW9uIDogKDAsIHZlY18xLnZlYykoKSwgbWFya2VyLmxhYmVsT2Zmc2V0KSwgJ2xlZnQnLCAoX2QgPSBtYXJrZXIucGFkZGluZykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5vcHRpb25zLnBhZGRpbmcsIChfZSA9IG1hcmtlci5mb250KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLm9wdGlvbnMuZm9udCwgKF9mID0gbWFya2VyLmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3VyLCAoX2cgPSBtYXJrZXIuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvdXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG1hcmtlci5zaG93TWFya2VyKSB7XFxuICAgICAgICAgICAgaWYgKG1hcmtlci5tYXJrZXJJbWFnZSkge1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShtYXJrZXIubWFya2VySW1hZ2UsIHBvc2l0aW9uLnggLSBtYXJrZXIubWFya2VySW1hZ2Uud2lkdGggLyAyLCBwb3NpdGlvbi55IC0gbWFya2VyLm1hcmtlckltYWdlLmhlaWdodCAvIDIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBtYXJrZXIubWFya2VyTGluZVdpZHRoO1xcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29udGV4dC5maWxsU3R5bGUgPSBtYXJrZXIubWFya2VyQ29sb3VyO1xcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hcmtlci5tYXJrZXJTdHlsZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Q3Jvc3MoY29udGV4dCwgcG9zaXRpb24sIG1hcmtlci5tYXJrZXJTaXplKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BsdXMoY29udGV4dCwgcG9zaXRpb24sIG1hcmtlci5tYXJrZXJTaXplKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0RvdChjb250ZXh0LCBwb3NpdGlvbiwgbWFya2VyLm1hcmtlclNpemUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH1cXG4gICAgZHJhd0Nyb3NzKGNvbnRleHQsIHBvc2l0aW9uLCBzaXplKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29uc3QgaGFsZlNpemUgPSBzaXplIC8gMjtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc2l0aW9uLnggLSBoYWxmU2l6ZSwgcG9zaXRpb24ueSArIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLnggKyBoYWxmU2l6ZSwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgZHJhd1BsdXMoY29udGV4dCwgcG9zaXRpb24sIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb25zdCBoYWxmU2l6ZSA9IHNpemUgLyAyO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSAtIGhhbGZTaXplKTtcXG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkgKyBoYWxmU2l6ZSk7XFxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NpdGlvbi54IC0gaGFsZlNpemUsIHBvc2l0aW9uLnkpO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8ocG9zaXRpb24ueCArIGhhbGZTaXplLCBwb3NpdGlvbi55KTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG4gICAgZHJhd0RvdChjb250ZXh0LCBwb3NpdGlvbiwgc2l6ZSkge1xcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcXG4gICAgICAgIGNvbnRleHQuYXJjKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHNpemUgLyAyLCAwLCBNYXRoLlBJICogMik7XFxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgfVxcbiAgICBkcmF3Qm9yZGVyKGNvbnRleHQsIGJvcmRlcikge1xcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IChfYSA9IGJvcmRlci5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIHZlY18xLnZlYykoKTtcXG4gICAgICAgIGlmIChib3JkZXIuc2hvd0xhYmVsIHx8IGJvcmRlci5zaG93VmFsdWUpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdMYWJlbChjb250ZXh0LCBEZWJ1Zy5wcmVwYXJlTGFiZWwoKF9iID0gYm9yZGVyLmxhYmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJywgKF9jID0gYm9yZGVyLnZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJywgYm9yZGVyLnNob3dMYWJlbCwgYm9yZGVyLnNob3dWYWx1ZSksIHZlY18xLnZlYy5hZGQocG9zaXRpb24gIT09IG51bGwgJiYgcG9zaXRpb24gIT09IHZvaWQgMCA/IHBvc2l0aW9uIDogKDAsIHZlY18xLnZlYykoKSwgYm9yZGVyLmxhYmVsT2Zmc2V0KSwgJ2xlZnQnLCAoX2QgPSBib3JkZXIucGFkZGluZykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5vcHRpb25zLnBhZGRpbmcsIChfZSA9IGJvcmRlci5mb250KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLm9wdGlvbnMuZm9udCwgKF9mID0gYm9yZGVyLmZvcmVncm91bmRDb2xvdXIpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMub3B0aW9ucy5mb3JlZ3JvdW5kQ29sb3VyLCAoX2cgPSBib3JkZXIuYmFja2dyb3VuZENvbG91cikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5vcHRpb25zLmJhY2tncm91bmRDb2xvdXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGJvcmRlci5zaG93Qm9yZGVyKSB7XFxuICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXIuYm9yZGVyV2lkdGg7XFxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbnRleHQuZmlsbFN0eWxlID0gYm9yZGVyLmJvcmRlckNvbG91cjtcXG4gICAgICAgICAgICBzd2l0Y2ggKGJvcmRlci5ib3JkZXJTdHlsZSkge1xcbiAgICAgICAgICAgICAgICBjYXNlICdzb2xpZCc6XFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbYm9yZGVyLmJvcmRlckRhc2hTaXplLCBib3JkZXIuYm9yZGVyRGFzaFNpemVdKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbYm9yZGVyLmJvcmRlcldpZHRoLCBib3JkZXIuYm9yZGVyV2lkdGhdKTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzd2l0Y2ggKGJvcmRlci5ib3JkZXJTaGFwZSkge1xcbiAgICAgICAgICAgICAgICBjYXNlICdyZWN0YW5nbGUnOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlci5zaXplKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKGNvbnRleHQsIHBvc2l0aW9uLCBib3JkZXIuc2l6ZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgY2FzZSAnY2lyY2xlJzpcXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3JkZXIucmFkaXVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKGNvbnRleHQsIHBvc2l0aW9uLCBib3JkZXIucmFkaXVzKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xcbiAgICB9XFxuICAgIGRyYXdSZWN0YW5nbGUoY29udGV4dCwgcG9zaXRpb24sIHNpemUpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb250ZXh0LnJlY3QocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc2l6ZS54LCBzaXplLnkpO1xcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcXG4gICAgfVxcbiAgICBkcmF3Q2lyY2xlKGNvbnRleHQsIHBvc2l0aW9uLCByYWRpdXMpIHtcXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgICAgICBjb250ZXh0LmFyYyhwb3NpdGlvbi54LCBwb3NpdGlvbi55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XFxuICAgIH1cXG59XFxuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gRGVidWc7XFxuRGVidWcuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgIG1hcmdpbjogMTAsXFxuICAgIHBhZGRpbmc6IDQsXFxuICAgIGZvbnQ6ICcxMHB0IEx1Y2lkYSBDb25zb2xlLCBtb25vc3BhY2UnLFxcbiAgICBsaW5lSGVpZ2h0OiAxMixcXG4gICAgbGluZU1hcmdpbjogMCxcXG4gICAgZm9yZWdyb3VuZENvbG91cjogJyNmZmYnLFxcbiAgICBiYWNrZ3JvdW5kQ29sb3VyOiAnIzMzMycsXFxuICAgIGRlZmF1bHRWYWx1ZToge1xcbiAgICAgICAgYWxpZ246ICdsZWZ0JyxcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgfSxcXG4gICAgZGVmYXVsdENoYXJ0OiB7XFxuICAgICAgICB2YWx1ZXM6IFtdLFxcbiAgICAgICAgdmFsdWVCdWZmZXJTaXplOiA2MCxcXG4gICAgICAgIHZhbHVlQnVmZmVyU3RyaWRlOiAxLFxcbiAgICAgICAgbWluVmFsdWU6IDAsXFxuICAgICAgICBtYXhWYWx1ZTogMTAwLFxcbiAgICAgICAgYmFyV2lkdGg6IDIsXFxuICAgICAgICBhbGlnbjogJ2xlZnQnLFxcbiAgICAgICAgc2hvd0xhYmVsOiB0cnVlLFxcbiAgICAgICAgY2hhcnRCYWNrZ3JvdW5kQ29sb3VyOiAnIzIyMicsXFxuICAgIH0sXFxuICAgIGRlZmF1bHRNYXJrZXI6IHtcXG4gICAgICAgIHNob3dMYWJlbDogdHJ1ZSxcXG4gICAgICAgIHNob3dWYWx1ZTogdHJ1ZSxcXG4gICAgICAgIHNob3dNYXJrZXI6IHRydWUsXFxuICAgICAgICBtYXJrZXJTaXplOiA2LFxcbiAgICAgICAgbWFya2VyTGluZVdpZHRoOiAyLFxcbiAgICAgICAgbWFya2VyU3R5bGU6ICd4JyxcXG4gICAgICAgIG1hcmtlckNvbG91cjogJyNjY2MnLFxcbiAgICAgICAgc3BhY2U6ICd3b3JsZCcsXFxuICAgICAgICBsYWJlbE9mZnNldDogKDAsIHZlY18xLnZlYykoMTApLFxcbiAgICB9LFxcbiAgICBkZWZhdWx0Qm9yZGVyOiB7XFxuICAgICAgICBzaG93TGFiZWw6IHRydWUsXFxuICAgICAgICBzaG93VmFsdWU6IHRydWUsXFxuICAgICAgICBzaG93Qm9yZGVyOiB0cnVlLFxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXFxuICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcXG4gICAgICAgIGJvcmRlclNoYXBlOiAncmVjdGFuZ2xlJyxcXG4gICAgICAgIGJvcmRlckNvbG91cjogJyNjY2MnLFxcbiAgICAgICAgYm9yZGVyRGFzaFNpemU6IDUsXFxuICAgICAgICBzcGFjZTogJ3dvcmxkJyxcXG4gICAgICAgIGxhYmVsT2Zmc2V0OiAoMCwgdmVjXzEudmVjKSgxMCksXFxuICAgIH0sXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9AYmFzZW1lbnR1bml2ZXJzZS9kZWJ1Zy8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGNhbid0IGJlIGlubGluZWQgYmVjYXVzZSB0aGUgZXZhbCBkZXZ0b29sIGlzIHVzZWQuXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHR3byBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD1OdW1iZXIuRVBTSUxPTl0gVGhlIHByZWNpc2lvbiB2YWx1ZVxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbnVtYmVycyBhIGFuZCBiIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsXFxuICovXFxuY29uc3QgZmxvYXRFcXVhbHMgPSAoYSwgYiwgcCA9IE51bWJlci5FUFNJTE9OKSA9PiBNYXRoLmFicyhhIC0gYikgPCBwO1xcblxcbi8qKlxcbiAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXhcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbnVtYmVyIHRvIGNsYW1wXFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSB2YWx1ZVxcbiAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIG51bWJlclxcbiAqL1xcbmNvbnN0IGNsYW1wID0gKGEsIG1pbiA9IDAsIG1heCA9IDEpID0+IGEgPCBtaW4gPyBtaW4gOiAoYSA+IG1heCA/IG1heCA6IGEpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZnJhY3Rpb25hbCBwYXJ0XFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcXG4gKi9cXG5jb25zdCBmcmFjID0gYSA9PiBhID49IDAgPyBhIC0gTWF0aC5mbG9vcihhKSA6IGEgLSBNYXRoLmNlaWwoYSk7XFxuXFxuLyoqXFxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW2EsIGJdXFxuICovXFxuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIG9mIGkgYmV0d2VlbiBhIGFuZCBiXFxuICovXFxuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xcblxcbi8qKlxcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDAgVG9wLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzEwIFRvcC1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcXG4gKiBAcGFyYW0ge251bWJlcn0gYzExIEJvdHRvbS1yaWdodCB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpeCBJbnRlcnBvbGF0aW9uIHZhbHVlIGFsb25nIHhcXG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XFxuICogQHJldHVybiB7bnVtYmVyfSBBIGJpbGluZWFyIGludGVycG9sYXRlZCB2YWx1ZVxcbiAqL1xcbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XFxuXFxuLyoqXFxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgbnVtYmVyIHRvIHJlLW1hcFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiMlxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5jb25zdCByZW1hcCA9IChpLCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoaSAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcXG5cXG4vKipcXG4gKiBEbyBhIHNtb290aCBpbnRlcnBvbGF0aW9uIGJldHdlZW4gYSBhbmQgYlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBtYXhpbXVtIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcbmNvbnN0IHNtb290aHN0ZXAgPSAoYSwgYiwgaSkgPT4gbGVycChhLCBiLCAzICogTWF0aC5wb3coaSwgMikgLSAyICogTWF0aC5wb3coaSwgMykpO1xcblxcbi8qKlxcbiAqIEdldCBhbiBhbmdsZSBpbiByYWRpYW5zXFxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICovXFxuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcXG5cXG4vKipcXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIFRoZSBhbmdsZSBpbiByYWRpYW5zXFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgaW4gZGVncmVlc1xcbiAqL1xcbmNvbnN0IGRlZ3JlZXMgPSByYWRpYW5zID0+ICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XFxuXFxuLyoqXFxuICogR2V0IGEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXFxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XFxuICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4KVxcbiAqL1xcbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcXG5cXG4vKipcXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxcbiAqL1xcbmNvbnN0IHJhbmRvbUludEJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIG51bWJlclxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2lnbWE9MC41XSBUaGUgc3RhbmRhcmQgZGV2aWF0aW9uXFxuICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVzPTJdIFRoZSBudW1iZXIgb2Ygc2FtcGxlc1xcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXFxuICovXFxuY29uc3QgY2x0UmFuZG9tID0gKG11ID0gMC41LCBzaWdtYSA9IDAuNSwgc2FtcGxlcyA9IDIpID0+IHtcXG4gIGxldCB0b3RhbCA9IDA7XFxuICBmb3IgKGxldCBpID0gc2FtcGxlczsgaS0tOykge1xcbiAgICB0b3RhbCArPSBNYXRoLnJhbmRvbSgpO1xcbiAgfVxcbiAgcmV0dXJuIG11ICsgKHRvdGFsIC0gc2FtcGxlcyAvIDIpIC8gKHNhbXBsZXMgLyAyKSAqIHNpZ21hO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXIgaW4gdGhlIGludGVydmFsIFttaW4sIG1heF1cXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsbHktZGlzdHJpYnV0ZWQgcmFuZG9tIGludGVnZXJcXG4gKi9cXG5jb25zdCBjbHRSYW5kb21JbnQgPSAobWluLCBtYXgpID0+IE1hdGguZmxvb3IobWluICsgY2x0UmFuZG9tKDAuNSwgMC41LCAyKSAqIChtYXggKyAxIC0gbWluKSk7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgd2VpZ2h0ZWQgcmFuZG9tIGludGVnZXJcXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHcgQW4gYXJyYXkgb2Ygd2VpZ2h0c1xcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XFxuICovXFxuY29uc3Qgd2VpZ2h0ZWRSYW5kb20gPSB3ID0+IHtcXG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xcbiAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiB0b3RhbDtcXG4gIHdoaWxlICh0b3RhbCA+IHIpIHtcXG4gICAgdG90YWwgLT0gd1tuKytdO1xcbiAgfVxcbiAgcmV0dXJuIG4gLSAxO1xcbn07XFxuXFxuLyoqXFxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxcbiAqIEBjYWxsYmFjayBpbnRlcnBvbGF0aW9uQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgbWluaW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxcbiAqL1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBBbiBhcnJheSBvZiB2YWx1ZXMgaW50ZXJwb2xhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBBIG51bWJlciBpbiB0aGUgaW50ZXJ2YWwgWzAsIDFdXFxuICogQHBhcmFtIHtpbnRlcnBvbGF0aW9uQ2FsbGJhY2t9IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXFxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFttaW4oYSksIG1heChhKV1cXG4gKi9cXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcXG4gIGNvbnN0IHMgPSBpICogKGEubGVuZ3RoIC0gMSk7XFxuICBjb25zdCBwID0gY2xhbXAoTWF0aC50cnVuYyhzKSwgMCwgYS5sZW5ndGggLSAxKTtcXG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXFxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXFxuICovXFxuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXFxuICogQHBhcmFtIHtudW1iZXJ9IGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEhXFxuICovXFxuY29uc3QgZmFjdG9yaWFsID0gYSA9PiB7XFxuICBsZXQgcmVzdWx0ID0gMTtcXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xcbiAgICByZXN1bHQgKj0gaTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIG51bWJlciBvZiBwZXJtdXRhdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7bnVtYmVyfSByXFxuICogQHJldHVybiB7bnVtYmVyfSBuUHJcXG4gKi9cXG5jb25zdCBwZXJtdXRhdGlvbiA9IChuLCByKSA9PiBmYWN0b3JpYWwobikgLyBmYWN0b3JpYWwobiAtIHIpO1xcblxcbi8qKlxcbiAqIEdldCB0aGUgbnVtYmVyIG9mIGNvbWJpbmF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IHJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5DclxcbiAqL1xcbmNvbnN0IGNvbWJpbmF0aW9uID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcXG5cXG4vKipcXG4gKiBBIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGFycmF5IHZhbHVlc1xcbiAqIEBjYWxsYmFjayB0aW1lc0NhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGFycmF5IGluZGV4XFxuICogQHJldHVybiB7Kn0gVGhlIGFycmF5IHZhbHVlXFxuICovXFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxcbiAqIEBwYXJhbSB7dGltZXNDYWxsYmFja30gZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBzaXplIG9mIHRoZSBhcnJheVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxcbiAqL1xcbmNvbnN0IHRpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBudW1iZXJzIDAtPihuIC0gMSlcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBvZiBpbnRlZ2VycyAwLT4obiAtIDEpXFxuICovXFxuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XFxuXFxuLyoqXFxuICogWmlwIDIgYXJyYXlzIHRvZ2V0aGVyLCBpLmUuIChbMSwgMiwgM10sIFthLCBiLCBjXSkgPT4gW1sxLCBhXSwgWzIsIGJdLCBbMywgY11dXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGJcXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59XFxuICovXFxuY29uc3QgemlwID0gKGEsIGIpID0+IGEubWFwKChrLCBpKSA9PiBbaywgYltpXV0pO1xcblxcbi8qKlxcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcXG4gKiBAcmV0dXJuIHsqfSBBbiBlbGVtZW50IGZyb20gdGhlIGFycmF5XFxuICovXFxuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xcblxcbi8qKlxcbiAqIENob3AgYW4gYXJyYXkgaW50byBjaHVua3Mgb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheSBjaHVua3NcXG4gKi9cXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcXG5cXG4vKipcXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgc2h1ZmZsZWQgYXJyYXlcXG4gKi9cXG5jb25zdCBzaHVmZmxlID0gYSA9PiBhLnNsaWNlKCkuc29ydCgoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KTtcXG5cXG5pZiAodHJ1ZSkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIGZsb2F0RXF1YWxzLFxcbiAgICBjbGFtcCxcXG4gICAgZnJhYyxcXG4gICAgbGVycCxcXG4gICAgdW5sZXJwLFxcbiAgICBibGVycCxcXG4gICAgcmVtYXAsXFxuICAgIHNtb290aHN0ZXAsXFxuICAgIHJhZGlhbnMsXFxuICAgIGRlZ3JlZXMsXFxuICAgIHJhbmRvbUJldHdlZW4sXFxuICAgIHJhbmRvbUludEJldHdlZW4sXFxuICAgIGNsdFJhbmRvbSxcXG4gICAgY2x0UmFuZG9tSW50LFxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcXG4gICAgbGVycEFycmF5LFxcbiAgICBkb3QsXFxuICAgIGZhY3RvcmlhbCxcXG4gICAgcGVybXV0YXRpb24sXFxuICAgIGNvbWJpbmF0aW9uLFxcbiAgICB0aW1lcyxcXG4gICAgcmFuZ2UsXFxuICAgIHppcCxcXG4gICAgYXQsXFxuICAgIGNodW5rLFxcbiAgICBzaHVmZmxlLFxcbiAgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlci8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS91dGlscy91dGlscy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbmV2YWwoXCJjb25zdCB7IHRpbWVzLCBjaHVuaywgZG90IH0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS91dGlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcXFwiKTtcXG5cXG4vKipcXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcXG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxcbiAqL1xcblxcbi8qKlxcbiAqIEEgMmQgdmVjdG9yXFxuICogQHR5cGVkZWYge09iamVjdH0gdmVjXFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxcbiAqL1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3JcXG4gKiBAcGFyYW0ge251bWJlcnx2ZWN9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgbmV3IHZlY3RvclxcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxcbiAqIGxldCBhID0gdmVjKDMsIDIpOyAgLy8gKDMsIDIpXFxuICogbGV0IGIgPSB2ZWMoNCk7ICAgICAvLyAoNCwgNClcXG4gKiBsZXQgYyA9IHZlYyhhKTsgICAgIC8vICgzLCAyKVxcbiAqIGxldCBkID0gdmVjKCk7ICAgICAgLy8gKDAsIDApXFxuICovXFxuY29uc3QgdmVjID0gKHgsIHkpID0+ICgheCAmJiAheSA/XFxuICB7IHg6IDAsIHk6IDAgfSA6ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xcbiAgICB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9IDogKHkgPT09IG51bGwgfHwgeSA9PT0gdW5kZWZpbmVkID9cXG4gICAgICB7IHg6IHgsIHk6IHggfSA6IHsgeDogeCwgeTogeSB9KVxcbiAgKVxcbik7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XFxuICovXFxudmVjLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDEsIDApXFxuICogQHJldHVybiB7dmVjfSBBIHVuaXQgdmVjdG9yICgxLCAwKVxcbiAqL1xcbnZlYy51eCA9ICgpID0+IHZlYygxLCAwKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMSlcXG4gKiBAcmV0dXJuIHt2ZWN9IEEgdW5pdCB2ZWN0b3IgKDAsIDEpXFxuICovXFxudmVjLnV5ID0gKCkgPT4gdmVjKDAsIDEpO1xcblxcbi8qKlxcbiAqIEFkZCB2ZWN0b3JzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSArIGJcXG4gKi9cXG52ZWMuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIGIueCwgeTogYS55ICsgYi55IH0pO1xcblxcbi8qKlxcbiAqIFNjYWxlIGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxcbiAqIEByZXR1cm4ge3ZlY30gYSAqIGJcXG4gKi9cXG52ZWMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIGIsIHk6IGEueSAqIGIgfSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHt2ZWN9IGEgLSBiXFxuICovXFxudmVjLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcXG4gKi9cXG52ZWMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxcbiAqL1xcbnZlYy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpO1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIHZlY3RvclxcbiAqIEBwYXJhbSB7dmVjfSBhIFRoZSB2ZWN0b3IgdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7dmVjfSBeYVxcbiAqL1xcbnZlYy5ub3IgPSBhID0+IHtcXG4gIGxldCBsZW4gPSB2ZWMubGVuKGEpO1xcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYygpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xcbiAqIEBwYXJhbSB7dmVjfSBhIFZlY3RvciBhXFxuICogQHBhcmFtIHt2ZWN9IGIgVmVjdG9yIGJcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcXG4gKi9cXG52ZWMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcXG5cXG4vKipcXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXFxuICogQHJldHVybiB7dmVjfSBBIHJvdGF0ZWQgdmVjdG9yXFxuICovXFxudmVjLnJvdCA9IChhLCByKSA9PiB7XFxuICBsZXQgcyA9IE1hdGguc2luKHIpLFxcbiAgICBjID0gTWF0aC5jb3Mocik7XFxuICByZXR1cm4geyB4OiBjICogYS54IC0gcyAqIGEueSwgeTogcyAqIGEueCArIGMgKiBhLnkgfTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY30gYiBWZWN0b3IgYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxudmVjLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcXG4gKiBAcGFyYW0ge3ZlY30gYSBWZWN0b3IgYVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcXG4gKi9cXG52ZWMucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcXG5cXG4vKipcXG4gKiBDb3B5IGEgdmVjdG9yXFxuICogQHBhcmFtIHt2ZWN9IGEgVGhlIHZlY3RvciB0byBjb3B5XFxuICogQHJldHVybiB7dmVjfSBBIGNvcHkgb2YgdmVjdG9yIGFcXG4gKi9cXG52ZWMuY3B5ID0gYSA9PiB2ZWMoYSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yXFxuICogQGNhbGxiYWNrIHZlY3Rvck1hcENhbGxiYWNrXFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcXG4gKiBAcGFyYW0geyd4JyB8ICd5J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCBvciB5KVxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXFxuICogQHBhcmFtIHt2ZWN9IGEgVmVjdG9yIGFcXG4gKiBAcGFyYW0ge3ZlY3Rvck1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcXG4gKiBAcmV0dXJuIHt2ZWN9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcXG4gKi9cXG52ZWMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSB9KTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gYSBzdHJpbmdcXG4gKiBAcGFyYW0ge3ZlY30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcXG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcXG4gKi9cXG52ZWMuc3RyID0gKGEsIHMgPSAnLCAnKSA9PiBgJHthLnh9JHtzfSR7YS55fWA7XFxuXFxuLyoqXFxuICogQSBtYXRyaXhcXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtYXRcXG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBtYXRyaXggdmFsdWVzXFxuICovXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcXG4gKiBAcGFyYW0ge251bWJlcn0gW249NF0gVGhlIG51bWJlciBvZiBjb2x1bW5zXFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXFxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcXG4gKi9cXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XFxuICBtLCBuLFxcbiAgZW50cmllczogZW50cmllcy5jb25jYXQoQXJyYXkobSAqIG4pLmZpbGwoMCkpLnNsaWNlKDAsIG0gKiBuKVxcbn0pO1xcblxcbi8qKlxcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXFxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxcbiAqIEByZXR1cm4ge21hdH0gQW4gaWRlbnRpdHkgbWF0cml4XFxuICovXFxubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcXG5cXG4vKipcXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZhbHVlIGF0IHBvc2l0aW9uIChpLCBqKSBpbiBtYXRyaXggYVxcbiAqL1xcbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcXG5cXG4vKipcXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gdiBUaGUgdmFsdWUgdG8gc2V0IGluIG1hdHJpeCBhXFxuICovXFxubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xcblxcbi8qKlxcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQucm93ID0gKGEsIG0pID0+IHtcXG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xcbiAgcmV0dXJuIGEuZW50cmllcy5zbGljZShzLCBzICsgYS5uKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcXG4gKi9cXG5tYXQuY29sID0gKGEsIG4pID0+IHRpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcXG5cXG4vKipcXG4gKiBBZGQgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhICsgYlxcbiAqL1xcbm1hdC5hZGQgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiArIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogU3VidHJhY3QgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fSBhIC0gYlxcbiAqL1xcbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XFxuXFxuLyoqXFxuICogTXVsdGlwbHkgbWF0cmljZXNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxcbiAqL1xcbm1hdC5tdWwgPSAoYSwgYikgPT4ge1xcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIGRvdChtYXQucm93KGEsIGkpLCBtYXQuY29sKGIsIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBTY2FsZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXFxuICovXFxubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XFxuXFxuLyoqXFxuICogVHJhbnNwb3NlIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcXG4gKiBAcmV0dXJuIHttYXR9IEEgdHJhbnNwb3NlZCBtYXRyaXhcXG4gKi9cXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgdGltZXMoaSA9PiBtYXQuY29sKGEsIChpICsgMSkpLCBhLm4pLmZsYXQoKSk7XFxuXFxuLyoqXFxuICogR2V0IHRoZSBtaW5vciBvZiBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcXG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxcbiAqIEByZXR1cm4ge21hdHxib29sZWFufSBUaGUgKGksIGopIG1pbm9yIG9mIG1hdHJpeCBhIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XFxuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XFxuICBjb25zdCBlbnRyaWVzID0gW107XFxuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xcbiAgICBpZiAoaWkgPT09IGkpIHsgY29udGludWU7IH1cXG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcXG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cXG4gICAgICBlbnRyaWVzLnB1c2gobWF0LmdldChhLCBpaSwgamopKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1hdChhLm0gLSAxLCBhLm4gLSAxLCBlbnRyaWVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXFxuICovXFxubWF0LmRldCA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgaWYgKGEubSA9PT0gMSkge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xcbiAgfVxcbiAgaWYgKGEubSA9PT0gMikge1xcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xcbiAgfVxcbiAgbGV0IHRvdGFsID0gMCwgc2lnbiA9IDE7XFxuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcXG4gICAgc2lnbiAqPSAtMTtcXG4gIH1cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIE5vcm1hbGlzZSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXFxuICogQHJldHVybiB7bWF0fGJvb2xlYW59IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxcbiAqL1xcbm1hdC5ub3IgPSBhID0+IHtcXG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cXG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xcbiAgcmV0dXJuIG1hdC5tYXAoYSwgaSA9PiBpICogZCk7XFxufTtcXG5cXG4vKipcXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcXG4gKiBAcmV0dXJuIHttYXR9IFRoZSBhZGp1Z2F0ZSBvZiBhXFxuICovXFxubWF0LmFkaiA9IGEgPT4ge1xcbiAgY29uc3QgbWlub3JzID0gbWF0KGEubSwgYS5uKTtcXG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XFxuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XFxuICAgICAgbWF0LnNldChtaW5vcnMsIGksIGosIG1hdC5kZXQobWF0Lm1pbm9yKGEsIGksIGopKSk7XFxuICAgIH1cXG4gIH1cXG4gIGNvbnN0IGNvZmFjdG9ycyA9IG1hdC5tYXAobWlub3JzLCAodiwgaSkgPT4gdiAqIChpICUgMiA/IC0xIDogMSkpO1xcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byBpbnZlcnRcXG4gKiBAcmV0dXJuIHttYXR8Ym9vbGVhbn0gYV4tMSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGhhcyBubyBpbnZlcnNlXFxuICovXFxubWF0LmludiA9IGEgPT4ge1xcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XFxuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG4gIHJldHVybiBtYXQuc2NhbGUobWF0LmFkaihhKSwgMSAvIGQpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXFxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXFxuICovXFxubWF0LmVxID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5zdHIoYSkgPT09IG1hdC5zdHIoYik7XFxuXFxuLyoqXFxuICogQ29weSBhIG1hdHJpeFxcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXFxuICovXFxubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XFxuXFxuLyoqXFxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcXG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgZW50cnlcXG4gKi9cXG5cXG4vKipcXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxcbiAqIEBwYXJhbSB7bWF0cml4TWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBlbnRyeSBvZiB0aGUgbWF0cml4XFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXFxuICovXFxubWF0Lm1hcCA9IChhLCBmKSA9PiBtYXQoYS5tLCBhLm4sIGEuZW50cmllcy5tYXAoZikpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYSBtYXRyaXggaW50byBhIHN0cmluZ1xcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcXG4gKiBAcGFyYW0ge3N0cmluZ30gW25zPSdcXFxcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XFxuICovXFxubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcXFxuJykgPT4gY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xcblxcbmlmICh0cnVlKSB7XFxuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjLCBtYXQgfTtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2UvaW5wdXQtbWFuYWdlci8uL25vZGVfbW9kdWxlcy9AYmFzZW1lbnR1bml2ZXJzZS92ZWMvdmVjLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xcbmV4cG9ydHMuTW91c2VCdXR0b24gPSB2b2lkIDA7XFxuY29uc3QgdmVjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFzZW1lbnR1bml2ZXJzZS92ZWMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcXFwiKTtcXG52YXIgTW91c2VCdXR0b247XFxuKGZ1bmN0aW9uIChNb3VzZUJ1dHRvbikge1xcbiAgICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcXFwiTGVmdFxcXCJdID0gMF0gPSBcXFwiTGVmdFxcXCI7XFxuICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1xcXCJNaWRkbGVcXFwiXSA9IDFdID0gXFxcIk1pZGRsZVxcXCI7XFxuICAgIE1vdXNlQnV0dG9uW01vdXNlQnV0dG9uW1xcXCJSaWdodFxcXCJdID0gMl0gPSBcXFwiUmlnaHRcXFwiO1xcbn0pKE1vdXNlQnV0dG9uID0gZXhwb3J0cy5Nb3VzZUJ1dHRvbiB8fCAoZXhwb3J0cy5Nb3VzZUJ1dHRvbiA9IHt9KSk7XFxuY2xhc3MgSW5wdXRNYW5hZ2VyIHtcXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xcbiAgICAgICAgdGhpcy5rZXlib2FyZFN0YXRlID0gSW5wdXRNYW5hZ2VyLmluaXRpYWxLZXlib2FyZFN0YXRlKCk7XFxuICAgICAgICB0aGlzLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZSA9IElucHV0TWFuYWdlci5pbml0aWFsS2V5Ym9hcmRTdGF0ZSgpO1xcbiAgICAgICAgdGhpcy5tb3VzZVN0YXRlID0gSW5wdXRNYW5hZ2VyLmluaXRpYWxNb3VzZVN0YXRlKCk7XFxuICAgICAgICB0aGlzLnByZXZpb3VzTW91c2VTdGF0ZSA9IElucHV0TWFuYWdlci5pbml0aWFsTW91c2VTdGF0ZSgpO1xcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgSW5wdXRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XFxuICAgICAgICAvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnNcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubW91c2UpIHtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbZS5idXR0b25dID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5idXR0b25zW2UuYnV0dG9uXSA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCAoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5idXR0b25zWzBdID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLmJ1dHRvbnNbMF0gPSBmYWxzZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZVN0YXRlLnBvc2l0aW9uLnggPSBlLm9mZnNldFg7XFxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VTdGF0ZS5wb3NpdGlvbi55ID0gZS5vZmZzZXRZO1xcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUuaG92ZXJlZEVsZW1lbnQgPSBlLnRhcmdldDtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vdXNlV2hlZWwpIHtcXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdXNlU3RhdGUud2hlZWwgPSBlLmRlbHRhWSA+IDAgPyAxIDogLTE7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4ge1xcbiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkU3RhdGVbZS5jb2RlXSA9IHRydWU7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZSA9PiB7XFxuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTdGF0ZVtlLmNvZGVdID0gZmFsc2U7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBjb250ZXh0IG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gcmlnaHQtY2xpY2tcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudENvbnRleHRNZW51KSB7XFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBlID0+IHtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXNlIHRoZSBpbnB1dCBtYW5hZ2VyIGZvciBtYW5hZ2luZyBtb3VzZSBhbmQga2V5Ym9hcmQgaW5wdXRcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKG9wdGlvbnMpIHtcXG4gICAgICAgIGlmIChJbnB1dE1hbmFnZXIuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbWFuYWdlciBhbHJlYWR5IGluaXRpYWxpc2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICBJbnB1dE1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgSW5wdXRNYW5hZ2VyKG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICAgIGlmIChJbnB1dE1hbmFnZXIuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbWFuYWdlciBub3QgcHJvcGVybHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBJbnB1dE1hbmFnZXIuaW5zdGFuY2U7XFxuICAgIH1cXG4gICAgc3RhdGljIGluaXRpYWxLZXlib2FyZFN0YXRlKCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICB9XFxuICAgIHN0YXRpYyBpbml0aWFsTW91c2VTdGF0ZSgpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgYnV0dG9uczoge1xcbiAgICAgICAgICAgICAgICBbTW91c2VCdXR0b24uTGVmdF06IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBbTW91c2VCdXR0b24uTWlkZGxlXTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIFtNb3VzZUJ1dHRvbi5SaWdodF06IGZhbHNlLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMpKCksXFxuICAgICAgICAgICAgd2hlZWw6IDAsXFxuICAgICAgICAgICAgaG92ZXJlZEVsZW1lbnQ6IG51bGwsXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIHN0YXRpYyBjb3B5S2V5Ym9hcmRTdGF0ZShzdGF0ZSkge1xcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgY29weU1vdXNlU3RhdGUoc3RhdGUpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgYnV0dG9uczogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYnV0dG9ucyksXFxuICAgICAgICAgICAgcG9zaXRpb246IHZlY18xLnZlYy5jcHkoc3RhdGUucG9zaXRpb24pLFxcbiAgICAgICAgICAgIHdoZWVsOiBzdGF0ZS53aGVlbCxcXG4gICAgICAgICAgICBob3ZlcmVkRWxlbWVudDogc3RhdGUuaG92ZXJlZEVsZW1lbnQsXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBpbnB1dCBkZXZpY2VzXFxuICAgICAqL1xcbiAgICBzdGF0aWMgdXBkYXRlKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZSA9IHRoaXMuY29weUtleWJvYXJkU3RhdGUoaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZSk7XFxuICAgICAgICBpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUgPSB0aGlzLmNvcHlNb3VzZVN0YXRlKGluc3RhbmNlLm1vdXNlU3RhdGUpO1xcbiAgICAgICAgaW5zdGFuY2UubW91c2VTdGF0ZS53aGVlbCA9IDA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cXG4gICAgICovXFxuICAgIHN0YXRpYyBrZXlEb3duKGNvZGUpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkga2V5IGlzIGRvd25cXG4gICAgICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtrXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICEhaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtjb2RlXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaGFzIGJlZW4gcHJlc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIGtleVByZXNzZWQoY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgd2FzIHByZXNzZWRcXG4gICAgICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtrXSAmJlxcbiAgICAgICAgICAgICAgICAgICAgKCEoayBpbiBpbnN0YW5jZS5wcmV2aW91c0tleWJvYXJkU3RhdGUpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgIWluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZVtrXSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAoISFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2NvZGVdICYmXFxuICAgICAgICAgICAgIWluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZVtjb2RlXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIGEga2V5IGhhcyBiZWVuIHJlbGVhc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMga2V5UmVsZWFzZWQoY29kZSkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBJbnB1dE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBrZXkgd2FzIHJlbGVhc2VkXFxuICAgICAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGluc3RhbmNlLmtleWJvYXJkU3RhdGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5rZXlib2FyZFN0YXRlW2tdICYmXFxuICAgICAgICAgICAgICAgICAgICAhIWluc3RhbmNlLnByZXZpb3VzS2V5Ym9hcmRTdGF0ZVtrXSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICghaW5zdGFuY2Uua2V5Ym9hcmRTdGF0ZVtjb2RlXSAmJlxcbiAgICAgICAgICAgICEhaW5zdGFuY2UucHJldmlvdXNLZXlib2FyZFN0YXRlW2NvZGVdKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBtb3VzZSBidXR0b24gaXMgY3VycmVudGx5IHByZXNzZWQgZG93blxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlRG93bihidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIGlzIGRvd25cXG4gICAgICAgIGlmIChidXR0b24gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBpbiBpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnMpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJ1dHRvbiA9ICtiO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gISFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2sgaWYgYSBtb3VzZSBidXR0b24gaGFzIGJlZW4gcHJlc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlUHJlc3NlZChidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIHdhcyBwcmVzc2VkXFxuICAgICAgICBpZiAoYnV0dG9uID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGIgaW4gaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCdXR0b24gPSArYjtcXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9uc1tjdXJyZW50QnV0dG9uXSAmJlxcbiAgICAgICAgICAgICAgICAgICAgKCEoYiBpbiBpbnN0YW5jZS5wcmV2aW91c01vdXNlU3RhdGUuYnV0dG9ucykgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbY3VycmVudEJ1dHRvbl0pKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCEhaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2J1dHRvbl0gJiZcXG4gICAgICAgICAgICAhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIGEgbW91c2UgYnV0dG9uIGhhcyBiZWVuIHJlbGVhc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VSZWxlYXNlZChidXR0b24pIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICAvLyBDaGVjayBpZiBhbnkgYnV0dG9uIHdhcyByZWxlYXNlZFxcbiAgICAgICAgaWYgKGJ1dHRvbiA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZm9yIChjb25zdCBiIGluIGluc3RhbmNlLm1vdXNlU3RhdGUuYnV0dG9ucykge1xcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QnV0dG9uID0gK2I7XFxuICAgICAgICAgICAgICAgIGlmICghaW5zdGFuY2UubW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dICYmXFxuICAgICAgICAgICAgICAgICAgICAhIWluc3RhbmNlLnByZXZpb3VzTW91c2VTdGF0ZS5idXR0b25zW2N1cnJlbnRCdXR0b25dKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKCFpbnN0YW5jZS5tb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSAmJlxcbiAgICAgICAgICAgICEhaW5zdGFuY2UucHJldmlvdXNNb3VzZVN0YXRlLmJ1dHRvbnNbYnV0dG9uXSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyB1cFxcbiAgICAgKi9cXG4gICAgc3RhdGljIG1vdXNlV2hlZWxVcCgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UubW91c2VTdGF0ZS53aGVlbCA+IDA7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENoZWNrIGlmIHRoZSBtb3VzZXdoZWVsIGlzIHNjcm9sbGluZyBkb3duXFxuICAgICAqL1xcbiAgICBzdGF0aWMgbW91c2VXaGVlbERvd24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUud2hlZWwgPCAwO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gaW4gc2NyZWVuLXNwYWNlXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZ2V0IG1vdXNlUG9zaXRpb24oKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IElucHV0TWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm1vdXNlU3RhdGUucG9zaXRpb247XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGhvdmVyZWQgZWxlbWVudFxcbiAgICAgKi9cXG4gICAgc3RhdGljIGdldCBob3ZlcmVkRWxlbWVudCgpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gSW5wdXRNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICByZXR1cm4gKF9hID0gaW5zdGFuY2UubW91c2VTdGF0ZS5ob3ZlcmVkRWxlbWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcXG4gICAgfVxcbn1cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBJbnB1dE1hbmFnZXI7XFxuSW5wdXRNYW5hZ2VyLmRlZmF1bHRPcHRpb25zID0ge1xcbiAgICBlbGVtZW50OiB3aW5kb3csXFxuICAgIG1vdXNlOiB0cnVlLFxcbiAgICBtb3VzZVdoZWVsOiB0cnVlLFxcbiAgICBrZXlib2FyZDogdHJ1ZSxcXG4gICAgcHJldmVudENvbnRleHRNZW51OiBmYWxzZSxcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXIvLi9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2luZGV4LnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLyoqXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXG4gKi9cblxuLyoqXG4gKiBNZW1vaXplIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvblxuICovXG5jb25zdCBtZW1vaXplID0gZiA9PiB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjYWNoZVthcmdzXSA/PyAoY2FjaGVbYXJnc10gPSBmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG51bWJlcnMgYSBhbmQgYiBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICovXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XG5cbi8qKlxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBudW1iZXJcbiAqL1xuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XG5cbi8qKlxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgZnJvbSB3aGljaCB0byBnZXQgdGhlIGZyYWN0aW9uYWwgcGFydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcbiAqL1xuY29uc3QgZnJhYyA9IGEgPT4gYSA+PSAwID8gYSAtIE1hdGguZmxvb3IoYSkgOiBhIC0gTWF0aC5jZWlsKGEpO1xuXG4vKipcbiAqIFJvdW5kIG4gdG8gZCBkZWNpbWFsIHBsYWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtkPTBdIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm4ge251bWJlcn0gQSByb3VuZGVkIG51bWJlclxuICovXG5jb25zdCByb3VuZCA9IChuLCBkID0gMCkgPT4ge1xuICBjb25zdCBwID0gTWF0aC5wb3coMTAsIGQpO1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogcCArIE51bWJlci5FUFNJTE9OKSAvIHA7XG59XG5cbi8qKlxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XG5cbi8qKlxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xuXG4vKipcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMxMCBUb3AtcmlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaXggSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB4XG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXG4gKi9cbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XG5cbi8qKlxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXG4gKiBAcGFyYW0ge251bWJlcn0gYTFcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxuICogQHBhcmFtIHtudW1iZXJ9IGIxXG4gKiBAcGFyYW0ge251bWJlcn0gYjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgcmVtYXAgPSAoaSwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKGkgLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSk7XG5cbi8qKlxuICogRG8gYSBzbW9vdGggaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5jb25zdCBzbW9vdGhzdGVwID0gKGEsIGIsIGkpID0+IGxlcnAoYSwgYiwgMyAqIE1hdGgucG93KGksIDIpIC0gMiAqIE1hdGgucG93KGksIDMpKTtcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqL1xuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXG4gKi9cbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICovXG5jb25zdCByYW5kb21JbnRCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlcz0yXSBUaGUgbnVtYmVyIG9mIHNhbXBsZXNcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbSA9IChtdSA9IDAuNSwgc2lnbWEgPSAwLjUsIHNhbXBsZXMgPSAyKSA9PiB7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XG4gICAgdG90YWwgKz0gTWF0aC5yYW5kb20oKTtcbiAgfVxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XG59O1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB3IEFuIGFycmF5IG9mIHdlaWdodHNcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XG4gKi9cbmNvbnN0IHdlaWdodGVkUmFuZG9tID0gdyA9PiB7XG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xuICB3aGlsZSAodG90YWwgPiByKSB7XG4gICAgdG90YWwgLT0gd1tuKytdO1xuICB9XG4gIHJldHVybiBuIC0gMTtcbn07XG5cbi8qKlxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxuICogQGNhbGxiYWNrIEludGVycG9sYXRpb25GdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQSBudW1iZXIgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHBhcmFtIHtJbnRlcnBvbGF0aW9uRnVuY3Rpb259IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxuICovXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcbiAgY29uc3QgcCA9IGNsYW1wKE1hdGgudHJ1bmMocyksIDAsIGEubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xuXG4vKipcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHJldHVybiB7bnVtYmVyfSBhIVxuICovXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcbiAgbGV0IHJlc3VsdCA9IDE7XG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xuICAgIHJlc3VsdCAqPSBpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSByXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxuICovXG5jb25zdCBucHIgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gZmFjdG9yaWFsKG4gLSByKTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gclxuICogQHJldHVybiB7bnVtYmVyfSBuQ3JcbiAqL1xuY29uc3QgbmNyID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogcGVybXV0YXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgMV0sXG4gKiAgIFsyLCAzXSxcbiAqICAgWzMsIDFdLFxuICogICBbMywgMl1cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBwZXJtdXRhdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBwZXJtdXRhdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgcGVybXV0YXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLnBlcm11dGF0aW9ucyhhLnNsaWNlKDAsIGkpLmNvbmNhdChhLnNsaWNlKGkgKyAxKSksIHIgLSAxKS5tYXAoYyA9PiBbaXRlbSwgLi4uY10pLFxuICAgIF0sXG4gICAgW11cbiAgKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgM11cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBjb21iaW5hdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLmNvbWJpbmF0aW9ucyhhLnNsaWNlKGkgKyAxKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXG4gICAgXSxcbiAgICBbXVxuICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNhcnRlc2lhbihbMSwgMiwgM10sIFsnYScsICdiJ10pO1xuICogYGBgXG4gKlxuICogT3V0cHV0OlxuICogYGBganNvblxuICogW1xuICogICBbMSwgXCJhXCJdLFxuICogICBbMSwgXCJiXCJdLFxuICogICBbMiwgXCJhXCJdLFxuICogICBbMiwgXCJiXCJdLFxuICogICBbMywgXCJhXCJdLFxuICogICBbMywgXCJiXCJdXG4gKiBdXG4gKiBgYGBcbiAqL1xuY29uc3QgY2FydGVzaWFuID0gKC4uLmFycikgPT5cbiAgYXJyLnJlZHVjZShcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcbiAgICBbW11dXG4gICk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhcnJheSB2YWx1ZXNcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IFRoZSBhcnJheSB2YWx1ZVxuICovXG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxuICogQHBhcmFtIHtUaW1lc0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxuICovXG5jb25zdCB0aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyAwLT4obiAtIDEpXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcbiAqL1xuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XG5cbi8qKlxuICogWmlwIG11bHRpcGxlIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxuICogQHBhcmFtIHsuLi5BcnJheTwqPn0gYSBUaGUgYXJyYXlzIHRvIHppcFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fVxuICovXG5jb25zdCB6aXAgPSAoLi4uYSkgPT4gdGltZXMoaSA9PiBhLm1hcChhID0+IGFbaV0pLCBNYXRoLm1heCguLi5hLm1hcChhID0+IGEubGVuZ3RoKSkpO1xuXG4vKipcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xuICogQHBhcmFtIHtBcnJheTwqPn0gYSBUaGUgYXJyYXkgdG8gYWNjZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEByZXR1cm4geyp9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgcGVlayA9IChhKSA9PiB7XG4gIGlmICghYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBwb3NpdGlvbiBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggaW4gdGhlIHVucm9sbGVkIGFycmF5XG4gKi9cbmNvbnN0IGluZCA9ICh4LCB5LCB3KSA9PiB4ICsgeSAqIHc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwb3NpdGlvbiBmb3IgYSBnaXZlbiBpbmRleCBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHBvc2l0aW9uIGFzIGEgMi10dXBsZVxuICovXG5jb25zdCBwb3MgPSAoaSwgdykgPT4gW2kgJSB3LCBNYXRoLmZsb29yKGkgLyB3KV07XG5cbi8qKlxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xuICovXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcblxuLyoqXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gVGhlIHNodWZmbGVkIGFycmF5XG4gKi9cbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuXG4vKipcbiAqIEZsYXR0ZW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIHVzZSBmb3IgY29uY2F0ZW5hdGluZyBrZXlzXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCBmbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChvW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBvW2tleV0udG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8ICFvW2tleV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2tleV06IG9ba2V5XSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQob1trZXldLCBjb25jYXRlbmF0b3IpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGZsYXR0ZW5lZCkucmVkdWNlKFxuICAgICAgICAoY2hpbGRBY2MsIGNoaWxkS2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmNoaWxkQWNjLFxuICAgICAgICAgIFtgJHtrZXl9JHtjb25jYXRlbmF0b3J9JHtjaGlsZEtleX1gXTogZmxhdHRlbmVkW2NoaWxkS2V5XSxcbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApLFxuICAgIH07XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogVW5mbGF0dGVuIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byBjaGVjayBmb3IgaW4gY29uY2F0ZW5hdGVkIGtleXNcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gdW4tZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCB1bmZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XG4gIGxldCByZXN1bHQgPSB7fSwgdGVtcCwgc3Vic3RyaW5ncywgcHJvcGVydHksIGk7XG5cbiAgZm9yIChwcm9wZXJ0eSBpbiBvKSB7XG4gICAgc3Vic3RyaW5ncyA9IHByb3BlcnR5LnNwbGl0KGNvbmNhdGVuYXRvcik7XG4gICAgdGVtcCA9IHJlc3VsdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICghKHN1YnN0cmluZ3NbaV0gaW4gdGVtcCkpIHtcbiAgICAgICAgaWYgKGlzRmluaXRlKHN1YnN0cmluZ3NbaSArIDFdKSkge1xuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSB0ZW1wW3N1YnN0cmluZ3NbaV1dO1xuICAgIH1cbiAgICB0ZW1wW3N1YnN0cmluZ3Nbc3Vic3RyaW5ncy5sZW5ndGggLSAxXV0gPSBvW3Byb3BlcnR5XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEEgc3BsaXQgcHJlZGljYXRlXG4gKiBAY2FsbGJhY2sgU3BsaXRQcmVkaWNhdGVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJyYXkgc2hvdWxkIHNwbGl0IGF0IHRoaXMgaW5kZXhcbiAqL1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gc3ViLWFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcbiAqIEBwYXJhbSB7U3BsaXRQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheXNcbiAqL1xuY29uc3Qgc3BsaXQgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gW3ZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2goY3VycmVudCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGx1Y2sga2V5cyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIHBsdWNrIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGx1Y2tlZCBrZXlzXG4gKi9cbmNvbnN0IHBsdWNrID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChyZXN1bHQsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9ba2V5XSB9KSxcbiAgICB7fVxuICApO1xufTtcblxuLyoqXG4gKiBFeGNsdWRlIGtleXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBleGNsdWRlIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5cyBleGNlcHQgZXhjbHVkZWQga2V5c1xuICovXG5jb25zdCBleGNsdWRlID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKVxuICApO1xufTtcblxuaWYgKHRydWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbWVtb2l6ZSxcbiAgICBmbG9hdEVxdWFscyxcbiAgICBjbGFtcCxcbiAgICBmcmFjLFxuICAgIHJvdW5kLFxuICAgIGxlcnAsXG4gICAgdW5sZXJwLFxuICAgIGJsZXJwLFxuICAgIHJlbWFwLFxuICAgIHNtb290aHN0ZXAsXG4gICAgcmFkaWFucyxcbiAgICBkZWdyZWVzLFxuICAgIHJhbmRvbUJldHdlZW4sXG4gICAgcmFuZG9tSW50QmV0d2VlbixcbiAgICBjbHRSYW5kb20sXG4gICAgY2x0UmFuZG9tSW50LFxuICAgIHdlaWdodGVkUmFuZG9tLFxuICAgIGxlcnBBcnJheSxcbiAgICBkb3QsXG4gICAgZmFjdG9yaWFsLFxuICAgIG5wcixcbiAgICBuY3IsXG4gICAgcGVybXV0YXRpb25zLFxuICAgIGNvbWJpbmF0aW9ucyxcbiAgICBjYXJ0ZXNpYW4sXG4gICAgdGltZXMsXG4gICAgcmFuZ2UsXG4gICAgemlwLFxuICAgIGF0LFxuICAgIHBlZWssXG4gICAgaW5kLFxuICAgIHBvcyxcbiAgICBjaHVuayxcbiAgICBzaHVmZmxlLFxuICAgIGZsYXQsXG4gICAgdW5mbGF0LFxuICAgIHNwbGl0LFxuICAgIHBsdWNrLFxuICAgIGV4Y2x1ZGUsXG4gIH07XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdmVjL3ZlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8qKlxuICogQG92ZXJ2aWV3IEEgc21hbGwgdmVjdG9yIGFuZCBtYXRyaXggbGlicmFyeVxuICogQGF1dGhvciBHb3Jkb24gTGFycmlnYW5cbiAqL1xuXG5jb25zdCBfdmVjX3RpbWVzID0gKGYsIG4pID0+IEFycmF5KG4pLmZpbGwoMCkubWFwKChfLCBpKSA9PiBmKGkpKTtcbmNvbnN0IF92ZWNfY2h1bmsgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcbmNvbnN0IF92ZWNfZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xuY29uc3QgX3ZlY19pc192ZWMyID0gYSA9PiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgJ3gnIGluIGEgJiYgJ3knIGluIGE7XG5jb25zdCBfdmVjX2lzX3ZlYzMgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYSAmJiAneicgaW4gYTtcblxuLyoqXG4gKiBBIDJkIHZlY3RvclxuICogQHR5cGVkZWYge09iamVjdH0gdmVjMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgMmQgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMyfSBbeF0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IsIG9yIGEgdmVjdG9yIHRvIGNvcHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IDJkIHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzIoMywgMik7IC8vICgzLCAyKVxuICogbGV0IGIgPSB2ZWMyKDQpOyAgICAvLyAoNCwgNClcbiAqIGxldCBjID0gdmVjMihhKTsgICAgLy8gKDMsIDIpXG4gKiBsZXQgZCA9IHZlYzIoKTsgICAgIC8vICgwLCAwKVxuICovXG5jb25zdCB2ZWMyID0gKHgsIHkpID0+IHtcbiAgaWYgKCF4ICYmICF5KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAgfTtcbiAgfVxuICByZXR1cm4geyB4OiB4LCB5OiB5ID8/IHggfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAqL1xudmVjMi5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnldO1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIG5ldyB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMiguLi5jb21wb25lbnRzLnNsaWNlKDAsIDIpKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMClcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdW5pdCB2ZWN0b3IgKDEsIDApXG4gKi9cbnZlYzIudXggPSAoKSA9PiB2ZWMyKDEsIDApO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxKVxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMCwgMSlcbiAqL1xudmVjMi51eSA9ICgpID0+IHZlYzIoMCwgMSk7XG5cbi8qKlxuICogQWRkIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKyBiXG4gKi9cbnZlYzIuYWRkID0gKGEsIGIpID0+ICh7IHg6IGEueCArIChiLnggPz8gYiksIHk6IGEueSArIChiLnkgPz8gYikgfSk7XG5cbi8qKlxuICogU3VidHJhY3QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAtIGJcbiAqL1xudmVjMi5zdWIgPSAoYSwgYikgPT4gKHsgeDogYS54IC0gKGIueCA/PyBiKSwgeTogYS55IC0gKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTY2FsZSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAqIGJcbiAqL1xudmVjMi5tdWwgPSAoYSwgYikgPT4gKHsgeDogYS54ICogKGIueCA/PyBiKSwgeTogYS55ICogKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTY2FsZSBhIHZlY3RvciBieSBhIHNjYWxhciwgYWxpYXMgZm9yIHZlYzIubXVsXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxuICovXG52ZWMyLnNjYWxlID0gKGEsIGIpID0+IHZlYzIubXVsKGEsIGIpO1xuXG4vKipcbiAqIERpdmlkZSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSAvIGJcbiAqL1xudmVjMi5kaXYgPSAoYSwgYikgPT4gKHsgeDogYS54IC8gKGIueCA/PyBiKSwgeTogYS55IC8gKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxuICovXG52ZWMyLmxlbiA9IGEgPT4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgdXNpbmcgdGF4aWNhYiBnZW9tZXRyeVxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHxhfFxuICovXG52ZWMyLm1hbmhhdHRhbiA9IGEgPT4gTWF0aC5hYnMoYS54KSArIE1hdGguYWJzKGEueSk7XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcbiAqIEByZXR1cm4ge3ZlYzJ9IF5hXG4gKi9cbnZlYzIubm9yID0gYSA9PiB7XG4gIGxldCBsZW4gPSB2ZWMyLmxlbihhKTtcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4gfSA6IHZlYzIoKTtcbn07XG5cbi8qKlxuICogR2V0IGEgZG90IHByb2R1Y3Qgb2YgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDiiJkgYlxuICovXG52ZWMyLmRvdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFuc1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzIucm90ID0gKGEsIHIpID0+IHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyKSxcbiAgICBjID0gTWF0aC5jb3Mocik7XG4gIHJldHVybiB7IHg6IGMgKiBhLnggLSBzICogYS55LCB5OiBzICogYS54ICsgYyAqIGEueSB9O1xufTtcblxuLyoqXG4gKiBGYXN0IG1ldGhvZCB0byByb3RhdGUgYSB2ZWN0b3IgYnkgLTkwLCA5MCBvciAxODAgZGVncmVlc1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciAxIGZvciA5MCBkZWdyZWVzIChjdyksIC0xIGZvciAtOTAgZGVncmVlcyAoY2N3KSwgMiBvciAtMiBmb3IgMTgwIGRlZ3JlZXNcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMi5yb3RmID0gKGEsIHIpID0+IHtcbiAgc3dpdGNoIChyKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gdmVjMihhLnksIC1hLngpO1xuICAgIGNhc2UgLTE6IHJldHVybiB2ZWMyKC1hLnksIGEueCk7XG4gICAgY2FzZSAyOiBjYXNlIC0yOiByZXR1cm4gdmVjMigtYS54LCAtYS55KTtcbiAgICBkZWZhdWx0OiByZXR1cm4gYTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2FsYXIgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge251bWJlcn0gYSDDlyBiXG4gKi9cbnZlYzIuY3Jvc3MgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG52ZWMyLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMyLnJhZCA9IGEgPT4gTWF0aC5hdGFuMihhLnksIGEueCk7XG5cbi8qKlxuICogQ29weSBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29weVxuICogQHJldHVybiB7dmVjMn0gQSBjb3B5IG9mIHZlY3RvciBhXG4gKi9cbnZlYzIuY3B5ID0gYSA9PiB2ZWMyKGEpO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIDJkIHZlY3RvclxuICogQGNhbGxiYWNrIHZlYzJNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjb21wb25lbnQgdmFsdWVcbiAqIEBwYXJhbSB7J3gnIHwgJ3knfSBsYWJlbCBUaGUgY29tcG9uZW50IGxhYmVsICh4IG9yIHkpXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXBwZWQgY29tcG9uZW50XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBjb21wb25lbnQgb2YgYSB2ZWN0b3IgYW5kIGJ1aWxkIGEgbmV3IHZlY3RvciBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMk1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IFZlY3RvciBhIG1hcHBlZCB0aHJvdWdoIGZcbiAqL1xudmVjMi5tYXAgPSAoYSwgZikgPT4gKHsgeDogZihhLngsICd4JyksIHk6IGYoYS55LCAneScpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9YDtcblxuLyoqXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xuICpcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XG4gKiAtIGB4YCBvciBgeWBcbiAqIC0gYHVgIG9yIGB2YCAoYWxpYXNlcyBmb3IgYHhgIGFuZCBgeWAsIHJlc3BlY3RpdmVseSlcbiAqIC0gYFhgLCBgWWAsIGBVYCwgYFZgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXG4gKlxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzIoMywgLTIpO1xuICogdmVjMi5zd2l6KGEsICd4Jyk7ICAgIC8vIFszXVxuICogdmVjMi5zd2l6KGEsICd5eCcpOyAgIC8vIFstMiwgM11cbiAqIHZlYzIuc3dpeihhLCAneFknKTsgICAvLyBbMywgMl1cbiAqIHZlYzIuc3dpeihhLCAnWXknKTsgICAvLyBbMiwgLTJdXG4gKiB2ZWMyLnN3aXooYSwgJ3gueCcpOyAgLy8gWzMsIC0yLCAzXVxuICogdmVjMi5zd2l6KGEsICd5MDF4Jyk7IC8vIFstMiwgMCwgMSwgM11cbiAqL1xudmVjMi5zd2l6ID0gKGEsIHMgPSAnLi4nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiByZXN1bHQucHVzaChhLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogcmVzdWx0LnB1c2goLWEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAnWSc6IGNhc2UgJ1YnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnldW2ldID8/IDApOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJlc3VsdC5wdXNoKDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBvbGFyIGNvb3JkaW5hdGVzIGZvciBhIDJkIHZlY3RvclxuICogQHR5cGVkZWYge09iamVjdH0gcG9sYXJDb29yZGluYXRlczJkXG4gKiBAcHJvcGVydHkge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aGV0YSBUaGUgYW5nbGUgb2YgdGhlIHZlY3RvclxuICovXG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIHBvbGFyIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtwb2xhckNvb3JkaW5hdGVzMmR9IFRoZSBtYWduaXR1ZGUgYW5kIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5wb2xhciA9IGEgPT4gKHsgcjogdmVjMi5sZW4oYSksIHRoZXRhOiBNYXRoLmF0YW4yKGEueSwgYS54KSB9KTtcblxuLyoqXG4gKiBDb252ZXJ0IHBvbGFyIGNvb3JkaW5hdGVzIGludG8gYSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBhbmdsZSBhbmQgbWFnbml0dWRlXG4gKi9cbnZlYzIuZnJvbVBvbGFyID0gKHIsIHRoZXRhKSA9PiB2ZWMyKHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpO1xuXG4vKipcbiAqIEEgM2QgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMzXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgM2QgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnx2ZWMzfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgdGhlIHogY29tcG9uZW50IGlmIHggaXMgYSB2ZWMyXG4gKiBAcGFyYW0ge251bWJlcn0gW3pdIFRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyAzZCB2ZWN0b3JcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnZhcmlvdXMgd2F5cyB0byBpbml0aWFsaXNlIGEgdmVjdG9yPC9jYXB0aW9uPlxuICogbGV0IGEgPSB2ZWMzKDMsIDIsIDEpOyAgICAgICAvLyAoMywgMiwgMSlcbiAqIGxldCBiID0gdmVjMyg0LCA1KTsgICAgICAgICAgLy8gKDQsIDUsIDApXG4gKiBsZXQgYyA9IHZlYzMoNik7ICAgICAgICAgICAgIC8vICg2LCA2LCA2KVxuICogbGV0IGQgPSB2ZWMzKGEpOyAgICAgICAgICAgICAvLyAoMywgMiwgMSlcbiAqIGxldCBlID0gdmVjMygpOyAgICAgICAgICAgICAgLy8gKDAsIDAsIDApXG4gKiBsZXQgZiA9IHZlYzModmVjMigxLCAyKSwgMyk7IC8vICgxLCAyLCAzKVxuICogbGV0IGcgPSB2ZWMzKHZlYzIoNCwgNSkpOyAgICAvLyAoNCwgNSwgMClcbiAqL1xuY29uc3QgdmVjMyA9ICh4LCB5LCB6KSA9PiB7XG4gIGlmICgheCAmJiAheSAmJiAheikge1xuICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcbiAgfVxuICBpZiAoX3ZlY19pc192ZWMzKHgpKSB7XG4gICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzIoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHkgfHwgMCB9O1xuICB9XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCwgejogeiA/PyB4IH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhcyBhbiBhcnJheVxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgZnJvbVxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHZlY3RvciBjb21wb25lbnRzIGFzIGFuIGFycmF5XG4gKi9cbnZlYzMuY29tcG9uZW50cyA9IGEgPT4gW2EueCwgYS55LCBhLnpdO1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlY3RvciBmcm9tIGFuIGFycmF5IG9mIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29tcG9uZW50cyBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIG5ldyB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgPT4gdmVjMyguLi5jb21wb25lbnRzLnNsaWNlKDAsIDMpKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMSwgMCwgMClcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDEsIDAsIDApXG4gKi9cbnZlYzMudXggPSAoKSA9PiB2ZWMzKDEsIDAsIDApO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMCwgMSwgMClcbiAqL1xudmVjMy51eSA9ICgpID0+IHZlYzMoMCwgMSwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAwLCAxKVxuICovXG52ZWMzLnV6ID0gKCkgPT4gdmVjMygwLCAwLCAxKTtcblxuLyoqXG4gKiBBZGQgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzN8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjM30gYSArIGJcbiAqL1xudmVjMy5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSwgejogYS56ICsgKGIueiA/PyBiKSB9KTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC0gYlxuICovXG52ZWMzLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpLCB6OiBhLnogLSAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICogYlxuICovXG52ZWMzLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpLCB6OiBhLnogKiAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMy5tdWxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXG4gKi9cbnZlYzMuc2NhbGUgPSAoYSwgYikgPT4gdmVjMy5tdWwoYSwgYik7XG5cbi8qKlxuICogRGl2aWRlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhIC8gYlxuICovXG52ZWMzLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpLCB6OiBhLnogLyAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzMubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55ICsgYS56ICogYS56KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzMubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KSArIE1hdGguYWJzKGEueik7XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBub3JtYWxpc2VcbiAqIEByZXR1cm4ge3ZlYzN9IF5hXG4gKi9cbnZlYzMubm9yID0gYSA9PiB7XG4gIGxldCBsZW4gPSB2ZWMzLmxlbihhKTtcbiAgcmV0dXJuIGxlbiA/IHsgeDogYS54IC8gbGVuLCB5OiBhLnkgLyBsZW4sIHo6IGEueiAvIGxlbiB9IDogdmVjMygpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbnZlYzMuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSByb3RhdGlvbiBtYXRyaXhcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHttYXR9IG0gVGhlIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdCA9IChhLCBtKSA9PiB2ZWMzKFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMSkpLCBhKSxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDIpKSwgYSksXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAzKSksIGEpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB4IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHggPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54LFxuICBhLnkgKiBNYXRoLmNvcyhyKSAtIGEueiAqIE1hdGguc2luKHIpLFxuICBhLnkgKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB5IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHkgPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54ICogTWF0aC5jb3MocikgKyBhLnogKiBNYXRoLnNpbihyKSxcbiAgYS55LFxuICAtYS54ICogTWF0aC5zaW4ocikgKyBhLnogKiBNYXRoLmNvcyhyKVxuKTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zIGFyb3VuZCB0aGUgeiBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMy5yb3R6ID0gKGEsIHIpID0+IHZlYzMoXG4gIGEueCAqIE1hdGguY29zKHIpIC0gYS55ICogTWF0aC5zaW4ociksXG4gIGEueCAqIE1hdGguc2luKHIpICsgYS55ICogTWF0aC5jb3MociksXG4gIGEuelxuKTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgYSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcSBUaGUgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMy5yb3RxID0gKHYsIHEpID0+IHtcbiAgaWYgKHEubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIHZlYzMoKTtcbiAgfVxuXG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQocVswXSAqIHFbMF0gKyBxWzFdICogcVsxXSArIHFbMl0gKiBxWzJdICsgcVszXSAqIHFbM10pO1xuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiB2ZWMzKCk7XG4gIH1cblxuICBjb25zdCB1cSA9IFtxWzBdIC8gZCwgcVsxXSAvIGQsIHFbMl0gLyBkLCBxWzNdIC8gZF07XG4gIGNvbnN0IHUgPSB2ZWMzKC4uLnVxLnNsaWNlKDAsIDMpKTtcbiAgY29uc3QgcyA9IHVxWzNdO1xuICByZXR1cm4gdmVjMy5hZGQoXG4gICAgdmVjMy5hZGQoXG4gICAgICB2ZWMzLm11bCh1LCAyICogdmVjMy5kb3QodSwgdikpLFxuICAgICAgdmVjMy5tdWwodiwgcyAqIHMgLSB2ZWMzLmRvdCh1LCB1KSlcbiAgICApLFxuICAgIHZlYzMubXVsKHZlYzMuY3Jvc3ModSwgdiksIDIgKiBzKVxuICApO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgdXNpbmcgRXVsZXIgYW5nbGVzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gZSBUaGUgRXVsZXIgYW5nbGVzIHRvIHJvdGF0ZSBieVxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdGEgPSAoYSwgZSkgPT4gdmVjMy5yb3R6KHZlYzMucm90eSh2ZWMzLnJvdHgoYSwgZS54KSwgZS55KSwgZS56KTtcblxuLyoqXG4gKiBHZXQgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgw5cgYlxuICovXG52ZWMzLmNyb3NzID0gKGEsIGIpID0+IHZlYzMoXG4gIGEueSAqIGIueiAtIGEueiAqIGIueSxcbiAgYS56ICogYi54IC0gYS54ICogYi56LFxuICBhLnggKiBiLnkgLSBhLnkgKiBiLnhcbik7XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGVxdWFsXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZWN0b3JzIGEgYW5kIGIgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xudmVjMy5lcSA9IChhLCBiKSA9PiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLnogPT09IGIuejtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHggYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzMucmFkeCA9IGEgPT4gTWF0aC5hdGFuMihhLnosIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB5IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMzLnJhZHkgPSBhID0+IE1hdGguYXRhbjIoYS54LCBhLnkpO1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeiBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcbiAqL1xudmVjMy5yYWR6ID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS56KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb3B5XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIGNvcHkgb2YgdmVjdG9yIGFcbiAqL1xudmVjMy5jcHkgPSBhID0+IHZlYzMoYSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgM2QgdmVjdG9yXG4gKiBAY2FsbGJhY2sgdmVjM01hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICogQHBhcmFtIHsneCcgfCAneScgfCAneid9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHgsIHkgb3IgeilcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjM30gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG52ZWMzLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JyksIHo6IGYoYS56LCAneicpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScsICddIFRoZSBzZXBhcmF0b3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSAoYSwgcyA9ICcsICcpID0+IGAke2EueH0ke3N9JHthLnl9JHtzfSR7YS56fWA7XG5cbi8qKlxuICogU3dpenpsZSBhIHZlY3RvciB3aXRoIGEgc3RyaW5nIG9mIGNvbXBvbmVudCBsYWJlbHNcbiAqXG4gKiBUaGUgc3RyaW5nIGNhbiBjb250YWluOlxuICogLSBgeGAsIGB5YCBvciBgemBcbiAqIC0gYHVgLCBgdmAgb3IgYHdgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXG4gKiAtIGByYCwgYGdgIG9yIGBiYCAoYWxpYXNlcyBmb3IgYHhgLCBgeWAgYW5kIGB6YCwgcmVzcGVjdGl2ZWx5KVxuICogLSBgWGAsIGBZYCwgYFpgLCBgVWAsIGBWYCwgYFdgLCBgUmAsIGBHYCwgYEJgIChuZWdhdGVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSlcbiAqIC0gYDBgIG9yIGAxYCAodGhlc2Ugd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB1bmNoYW5nZWQpXG4gKiAtIGAuYCB0byByZXR1cm4gdGhlIGNvbXBvbmVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGJlIGF0IHRoaXMgcG9zaXRpb24gKG9yIDApXG4gKlxuICogQW55IG90aGVyIGNoYXJhY3RlcnMgd2lsbCBkZWZhdWx0IHRvIDBcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHN3aXp6bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcz0nLi4uJ10gVGhlIHN3aXp6bGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgc3dpenpsZWQgY29tcG9uZW50c1xuICogQGV4YW1wbGUgPGNhcHRpb24+c3dpenpsaW5nIGEgdmVjdG9yPC9jYXB0aW9uPlxuICogbGV0IGEgPSB2ZWMzKDMsIC0yLCAxKTtcbiAqIHZlYzMuc3dpeihhLCAneCcpOyAgICAgLy8gWzNdXG4gKiB2ZWMzLnN3aXooYSwgJ3p5eCcpOyAgIC8vIFsxLCAtMiwgM11cbiAqIHZlYzMuc3dpeihhLCAneFlaJyk7ICAgLy8gWzMsIDIsIC0xXVxuICogdmVjMy5zd2l6KGEsICdaengnKTsgICAvLyBbLTEsIDEsIDNdXG4gKiB2ZWMzLnN3aXooYSwgJ3gueCcpOyAgIC8vIFszLCAtMiwgM11cbiAqIHZlYzMuc3dpeihhLCAneTAxengnKTsgLy8gWy0yLCAwLCAxLCAxLCAzXVxuICovXG52ZWMzLnN3aXogPSAoYSwgcyA9ICcuLi4nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBzLnNwbGl0KCcnKS5mb3JFYWNoKChjLCBpKSA9PiB7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlICd4JzogY2FzZSAndSc6IGNhc2UgJ3InOiByZXN1bHQucHVzaChhLngpOyBicmVhaztcbiAgICAgIGNhc2UgJ3knOiBjYXNlICd2JzogY2FzZSAnZyc6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xuICAgICAgY2FzZSAneic6IGNhc2UgJ3cnOiBjYXNlICdiJzogcmVzdWx0LnB1c2goYS56KTsgYnJlYWs7XG4gICAgICBjYXNlICdYJzogY2FzZSAnVSc6IGNhc2UgJ1InOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IGNhc2UgJ0cnOiByZXN1bHQucHVzaCgtYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICdaJzogY2FzZSAnVyc6IGNhc2UgJ0InOiByZXN1bHQucHVzaCgtYS56KTsgYnJlYWs7XG4gICAgICBjYXNlICcwJzogcmVzdWx0LnB1c2goMCk7IGJyZWFrO1xuICAgICAgY2FzZSAnMSc6IHJlc3VsdC5wdXNoKDEpOyBicmVhaztcbiAgICAgIGNhc2UgJy4nOiByZXN1bHQucHVzaChbYS54LCBhLnksIGEuel1baV0gPz8gMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgM2QgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzM2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSB0aWx0IGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaGkgVGhlIHBhbiBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMzZH0gVGhlIG1hZ25pdHVkZSwgdGlsdCBhbmQgcGFuIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5wb2xhciA9IGEgPT4ge1xuICBsZXQgciA9IHZlYzMubGVuKGEpLFxuICAgIHRoZXRhID0gTWF0aC5hY29zKGEueSAvIHIpLFxuICAgIHBoaSA9IE1hdGguYXRhbjIoYS56LCBhLngpO1xuICByZXR1cm4geyByLCB0aGV0YSwgcGhpIH07XG59O1xuXG4vKipcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIHRpbHQgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHBoaSBUaGUgcGFuIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcbiAqL1xudmVjMy5mcm9tUG9sYXIgPSAociwgdGhldGEsIHBoaSkgPT4ge1xuICBjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcbiAgcmV0dXJuIHZlYzMoXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5jb3MocGhpKSxcbiAgICByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHIgKiBzaW5UaGV0YSAqIE1hdGguc2luKHBoaSlcbiAgKTtcbn07XG5cbi8qKlxuICogQSBtYXRyaXhcbiAqIEB0eXBlZGVmIHtPYmplY3R9IG1hdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG0gVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWF0cml4XG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGVudHJpZXMgVGhlIG1hdHJpeCB2YWx1ZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbT00XSBUaGUgbnVtYmVyIG9mIHJvd3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj00XSBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW2VudHJpZXM9W11dIE1hdHJpeCB2YWx1ZXMgaW4gcmVhZGluZyBvcmRlclxuICogQHJldHVybiB7bWF0fSBBIG5ldyBtYXRyaXhcbiAqL1xuY29uc3QgbWF0ID0gKG0gPSA0LCBuID0gNCwgZW50cmllcyA9IFtdKSA9PiAoe1xuICBtLCBuLFxuICBlbnRyaWVzOiBlbnRyaWVzLmNvbmNhdChBcnJheShtICogbikuZmlsbCgwKSkuc2xpY2UoMCwgbSAqIG4pXG59KTtcblxuLyoqXG4gKiBHZXQgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7bWF0fSBBbiBpZGVudGl0eSBtYXRyaXhcbiAqL1xubWF0LmlkZW50aXR5ID0gbiA9PiBtYXQobiwgbiwgQXJyYXkobiAqIG4pLmZpbGwoMCkubWFwKCh2LCBpKSA9PiArKE1hdGguZmxvb3IoaSAvIG4pID09PSBpICUgbikpKTtcblxuLyoqXG4gKiBHZXQgYW4gZW50cnkgZnJvbSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUgYXQgcG9zaXRpb24gKGksIGopIGluIG1hdHJpeCBhXG4gKi9cbm1hdC5nZXQgPSAoYSwgaSwgaikgPT4gYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXTtcblxuLyoqXG4gKiBTZXQgYW4gZW50cnkgb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2IFRoZSB2YWx1ZSB0byBzZXQgaW4gbWF0cml4IGFcbiAqL1xubWF0LnNldCA9IChhLCBpLCBqLCB2KSA9PiB7IGEuZW50cmllc1soaiAtIDEpICsgKGkgLSAxKSAqIGEubl0gPSB2OyB9O1xuXG4vKipcbiAqIEdldCBhIHJvdyBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG0gVGhlIHJvdyBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJvdyBtIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LnJvdyA9IChhLCBtKSA9PiB7XG4gIGNvbnN0IHMgPSAobSAtIDEpICogYS5uO1xuICByZXR1cm4gYS5lbnRyaWVzLnNsaWNlKHMsIHMgKyBhLm4pO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjb2x1bW4gZnJvbSBhIG1hdHJpeCBhcyBhbiBhcnJheVxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDb2x1bW4gbiBmcm9tIG1hdHJpeCBhXG4gKi9cbm1hdC5jb2wgPSAoYSwgbikgPT4gX3ZlY190aW1lcyhpID0+IG1hdC5nZXQoYSwgKGkgKyAxKSwgbiksIGEubSk7XG5cbi8qKlxuICogQWRkIG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSArIGJcbiAqL1xubWF0LmFkZCA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2ICsgYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBTdWJ0cmFjdCBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR9IGEgLSBiXG4gKi9cbm1hdC5zdWIgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0Lm1hcChhLCAodiwgaSkgPT4gdiAtIGIuZW50cmllc1tpXSk7XG5cbi8qKlxuICogTXVsdGlwbHkgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cmljZXMgY2Fubm90IGJlIG11bHRpcGxpZWRcbiAqL1xubWF0Lm11bCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLm4gIT09IGIubSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgcmVzdWx0ID0gbWF0KGEubSwgYi5uKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBiLm47IGorKykge1xuICAgICAgbWF0LnNldChyZXN1bHQsIGksIGosIF92ZWNfZG90KG1hdC5yb3coYSwgaSksIG1hdC5jb2woYiwgaikpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYSBtYXRyaXggYnkgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge3ZlYzJ8dmVjM3xudW1iZXJbXX0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjMnx2ZWMzfG51bWJlcltdfGZhbHNlfSBhYiBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGFuZCB2ZWN0b3IgY2Fubm90IGJlIG11bHRpcGxpZWRcbiAqL1xubWF0Lm11bHYgPSAoYSwgYikgPT4ge1xuICBsZXQgbiwgYmIsIHJ0O1xuICBpZiAoX3ZlY19pc192ZWMzKGIpKSB7XG4gICAgYmIgPSB2ZWMzLmNvbXBvbmVudHMoYik7XG4gICAgbiA9IDM7XG4gICAgcnQgPSB2ZWMzLmZyb21Db21wb25lbnRzO1xuICB9IGVsc2UgaWYgKF92ZWNfaXNfdmVjMihiKSkge1xuICAgIGJiID0gdmVjMi5jb21wb25lbnRzKGIpO1xuICAgIG4gPSAyO1xuICAgIHJ0ID0gdmVjMi5mcm9tQ29tcG9uZW50cztcbiAgfSBlbHNlIHtcbiAgICBiYiA9IGI7XG4gICAgbiA9IGIubGVuZ3RoID8/IDA7XG4gICAgcnQgPSB2ID0+IHY7XG4gIH1cbiAgaWYgKGEubiAhPT0gbikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgcmVzdWx0LnB1c2goX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgYmIpKTtcbiAgfVxuICByZXR1cm4gcnQocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBTY2FsZSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFNjYWxhciBiXG4gKiBAcmV0dXJuIHttYXR9IGEgKiBiXG4gKi9cbm1hdC5zY2FsZSA9IChhLCBiKSA9PiBtYXQubWFwKGEsIHYgPT4gdiAqIGIpO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCB0byB0cmFuc3Bvc2VcbiAqIEByZXR1cm4ge21hdH0gQSB0cmFuc3Bvc2VkIG1hdHJpeFxuICovXG5tYXQudHJhbnMgPSBhID0+IG1hdChhLm4sIGEubSwgX3ZlY190aW1lcyhpID0+IG1hdC5jb2woYSwgKGkgKyAxKSksIGEubikuZmxhdCgpKTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pbm9yIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IFRoZSAoaSwgaikgbWlub3Igb2YgbWF0cml4IGEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXG4gKi9cbm1hdC5taW5vciA9IChhLCBpLCBqKSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBmb3IgKGxldCBpaSA9IDE7IGlpIDw9IGEubTsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaSkgeyBjb250aW51ZTsgfVxuICAgIGZvciAobGV0IGpqID0gMTsgamogPD0gYS5uOyBqaisrKSB7XG4gICAgICBpZiAoamogPT09IGopIHsgY29udGludWU7IH1cbiAgICAgIGVudHJpZXMucHVzaChtYXQuZ2V0KGEsIGlpLCBqaikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0KGEubSAtIDEsIGEubiAtIDEsIGVudHJpZXMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRldGVybWluYW50IG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHJldHVybiB7bnVtYmVyfGZhbHNlfSB8YXwgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBpcyBub3Qgc3F1YXJlXG4gKi9cbm1hdC5kZXQgPSBhID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYS5tID09PSAxKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXTtcbiAgfVxuICBpZiAoYS5tID09PSAyKSB7XG4gICAgcmV0dXJuIGEuZW50cmllc1swXSAqIGEuZW50cmllc1szXSAtIGEuZW50cmllc1sxXSAqIGEuZW50cmllc1syXTtcbiAgfVxuICBsZXQgdG90YWwgPSAwLCBzaWduID0gMTtcbiAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICB0b3RhbCArPSBzaWduICogYS5lbnRyaWVzW2ogLSAxXSAqIG1hdC5kZXQobWF0Lm1pbm9yKGEsIDEsIGopKTtcbiAgICBzaWduICo9IC0xO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXNlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7bWF0fGZhbHNlfSBeYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0Lm5vciA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xuICByZXR1cm4gbWF0Lm1hcChhLCBpID0+IGkgKiBkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgVGhlIG1hdHJpeCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgYWRqdWdhdGVcbiAqIEByZXR1cm4ge21hdH0gVGhlIGFkanVnYXRlIG9mIGFcbiAqL1xubWF0LmFkaiA9IGEgPT4ge1xuICBjb25zdCBtaW5vcnMgPSBtYXQoYS5tLCBhLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGEubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KG1pbm9ycywgaSwgaiwgbWF0LmRldChtYXQubWlub3IoYSwgaSwgaikpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY29mYWN0b3JzID0gbWF0Lm1hcChtaW5vcnMsICh2LCBpKSA9PiB2ICogKGkgJSAyID8gLTEgOiAxKSk7XG4gIHJldHVybiBtYXQudHJhbnMoY29mYWN0b3JzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnNlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGludmVydFxuICogQHJldHVybiB7bWF0fGZhbHNlfSBhXi0xIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaGFzIG5vIGludmVyc2VcbiAqL1xubWF0LmludiA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbnN0IGQgPSBtYXQuZGV0KGEpO1xuICBpZiAoZCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgcmV0dXJuIG1hdC5zY2FsZShtYXQuYWRqKGEpLCAxIC8gZCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtYXRyaWNlcyBhIGFuZCBiIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5tYXQuZXEgPSAoYSwgYikgPT4gYS5tID09PSBiLm0gJiYgYS5uID09PSBiLm4gJiYgbWF0LnN0cihhKSA9PT0gbWF0LnN0cihiKTtcblxuLyoqXG4gKiBDb3B5IGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm4ge21hdH0gQSBjb3B5IG9mIG1hdHJpeCBhXG4gKi9cbm1hdC5jcHkgPSBhID0+IG1hdChhLm0sIGEubiwgWy4uLmEuZW50cmllc10pO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIGEgbWF0cml4XG4gKiBAY2FsbGJhY2sgbWF0cml4TWFwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZW50cnkgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgZW50cnkgaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgYXJyYXkgb2YgbWF0cml4IGVudHJpZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBlbnRyeVxuICovXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXggYW5kIGJ1aWxkIGEgbmV3IG1hdHJpeCBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXRyaXhNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGVudHJ5IG9mIHRoZSBtYXRyaXhcbiAqIEByZXR1cm4ge21hdH0gTWF0cml4IGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG5tYXQubWFwID0gKGEsIGYpID0+IG1hdChhLm0sIGEubiwgYS5lbnRyaWVzLm1hcChmKSk7XG5cbi8qKlxuICogQ29udmVydCBhIG1hdHJpeCBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbXM9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIGNvbHVtbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbnM9J1xcbiddIFRoZSBzZXBhcmF0b3Igc3RyaW5nIGZvciByb3dzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0LnN0ciA9IChhLCBtcyA9ICcsICcsIG5zID0gJ1xcbicpID0+IF92ZWNfY2h1bmsoYS5lbnRyaWVzLCBhLm4pLm1hcChyID0+IHIuam9pbihtcykpLmpvaW4obnMpO1xuXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjMiwgdmVjMywgbWF0IH07XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVjb21wOiBwb2x5Z29uRGVjb21wLFxuICAgIHF1aWNrRGVjb21wOiBwb2x5Z29uUXVpY2tEZWNvbXAsXG4gICAgaXNTaW1wbGU6IHBvbHlnb25Jc1NpbXBsZSxcbiAgICByZW1vdmVDb2xsaW5lYXJQb2ludHM6IHBvbHlnb25SZW1vdmVDb2xsaW5lYXJQb2ludHMsXG4gICAgcmVtb3ZlRHVwbGljYXRlUG9pbnRzOiBwb2x5Z29uUmVtb3ZlRHVwbGljYXRlUG9pbnRzLFxuICAgIG1ha2VDQ1c6IHBvbHlnb25NYWtlQ0NXXG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byBsaW5lcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGluZUludFxuICogQHBhcmFtICB7QXJyYXl9ICBsMSAgICAgICAgICBMaW5lIHZlY3RvciAxXG4gKiBAcGFyYW0gIHtBcnJheX0gIGwyICAgICAgICAgIExpbmUgdmVjdG9yIDJcbiAqIEBwYXJhbSAge051bWJlcn0gcHJlY2lzaW9uICAgUHJlY2lzaW9uIHRvIHVzZSB3aGVuIGNoZWNraW5nIGlmIHRoZSBsaW5lcyBhcmUgcGFyYWxsZWxcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGludGVyc2VjdGlvbiBwb2ludC5cbiAqL1xuZnVuY3Rpb24gbGluZUludChsMSxsMixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHZhciBpID0gWzAsMF07IC8vIHBvaW50XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzIsIGRldDsgLy8gc2NhbGFyc1xuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XG4gICAgYzEgPSBhMSAqIGwxWzBdWzBdICsgYjEgKiBsMVswXVsxXTtcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xuICAgIGMyID0gYTIgKiBsMlswXVswXSArIGIyICogbDJbMF1bMV07XG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xuICAgIGlmICghc2NhbGFyX2VxKGRldCwgMCwgcHJlY2lzaW9uKSkgeyAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdHMuXG4gKiBAbWV0aG9kIHNlZ21lbnRzSW50ZXJzZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwMSBUaGUgc3RhcnQgdmVydGV4IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcTEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHEyIFRoZSBlbmQgdmVydGV4IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIGxpbmVTZWdtZW50c0ludGVyc2VjdChwMSwgcDIsIHExLCBxMil7XG5cdHZhciBkeCA9IHAyWzBdIC0gcDFbMF07XG5cdHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG5cdHZhciBkYSA9IHEyWzBdIC0gcTFbMF07XG5cdHZhciBkYiA9IHEyWzFdIC0gcTFbMV07XG5cblx0Ly8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXG5cdGlmKChkYSpkeSAtIGRiKmR4KSA9PT0gMCl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIHMgPSAoZHggKiAocTFbMV0gLSBwMVsxXSkgKyBkeSAqIChwMVswXSAtIHExWzBdKSkgLyAoZGEgKiBkeSAtIGRiICogZHgpO1xuXHR2YXIgdCA9IChkYSAqIChwMVsxXSAtIHExWzFdKSArIGRiICogKHExWzBdIC0gcDFbMF0pKSAvIChkYiAqIGR4IC0gZGEgKiBkeSk7XG5cblx0cmV0dXJuIChzPj0wICYmIHM8PTEgJiYgdD49MCAmJiB0PD0xKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgYSB0cmlhbmdsZSBzcGFubmVkIGJ5IHRoZSB0aHJlZSBnaXZlbiBwb2ludHMuIE5vdGUgdGhhdCB0aGUgYXJlYSB3aWxsIGJlIG5lZ2F0aXZlIGlmIHRoZSBwb2ludHMgYXJlIG5vdCBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlci5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgYXJlYVxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiB0cmlhbmdsZUFyZWEoYSxiLGMpe1xuICAgIHJldHVybiAoKChiWzBdIC0gYVswXSkqKGNbMV0gLSBhWzFdKSktKChjWzBdIC0gYVswXSkqKGJbMV0gLSBhWzFdKSkpO1xufVxuXG5mdW5jdGlvbiBpc0xlZnQoYSxiLGMpe1xuICAgIHJldHVybiB0cmlhbmdsZUFyZWEoYSxiLGMpID4gMDtcbn1cblxuZnVuY3Rpb24gaXNMZWZ0T24oYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpID49IDA7XG59XG5cbmZ1bmN0aW9uIGlzUmlnaHQoYSxiLGMpIHtcbiAgICByZXR1cm4gdHJpYW5nbGVBcmVhKGEsIGIsIGMpIDwgMDtcbn1cblxuZnVuY3Rpb24gaXNSaWdodE9uKGEsYixjKSB7XG4gICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA8PSAwO1xufVxuXG52YXIgdG1wUG9pbnQxID0gW10sXG4gICAgdG1wUG9pbnQyID0gW107XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhyZWUgcG9pbnRzIGFyZSBjb2xsaW5lYXJcbiAqIEBtZXRob2QgY29sbGluZWFyXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge0FycmF5fSBjXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT0wXSBUaHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gY29tcGFyaW5nIHRoZSB2ZWN0b3JzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgcmVzdWx0aW5nIHZlY3RvcnMgaXMgbGVzcyB0aGFuIHRoaXMgdmFsdWUuIFVzZSB6ZXJvIGZvciBtYXggcHJlY2lzaW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29sbGluZWFyKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XG4gICAgaWYoIXRocmVzaG9sZEFuZ2xlKXtcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSA9PT0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYWIgPSB0bXBQb2ludDEsXG4gICAgICAgICAgICBiYyA9IHRtcFBvaW50MjtcblxuICAgICAgICBhYlswXSA9IGJbMF0tYVswXTtcbiAgICAgICAgYWJbMV0gPSBiWzFdLWFbMV07XG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xuICAgICAgICBiY1sxXSA9IGNbMV0tYlsxXTtcblxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcbiAgICAgICAgICAgIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0qYWJbMF0gKyBhYlsxXSphYlsxXSksXG4gICAgICAgICAgICBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdKmJjWzBdICsgYmNbMV0qYmNbMV0pLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcWRpc3QoYSxiKXtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8qKlxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxuICogQG1ldGhvZCBhdFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkF0KHBvbHlnb24sIGkpe1xuICAgIHZhciBzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgcmV0dXJuIHBvbHlnb25baSA8IDAgPyBpICUgcyArIHMgOiBpICUgc107XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHBvbHlnb24gZGF0YVxuICogQG1ldGhvZCBjbGVhclxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DbGVhcihwb2x5Z29uKXtcbiAgICBwb2x5Z29uLmxlbmd0aCA9IDA7XG59XG5cbi8qKlxuICogQXBwZW5kIHBvaW50cyBcImZyb21cIiB0byBcInRvXCItMSBmcm9tIGFuIG90aGVyIHBvbHlnb24gXCJwb2x5XCIgb250byB0aGlzIG9uZS5cbiAqIEBtZXRob2QgYXBwZW5kXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHkgVGhlIHBvbHlnb24gdG8gZ2V0IHBvaW50cyBmcm9tLlxuICogQHBhcmFtIHtOdW1iZXJ9ICBmcm9tIFRoZSB2ZXJ0ZXggaW5kZXggaW4gXCJwb2x5XCIuXG4gKiBAcGFyYW0ge051bWJlcn0gIHRvIFRoZSBlbmQgdmVydGV4IGluZGV4IGluIFwicG9seVwiLiBOb3RlIHRoYXQgdGhpcyB2ZXJ0ZXggaXMgTk9UIGluY2x1ZGVkIHdoZW4gYXBwZW5kaW5nLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25BcHBlbmQocG9seWdvbiwgcG9seSwgZnJvbSwgdG8pe1xuICAgIGZvcih2YXIgaT1mcm9tOyBpPHRvOyBpKyspe1xuICAgICAgICBwb2x5Z29uLnB1c2gocG9seVtpXSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2x5Z29uIHZlcnRpY2VzIGFyZSBvcmRlcmVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICogQG1ldGhvZCBtYWtlQ0NXXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25NYWtlQ0NXKHBvbHlnb24pe1xuICAgIHZhciBiciA9IDAsXG4gICAgICAgIHYgPSBwb2x5Z29uO1xuXG4gICAgLy8gZmluZCBib3R0b20gcmlnaHQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHZbaV1bMV0gPCB2W2JyXVsxXSB8fCAodltpXVsxXSA9PT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xuICAgICAgICAgICAgYnIgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxuICAgIGlmICghaXNMZWZ0KHBvbHlnb25BdChwb2x5Z29uLCBiciAtIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYnIpLCBwb2x5Z29uQXQocG9seWdvbiwgYnIgKyAxKSkpIHtcbiAgICAgICAgcG9seWdvblJldmVyc2UocG9seWdvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5mdW5jdGlvbiBwb2x5Z29uUmV2ZXJzZShwb2x5Z29uKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIE4gPSBwb2x5Z29uLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHRtcC5wdXNoKHBvbHlnb24ucG9wKCkpO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG5cdFx0cG9seWdvbltpXSA9IHRtcFtpXTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpe1xuICAgIHJldHVybiBpc1JpZ2h0KHBvbHlnb25BdChwb2x5Z29uLCBpIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkgKyAxKSk7XG59XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUocG9seWdvbiwgYSxiKSB7XG4gICAgdmFyIHAsIGRpc3QsIGwxPXRtcExpbmUxLCBsMj10bXBMaW5lMjtcblxuICAgIGlmIChpc0xlZnRPbihwb2x5Z29uQXQocG9seWdvbiwgYSArIDEpLCBwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5Z29uLCBhIC0gMSksIHBvbHlnb25BdChwb2x5Z29uLCBhKSwgcG9seWdvbkF0KHBvbHlnb24sIGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBzcWRpc3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBwb2x5Z29uLmxlbmd0aDsgKytpKSB7IC8vIGZvciBlYWNoIGVkZ2VcbiAgICAgICAgaWYgKChpICsgMSkgJSBwb2x5Z29uLmxlbmd0aCA9PT0gYSB8fCBpID09PSBhKXsgLy8gaWdub3JlIGluY2lkZW50IGVkZ2VzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMZWZ0T24ocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpICsgMSkpICYmIGlzUmlnaHRPbihwb2x5Z29uQXQocG9seWdvbiwgYSksIHBvbHlnb25BdChwb2x5Z29uLCBiKSwgcG9seWdvbkF0KHBvbHlnb24sIGkpKSkgeyAvLyBpZiBkaWFnIGludGVyc2VjdHMgYW4gZWRnZVxuICAgICAgICAgICAgbDFbMF0gPSBwb2x5Z29uQXQocG9seWdvbiwgYSk7XG4gICAgICAgICAgICBsMVsxXSA9IHBvbHlnb25BdChwb2x5Z29uLCBiKTtcbiAgICAgICAgICAgIGwyWzBdID0gcG9seWdvbkF0KHBvbHlnb24sIGkpO1xuICAgICAgICAgICAgbDJbMV0gPSBwb2x5Z29uQXQocG9seWdvbiwgaSArIDEpO1xuICAgICAgICAgICAgcCA9IGxpbmVJbnQobDEsbDIpO1xuICAgICAgICAgICAgaWYgKHNxZGlzdChwb2x5Z29uQXQocG9seWdvbiwgYSksIHApIDwgZGlzdCkgeyAvLyBpZiBlZGdlIGlzIGJsb2NraW5nIHZpc2liaWxpdHkgdG8gYlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbiBjYW4gc2VlIGVhY2ggb3RoZXJcbiAqIEBtZXRob2QgY2FuU2VlMlxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25DYW5TZWUyKHBvbHlnb24sIGEsYikge1xuICAgIC8vIGZvciBlYWNoIGVkZ2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcbiAgICAgICAgaWYgKGkgPT09IGEgfHwgaSA9PT0gYiB8fCAoaSArIDEpICUgcG9seWdvbi5sZW5ndGggPT09IGEgfHwgKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoID09PSBiKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKCBsaW5lU2VnbWVudHNJbnRlcnNlY3QocG9seWdvbkF0KHBvbHlnb24sIGEpLCBwb2x5Z29uQXQocG9seWdvbiwgYiksIHBvbHlnb25BdChwb2x5Z29uLCBpKSwgcG9seWdvbkF0KHBvbHlnb24sIGkrMSkpICl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weSB0aGUgcG9seWdvbiBmcm9tIHZlcnRleCBpIHRvIHZlcnRleCBqLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtICB7UG9seWdvbn0gW3RhcmdldFBvbHldICAgT3B0aW9uYWwgdGFyZ2V0IHBvbHlnb24gdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1BvbHlnb259ICAgICAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgY29weS5cbiAqL1xuZnVuY3Rpb24gcG9seWdvbkNvcHkocG9seWdvbiwgaSxqLHRhcmdldFBvbHkpe1xuICAgIHZhciBwID0gdGFyZ2V0UG9seSB8fCBbXTtcbiAgICBwb2x5Z29uQ2xlYXIocCk7XG4gICAgaWYgKGkgPCBqKSB7XG4gICAgICAgIC8vIEluc2VydCBhbGwgdmVydGljZXMgZnJvbSBpIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8PWo7IGsrKyl7XG4gICAgICAgICAgICBwLnB1c2gocG9seWdvbltrXSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSW5zZXJ0IHZlcnRpY2VzIDAgdG8galxuICAgICAgICBmb3IodmFyIGs9MDsgazw9ajsgaysrKXtcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyBpIHRvIGVuZFxuICAgICAgICBmb3IodmFyIGs9aTsgazxwb2x5Z29uLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgIHAucHVzaChwb2x5Z29uW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBjb252ZXggcGllY2VzLiBSZXR1cm5zIGEgbGlzdCBvZiBlZGdlcyBbW3AxLHAyXSxbcDIscDNdLC4uLl0gdGhhdCBjdXRzIHRoZSBwb2x5Z29uLlxuICogTm90ZSB0aGF0IHRoaXMgYWxnb3JpdGhtIGhhcyBjb21wbGV4aXR5IE8oTl40KSBhbmQgd2lsbCBiZSB2ZXJ5IHNsb3cgZm9yIHBvbHlnb25zIHdpdGggbWFueSB2ZXJ0aWNlcy5cbiAqIEBtZXRob2QgZ2V0Q3V0RWRnZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBwb2x5Z29uR2V0Q3V0RWRnZXMocG9seWdvbikge1xuICAgIHZhciBtaW49W10sIHRtcDE9W10sIHRtcDI9W10sIHRtcFBvbHkgPSBbXTtcbiAgICB2YXIgbkRpYWdzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seWdvbklzUmVmbGV4KHBvbHlnb24sIGkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb24ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNhblNlZShwb2x5Z29uLCBpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICB0bXAxID0gcG9seWdvbkdldEN1dEVkZ2VzKHBvbHlnb25Db3B5KHBvbHlnb24sIGksIGosIHRtcFBvbHkpKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wMiA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uQ29weShwb2x5Z29uLCBqLCBpLCB0bXBQb2x5KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8dG1wMi5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAxLnB1c2godG1wMltrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wMS5sZW5ndGggPCBuRGlhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHRtcDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBuRGlhZ3MgPSB0bXAxLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbi5wdXNoKFtwb2x5Z29uQXQocG9seWdvbiwgaSksIHBvbHlnb25BdChwb2x5Z29uLCBqKV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBEZWNvbXBvc2VzIHRoZSBwb2x5Z29uIGludG8gb25lIG9yIG1vcmUgY29udmV4IHN1Yi1Qb2x5Z29ucy5cbiAqIEBtZXRob2QgZGVjb21wXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb3IgUG9seWdvbiBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBwb2x5Z29uRGVjb21wKHBvbHlnb24pe1xuICAgIHZhciBlZGdlcyA9IHBvbHlnb25HZXRDdXRFZGdlcyhwb2x5Z29uKTtcbiAgICBpZihlZGdlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgcmV0dXJuIHBvbHlnb25TbGljZShwb2x5Z29uLCBlZGdlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtwb2x5Z29uXTtcbiAgICB9XG59XG5cbi8qKlxuICogU2xpY2VzIHRoZSBwb2x5Z29uIGdpdmVuIG9uZSBvciBtb3JlIGN1dCBlZGdlcy4gSWYgZ2l2ZW4gb25lLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHR3byBwb2x5Z29ucyAoZmFsc2Ugb24gZmFpbHVyZSkuIElmIG1hbnksIGFuIGFycmF5IG9mIHBvbHlnb25zLlxuICogQG1ldGhvZCBzbGljZVxuICogQHBhcmFtIHtBcnJheX0gY3V0RWRnZXMgQSBsaXN0IG9mIGVkZ2VzLCBhcyByZXR1cm5lZCBieSAuZ2V0Q3V0RWRnZXMoKVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25TbGljZShwb2x5Z29uLCBjdXRFZGdlcyl7XG4gICAgaWYoY3V0RWRnZXMubGVuZ3RoID09PSAwKXtcblx0XHRyZXR1cm4gW3BvbHlnb25dO1xuICAgIH1cbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09PTIgJiYgY3V0RWRnZXNbMF1bMF0gaW5zdGFuY2VvZiBBcnJheSl7XG5cbiAgICAgICAgdmFyIHBvbHlzID0gW3BvbHlnb25dO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGN1dEVkZ2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXNbaV07XG4gICAgICAgICAgICAvLyBDdXQgYWxsIHBvbHlzXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxwb2x5cy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBwb2x5c1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcG9seWdvblNsaWNlKHBvbHksIGN1dEVkZ2UpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIHBvbHkhIEN1dCBhbmQgcXVpdFxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0scmVzdWx0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gV2FzIGdpdmVuIG9uZSBlZGdlXG4gICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXM7XG4gICAgICAgIHZhciBpID0gcG9seWdvbi5pbmRleE9mKGN1dEVkZ2VbMF0pO1xuICAgICAgICB2YXIgaiA9IHBvbHlnb24uaW5kZXhPZihjdXRFZGdlWzFdKTtcblxuICAgICAgICBpZihpICE9PSAtMSAmJiBqICE9PSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW3BvbHlnb25Db3B5KHBvbHlnb24sIGksaiksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25Db3B5KHBvbHlnb24sIGosaSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB0aGF0IHRoZSBsaW5lIHNlZ21lbnRzIG9mIHRoaXMgcG9seWdvbiBkbyBub3QgaW50ZXJzZWN0IGVhY2ggb3RoZXIuXG4gKiBAbWV0aG9kIGlzU2ltcGxlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGF0aCBBbiBhcnJheSBvZiB2ZXJ0aWNlcyBlLmcuIFtbMCwwXSxbMCwxXSwuLi5dXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gU2hvdWxkIGl0IGNoZWNrIGFsbCBzZWdtZW50cyB3aXRoIGFsbCBvdGhlcnM/XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Jc1NpbXBsZShwb2x5Z29uKXtcbiAgICB2YXIgcGF0aCA9IHBvbHlnb24sIGk7XG4gICAgLy8gQ2hlY2tcbiAgICBmb3IoaT0wOyBpPHBhdGgubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGktMTsgaisrKXtcbiAgICAgICAgICAgIGlmKGxpbmVTZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xuICAgIGZvcihpPTE7IGk8cGF0aC5sZW5ndGgtMjsgaSsrKXtcbiAgICAgICAgaWYobGluZVNlZ21lbnRzSW50ZXJzZWN0KHBhdGhbMF0sIHBhdGhbcGF0aC5sZW5ndGgtMV0sIHBhdGhbaV0sIHBhdGhbaSsxXSApKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludChwMSwgcDIsIHExLCBxMiwgZGVsdGEpe1xuXHRkZWx0YSA9IGRlbHRhIHx8IDA7XG5cdHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XG5cdHZhciBiMSA9IHAxWzBdIC0gcDJbMF07XG5cdHZhciBjMSA9IChhMSAqIHAxWzBdKSArIChiMSAqIHAxWzFdKTtcblx0dmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcblx0dmFyIGIyID0gcTFbMF0gLSBxMlswXTtcblx0dmFyIGMyID0gKGEyICogcTFbMF0pICsgKGIyICogcTFbMV0pO1xuXHR2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xuXG5cdGlmKCFzY2FsYXJfZXEoZGV0LDAsZGVsdGEpKXtcblx0XHRyZXR1cm4gWygoYjIgKiBjMSkgLSAoYjEgKiBjMikpIC8gZGV0LCAoKGExICogYzIpIC0gKGEyICogYzEpKSAvIGRldF07XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFswLDBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBRdWlja2x5IGRlY29tcG9zZSB0aGUgUG9seWdvbiBpbnRvIGNvbnZleCBzdWItcG9seWdvbnMuXG4gKiBAbWV0aG9kIHF1aWNrRGVjb21wXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVzdWx0XG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlZmxleFZlcnRpY2VzXVxuICogQHBhcmFtICB7QXJyYXl9IFtzdGVpbmVyUG9pbnRzXVxuICogQHBhcmFtICB7TnVtYmVyfSBbZGVsdGFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXhsZXZlbF1cbiAqIEBwYXJhbSAge051bWJlcn0gW2xldmVsXVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25RdWlja0RlY29tcChwb2x5Z29uLCByZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCl7XG4gICAgbWF4bGV2ZWwgPSBtYXhsZXZlbCB8fCAxMDA7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMjU7XG4gICAgcmVzdWx0ID0gdHlwZW9mKHJlc3VsdCkhPT1cInVuZGVmaW5lZFwiID8gcmVzdWx0IDogW107XG4gICAgcmVmbGV4VmVydGljZXMgPSByZWZsZXhWZXJ0aWNlcyB8fCBbXTtcbiAgICBzdGVpbmVyUG9pbnRzID0gc3RlaW5lclBvaW50cyB8fCBbXTtcblxuICAgIHZhciB1cHBlckludD1bMCwwXSwgbG93ZXJJbnQ9WzAsMF0sIHA9WzAsMF07IC8vIFBvaW50c1xuICAgIHZhciB1cHBlckRpc3Q9MCwgbG93ZXJEaXN0PTAsIGQ9MCwgY2xvc2VzdERpc3Q9MDsgLy8gc2NhbGFyc1xuICAgIHZhciB1cHBlckluZGV4PTAsIGxvd2VySW5kZXg9MCwgY2xvc2VzdEluZGV4PTA7IC8vIEludGVnZXJzXG4gICAgdmFyIGxvd2VyUG9seT1bXSwgdXBwZXJQb2x5PVtdOyAvLyBwb2x5Z29uc1xuICAgIHZhciBwb2x5ID0gcG9seWdvbixcbiAgICAgICAgdiA9IHBvbHlnb247XG5cbiAgICBpZih2Lmxlbmd0aCA8IDMpe1xuXHRcdHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbGV2ZWwrKztcbiAgICBpZihsZXZlbCA+IG1heGxldmVsKXtcbiAgICAgICAgY29uc29sZS53YXJuKFwicXVpY2tEZWNvbXA6IG1heCBsZXZlbCAoXCIrbWF4bGV2ZWwrXCIpIHJlYWNoZWQuXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocG9seWdvbklzUmVmbGV4KHBvbHksIGkpKSB7XG4gICAgICAgICAgICByZWZsZXhWZXJ0aWNlcy5wdXNoKHBvbHlbaV0pO1xuICAgICAgICAgICAgdXBwZXJEaXN0ID0gbG93ZXJEaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb24ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSAmJiBpc1JpZ2h0T24ocG9seWdvbkF0KHBvbHksIGkgLSAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiAtIDEpKSkgeyAvLyBpZiBsaW5lIGludGVyc2VjdHMgd2l0aCBhbiBlZGdlXG4gICAgICAgICAgICAgICAgICAgIHAgPSBnZXRJbnRlcnNlY3Rpb25Qb2ludChwb2x5Z29uQXQocG9seSwgaSAtIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHBvbHlnb25BdChwb2x5LCBqKSwgcG9seWdvbkF0KHBvbHksIGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodChwb2x5Z29uQXQocG9seSwgaSArIDEpLCBwb2x5Z29uQXQocG9seSwgaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHNxZGlzdChwb2x5W2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGogKyAxKSkgJiYgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seWdvbkF0KHBvbHksIGkgKyAxKSwgcG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaiksIHBvbHlnb25BdChwb2x5LCBqICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWZ0KHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seVtpXSwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IHVwcGVyRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyRGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdmVydGljZXMgdG8gY29ubmVjdCB0bywgY2hvb3NlIGEgcG9pbnQgaW4gdGhlIG1pZGRsZVxuICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT09ICh1cHBlckluZGV4ICsgMSkgJSBwb2x5Z29uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcbiAgICAgICAgICAgICAgICBwWzFdID0gKGxvd2VySW50WzFdICsgdXBwZXJJbnRbMV0pIC8gMjtcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwgaSwgdXBwZXJJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LGxvd2VySW5kZXgscG9seS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSwwLGkrMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5lbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHBvbHkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2xvd2VyUG9seS5pbnNlcnQobG93ZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIHVwcGVySW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZChsb3dlclBvbHksIHBvbHksMCx1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksbG93ZXJJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdCB0byB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhc2UgMjogVmVydGV4KFwiK2krXCIpLCBjbG9zZXN0SW5kZXgoXCIrY2xvc2VzdEluZGV4K1wiKSwgcG9seS5zaXplKFwiK3BvbHlnb24ubGVuZ3RoK1wiKVxcblwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID4gdXBwZXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ICs9IHBvbHlnb24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgICAgICAgICBpZih1cHBlckluZGV4IDwgbG93ZXJJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxvd2VySW5kZXg7IGogPD0gdXBwZXJJbmRleDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVmdE9uKHBvbHlnb25BdChwb2x5LCBpIC0gMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSaWdodE9uKHBvbHlnb25BdChwb2x5LCBpICsgMSksIHBvbHlnb25BdChwb2x5LCBpKSwgcG9seWdvbkF0KHBvbHksIGopKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBzcWRpc3QocG9seWdvbkF0KHBvbHksIGkpLCBwb2x5Z29uQXQocG9seSwgaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCAmJiBwb2x5Z29uQ2FuU2VlMihwb2x5LCBpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgcG9seWdvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RJbmRleCAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKHVwcGVyUG9seSwgcG9seSxjbG9zZXN0SW5kZXgsdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25BcHBlbmQodXBwZXJQb2x5LCBwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSxpLHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uQXBwZW5kKGxvd2VyUG9seSwgcG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbkFwcGVuZCh1cHBlclBvbHksIHBvbHksY2xvc2VzdEluZGV4LGkrMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2x2ZSBzbWFsbGVzdCBwb2x5IGZpcnN0XG4gICAgICAgICAgICBpZiAobG93ZXJQb2x5Lmxlbmd0aCA8IHVwcGVyUG9seS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAobG93ZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uUXVpY2tEZWNvbXAodXBwZXJQb2x5LHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKHVwcGVyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICAgICAgcG9seWdvblF1aWNrRGVjb21wKGxvd2VyUG9seSxyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJlbW92ZSBjb2xsaW5lYXIgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuICogQG1ldGhvZCByZW1vdmVDb2xsaW5lYXJQb2ludHNcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl0gVGhlIHRocmVzaG9sZCBhbmdsZSB0byB1c2Ugd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHR3byBlZGdlcyBhcmUgY29sbGluZWFyLiBVc2UgemVybyBmb3IgZmluZXN0IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlbW92ZWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvblJlbW92ZUNvbGxpbmVhclBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xuICAgIHZhciBudW0gPSAwO1xuICAgIGZvcih2YXIgaT1wb2x5Z29uLmxlbmd0aC0xOyBwb2x5Z29uLmxlbmd0aD4zICYmIGk+PTA7IC0taSl7XG4gICAgICAgIGlmKGNvbGxpbmVhcihwb2x5Z29uQXQocG9seWdvbiwgaS0xKSxwb2x5Z29uQXQocG9seWdvbiwgaSkscG9seWdvbkF0KHBvbHlnb24sIGkrMSkscHJlY2lzaW9uKSl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgcG9seWdvbi5zcGxpY2UoaSVwb2x5Z29uLmxlbmd0aCwxKTtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSBwb2ludHMgaW4gdGhlIHBvbHlnb24uXG4gKiBAbWV0aG9kIHJlbW92ZUR1cGxpY2F0ZVBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXSBUaGUgdGhyZXNob2xkIHRvIHVzZSB3aGVuIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgdGhlIHNhbWUuIFVzZSB6ZXJvIGZvciBiZXN0IHByZWNpc2lvbi5cbiAqL1xuZnVuY3Rpb24gcG9seWdvblJlbW92ZUR1cGxpY2F0ZVBvaW50cyhwb2x5Z29uLCBwcmVjaXNpb24pe1xuICAgIGZvcih2YXIgaT1wb2x5Z29uLmxlbmd0aC0xOyBpPj0xOyAtLWkpe1xuICAgICAgICB2YXIgcGkgPSBwb2x5Z29uW2ldO1xuICAgICAgICBmb3IodmFyIGo9aS0xOyBqPj0wOyAtLWope1xuICAgICAgICAgICAgaWYocG9pbnRzX2VxKHBpLCBwb2x5Z29uW2pdLCBwcmVjaXNpb24pKXtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLnNwbGljZShpLDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBzY2FsYXJzIGFyZSBlcXVhbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBlcVxuICogQHBhcmFtICB7TnVtYmVyfSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNjYWxhcl9lcShhLGIscHJlY2lzaW9uKXtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgICByZXR1cm4gTWF0aC5hYnMoYS1iKSA8PSBwcmVjaXNpb247XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcG9pbnRzX2VxXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEBwYXJhbSAge051bWJlcn0gW3ByZWNpc2lvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHBvaW50c19lcShhLGIscHJlY2lzaW9uKXtcbiAgICByZXR1cm4gc2NhbGFyX2VxKGFbMF0sYlswXSxwcmVjaXNpb24pICYmIHNjYWxhcl9lcShhWzFdLGJbMV0scHJlY2lzaW9uKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy8yZC9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy8yZC9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLmFuZ2xlQmV0d2VlbiA9IGFuZ2xlQmV0d2VlbjtcbmV4cG9ydHMucG9pbnRzQXJlQ29sbGluZWFyID0gcG9pbnRzQXJlQ29sbGluZWFyO1xuZXhwb3J0cy5saW5lVG9SYXkgPSBsaW5lVG9SYXk7XG5leHBvcnRzLnJheVRvTGluZSA9IHJheVRvTGluZTtcbmV4cG9ydHMuYWFiYiA9IGFhYmI7XG5leHBvcnRzLmFhYmJUb1JlY3RhbmdsZSA9IGFhYmJUb1JlY3RhbmdsZTtcbmV4cG9ydHMuYWFiYnNPdmVybGFwID0gYWFiYnNPdmVybGFwO1xuZXhwb3J0cy5wb2ludEluQUFCQiA9IHBvaW50SW5BQUJCO1xuZXhwb3J0cy5lbmNsb3NlQUFCQnMgPSBlbmNsb3NlQUFCQnM7XG5leHBvcnRzLnJlY3RhbmdsZUlzUm90YXRlZCA9IHJlY3RhbmdsZUlzUm90YXRlZDtcbmV4cG9ydHMucmVjdGFuZ2xlVmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcztcbmV4cG9ydHMudmVydGljZXNUb0VkZ2VzID0gdmVydGljZXNUb0VkZ2VzO1xuZXhwb3J0cy5wb2x5Z29uSXNDb252ZXggPSBwb2x5Z29uSXNDb252ZXg7XG5leHBvcnRzLnBvbHlnb25TZWxmSW50ZXJzZWN0cyA9IHBvbHlnb25TZWxmSW50ZXJzZWN0cztcbmV4cG9ydHMucG9seWdvbklzVmFsaWQgPSBwb2x5Z29uSXNWYWxpZDtcbmV4cG9ydHMucG9seWdvbldpbmRpbmdPcmRlciA9IHBvbHlnb25XaW5kaW5nT3JkZXI7XG5leHBvcnRzLnBvbHlnb25BcmVhID0gcG9seWdvbkFyZWE7XG5leHBvcnRzLnBvbHlnb25DZW50cm9pZCA9IHBvbHlnb25DZW50cm9pZDtcbmV4cG9ydHMucG9seWdvbkNvbnZleEh1bGwgPSBwb2x5Z29uQ29udmV4SHVsbDtcbmV4cG9ydHMub3B0aW1pc2VQb2x5Z29uID0gb3B0aW1pc2VQb2x5Z29uO1xuZXhwb3J0cy5kZWNvbXBvc2VQb2x5Z29uID0gZGVjb21wb3NlUG9seWdvbjtcbmV4cG9ydHMucG9pbnRPblJheSA9IHBvaW50T25SYXk7XG5leHBvcnRzLnBvaW50T25MaW5lID0gcG9pbnRPbkxpbmU7XG5leHBvcnRzLnBvaW50SW5DaXJjbGUgPSBwb2ludEluQ2lyY2xlO1xuZXhwb3J0cy5wb2ludEluUmVjdGFuZ2xlID0gcG9pbnRJblJlY3RhbmdsZTtcbmV4cG9ydHMucG9pbnRJblBvbHlnb24gPSBwb2ludEluUG9seWdvbjtcbmV4cG9ydHMucmF5VHJhdmVyc2VHcmlkID0gcmF5VHJhdmVyc2VHcmlkO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUmF5ID0gcmF5SW50ZXJzZWN0c1JheTtcbmV4cG9ydHMucmF5SW50ZXJzZWN0c0xpbmUgPSByYXlJbnRlcnNlY3RzTGluZTtcbmV4cG9ydHMucmF5SW50ZXJzZWN0c0NpcmNsZSA9IHJheUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLnJheUludGVyc2VjdHNSZWN0YW5nbGUgPSByYXlJbnRlcnNlY3RzUmVjdGFuZ2xlO1xuZXhwb3J0cy5yYXlJbnRlcnNlY3RzUG9seWdvbiA9IHJheUludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c1JheSA9IGxpbmVJbnRlcnNlY3RzUmF5O1xuZXhwb3J0cy5saW5lSW50ZXJzZWN0c0xpbmUgPSBsaW5lSW50ZXJzZWN0c0xpbmU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzQ2lyY2xlID0gbGluZUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlID0gbGluZUludGVyc2VjdHNSZWN0YW5nbGU7XG5leHBvcnRzLmxpbmVJbnRlcnNlY3RzUG9seWdvbiA9IGxpbmVJbnRlcnNlY3RzUG9seWdvbjtcbmV4cG9ydHMuY2lyY2xlSW50ZXJzZWN0c0NpcmNsZSA9IGNpcmNsZUludGVyc2VjdHNDaXJjbGU7XG5leHBvcnRzLmNpcmNsZUludGVyc2VjdHNSZWN0YW5nbGUgPSBjaXJjbGVJbnRlcnNlY3RzUmVjdGFuZ2xlO1xuZXhwb3J0cy5jaXJjbGVJbnRlcnNlY3RzUG9seWdvbiA9IGNpcmNsZUludGVyc2VjdHNQb2x5Z29uO1xuZXhwb3J0cy5yZWN0YW5nbGVJbnRlcnNlY3RzUmVjdGFuZ2xlID0gcmVjdGFuZ2xlSW50ZXJzZWN0c1JlY3RhbmdsZTtcbmV4cG9ydHMucmVjdGFuZ2xlSW50ZXJzZWN0c1BvbHlnb24gPSByZWN0YW5nbGVJbnRlcnNlY3RzUG9seWdvbjtcbmV4cG9ydHMucG9seWdvbkludGVyc2VjdHNQb2x5Z29uID0gcG9seWdvbkludGVyc2VjdHNQb2x5Z29uO1xuY29uc3QgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3V0aWxzICovIFwiLi9ub2RlX21vZHVsZXMvQGJhc2VtZW50dW5pdmVyc2UvdXRpbHMvdXRpbHMuanNcIik7XG5jb25zdCB2ZWNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYXNlbWVudHVuaXZlcnNlL3ZlYyAqLyBcIi4vbm9kZV9tb2R1bGVzL0BiYXNlbWVudHVuaXZlcnNlL3ZlYy92ZWMuanNcIik7XG5jb25zdCBkZWNvbXAgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcG9seS1kZWNvbXAgKi8gXCIuL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvaW5kZXguanNcIikpO1xuY29uc3QgdXRpbGl0aWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsaXRpZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMvaW5kZXgudHNcIik7XG5jb25zdCBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbGl0aWVzL2NvbnN0YW50cyAqLyBcIi4vc3JjL3V0aWxpdGllcy9jb25zdGFudHMudHNcIikpO1xuY29uc3QgdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMgKi8gXCIuL3NyYy8yZC90eXBlcy50c1wiKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvMmQvdHlwZXMudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBDb250ZW50c1xuICpcbiAqIFV0aWxpdGllc1xuICogQHNlZSBkaXN0YW5jZVxuICogQHNlZSBhbmdsZVxuICogQHNlZSBhbmdsZUJldHdlZW5cbiAqIEBzZWUgcG9pbnRzQXJlQ29sbGluZWFyXG4gKlxuICogTGluZSBhbmQgcmF5IHV0aWxpdGllc1xuICogQHNlZSBsaW5lVG9SYXlcbiAqIEBzZWUgcmF5VG9MaW5lXG4gKlxuICogQUFCQnNcbiAqIEBzZWUgYWFiYlxuICogQHNlZSBhYWJiVG9SZWN0YW5nbGVcbiAqIEBzZWUgYWFiYnNPdmVybGFwXG4gKiBAc2VlIHBvaW50SW5BQUJCXG4gKiBAc2VlIGVuY2xvc2VBQUJCc1xuICpcbiAqIFJlY3RhbmdsZSB1dGlsaXRpZXNcbiAqIEBzZWUgcmVjdGFuZ2xlSXNSb3RhdGVkXG4gKiBAc2VlIHJlY3RhbmdsZVZlcnRpY2VzXG4gKlxuICogUG9seWdvbiB1dGlsaXRpZXNcbiAqIEBzZWUgdmVydGljZXNUb0VkZ2VzXG4gKiBAc2VlIGZpbmRPdXRlckVkZ2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIHBvbHlnb25Jc0NvbnZleFxuICogQHNlZSBwb2x5Z29uU2VsZkludGVyc2VjdHNcbiAqIEBzZWUgcG9seWdvbklzVmFsaWRcbiAqIEBzZWUgcG9seWdvbldpbmRpbmdPcmRlclxuICogQHNlZSBwb2x5Z29uQXJlYVxuICogQHNlZSBwb2x5Z29uQ2VudHJvaWRcbiAqIEBzZWUgcG9seWdvbkNvbnZleEh1bGxcbiAqIEBzZWUgcmVtb3ZlRHVwbGljYXRlVmVydGljZXMgKG5vdCBleHBvcnRlZClcbiAqIEBzZWUgcmVtb3ZlRHVwbGljYXRlQWRqYWNlbnRWZXJ0aWNlcyAobm90IGV4cG9ydGVkKVxuICogQHNlZSByZW1vdmVDb2xsaW5lYXJWZXJ0aWNlcyAobm90IGV4cG9ydGVkKVxuICogQHNlZSBvcHRpbWlzZVBvbHlnb25cbiAqIEBzZWUgZGVjb21wb3NlUG9seWdvblxuICpcbiAqIFBvaW50c1xuICogQHNlZSBwb2ludE9uUmF5XG4gKiBAc2VlIHBvaW50T25MaW5lXG4gKiBAc2VlIHBvaW50SW5DaXJjbGVcbiAqIEBzZWUgcG9pbnRJblJlY3RhbmdsZVxuICogQHNlZSBwb2ludEluUG9seWdvblxuICpcbiAqIFJheXNcbiAqIEBzZWUgcmF5VHJhdmVyc2VHcmlkXG4gKiBAc2VlIHJheUludGVyc2VjdHNSYXlcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c0xpbmVcbiAqIEBzZWUgcmF5SW50ZXJzZWN0c0NpcmNsZVxuICogQHNlZSByYXlJbnRlcnNlY3RzUmVjdGFuZ2xlXG4gKiBAc2VlIHJheUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyAobm90IGV4cG9ydGVkKVxuICogQHNlZSByYXlJbnRlcnNlY3RzUG9seWdvblxuICpcbiAqIExpbmVzXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzUmF5XG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzTGluZVxuICogQHNlZSBsaW5lSW50ZXJzZWN0c0NpcmNsZVxuICogQHNlZSBsaW5lSW50ZXJzZWN0c1JlY3RhbmdsZVxuICogQHNlZSBsaW5lSW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIGxpbmVJbnRlcnNlY3RzUG9seWdvblxuICpcbiAqIENpcmNsZXNcbiAqIEBzZWUgY2lyY2xlSW50ZXJzZWN0c0NpcmNsZVxuICogQHNlZSBjaXJjbGVJbnRlcnNlY3RzUmVjdGFuZ2xlXG4gKiBAc2VlIGNpcmNsZUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyAobm90IGV4cG9ydGVkKVxuICogQHNlZSBjaXJjbGVJbnRlcnNlY3RzUG9seWdvblxuICpcbiAqIFJlY3RhbmdsZXNcbiAqIEBzZWUgcHJvamVjdFZlcnRpY2VzVG9BeGlzIChub3QgZXhwb3J0ZWQpXG4gKiBAc2VlIHJlY3RhbmdsZUludGVyc2VjdHNSZWN0YW5nbGVcbiAqIEBzZWUgcmVjdGFuZ2xlSW50ZXJzZWN0c1BvbHlnb25cbiAqXG4gKiBQb2x5Z29uc1xuICogQHNlZSBwb2x5Z29uSW50ZXJzZWN0c1BvbHlnb25cbiAqL1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgcmV0dXJuIHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGEsIGIpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBjbG9ja3dpc2UgYW5nbGUgZnJvbSBwb2ludCBhIHRvIHBvaW50IGJcbiAqXG4gKiBUaGUgcmVzdWx0IGlzIGluIHJhZGlhbnMgYW5kIHJhbmdlcyBmcm9tIDAgdG8gMs+AICgzNjAgZGVncmVlcylcbiAqXG4gKiBSZXR1cm5zIDAgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRoZXRhID0gdmVjXzEudmVjMi5yYWQodmVjXzEudmVjMi5zdWIoYiwgYSkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICBpZiAodGhldGEgPCAwKSB7XG4gICAgICAgIHJldHVybiB0aGV0YSArIDIgKiBNYXRoLlBJOyAvLyBFbnN1cmUgYW5nbGUgaXMgcG9zaXRpdmVcbiAgICB9XG4gICAgcmV0dXJuIHRoZXRhO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNsb2Nrd2lzZSBhbmdsZSBiZXR3ZWVuIHR3byBsaW5lcyBvciByYXlzXG4gKlxuICogUmV0dXJucyAwIGlmIGVpdGhlciBsaW5lIGlzIHplcm8tbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlbihhLCBiKSB7XG4gICAgbGV0IGFMaW5lID0gKDAsIHR5cGVzXzEuaXNSYXkpKGEpID8gcmF5VG9MaW5lKGEsIDEpIDogYTtcbiAgICBsZXQgYkxpbmUgPSAoMCwgdHlwZXNfMS5pc1JheSkoYikgPyByYXlUb0xpbmUoYiwgMSkgOiBiO1xuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykodmVjXzEudmVjMi5zdWIoYUxpbmUuZW5kLCBhTGluZS5zdGFydCkpIHx8XG4gICAgICAgICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKSh2ZWNfMS52ZWMyLnN1YihiTGluZS5lbmQsIGJMaW5lLnN0YXJ0KSkpIHtcbiAgICAgICAgcmV0dXJuIDA7IC8vIFplcm8tbGVuZ3RoIGxpbmVcbiAgICB9XG4gICAgY29uc3QgZGlyQSA9IHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKGFMaW5lLmVuZCwgYUxpbmUuc3RhcnQpKTtcbiAgICBjb25zdCBkaXJCID0gdmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIoYkxpbmUuZW5kLCBiTGluZS5zdGFydCkpO1xuICAgIC8vIENsYW1wIGRvdCBwcm9kdWN0IHRvIFstMSwgMV0gdG8gYXZvaWQgTmFOIGR1ZSB0byBmbG9hdGluZy1wb2ludCBlcnJvcnNcbiAgICBjb25zdCBkb3QgPSAoMCwgdXRpbHNfMS5jbGFtcCkodmVjXzEudmVjMi5kb3QoZGlyQSwgZGlyQiksIC0xLCAxKTtcbiAgICBjb25zdCBjcm9zcyA9IHZlY18xLnZlYzIuY3Jvc3MoZGlyQSwgZGlyQik7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGNyb3NzLCBkb3QpO1xuICAgIHJldHVybiBhbmdsZSA8IDAgPyBhbmdsZSArIDIgKiBNYXRoLlBJIDogYW5nbGU7IC8vIEVuc3VyZSBhbmdsZSBpcyBwb3NpdGl2ZVxufVxuLyoqXG4gKiBDaGVjayBpZiB0aHJlZSBwb2ludHMgaW4gMkQgc3BhY2UgYXJlIGNvbGxpbmVhclxuICovXG5mdW5jdGlvbiBwb2ludHNBcmVDb2xsaW5lYXIoYSwgYiwgYykge1xuICAgIC8vIENoZWNrIGlmIHRoZSBhcmVhIG9mIHRoZSB0cmlhbmdsZSBmb3JtZWQgYnkgdGhlIHBvaW50cyBpcyB6ZXJvXG4gICAgY29uc3QgYXJlYSA9IDAuNSAqIE1hdGguYWJzKGEueCAqIChiLnkgLSBjLnkpICsgYi54ICogKGMueSAtIGEueSkgKyBjLnggKiAoYS55IC0gYi55KSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKGFyZWEpIDwgY29uc3RhbnRzLkVQU0lMT047XG59XG4vKipcbiAqIENvbnZlcnQgYSBsaW5lIHNlZ21lbnQgdG8gYSByYXlcbiAqL1xuZnVuY3Rpb24gbGluZVRvUmF5KGxpbmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW46IGxpbmUuc3RhcnQsXG4gICAgICAgIGRpcmVjdGlvbjogdmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIobGluZS5lbmQsIGxpbmUuc3RhcnQpKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcmF5IHRvIGEgbGluZSBzZWdtZW50XG4gKi9cbmZ1bmN0aW9uIHJheVRvTGluZShyYXksIGxlbmd0aCA9IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogcmF5Lm9yaWdpbixcbiAgICAgICAgZW5kOiB2ZWNfMS52ZWMyLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMyLm11bChyYXkuZGlyZWN0aW9uLCBsZW5ndGgpKSxcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGJvdW5kaW5nIGJveCAoQUFCQikgb2YgYSBnZW9tZXRyaWMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFhYmIobykge1xuICAgIGlmICgoMCwgdHlwZXNfMS5pc0xpbmUpKG8pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYzIpKE1hdGgubWluKG8uc3RhcnQueCwgby5lbmQueCksIE1hdGgubWluKG8uc3RhcnQueSwgby5lbmQueSkpLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKE1hdGguYWJzKG8uZW5kLnggLSBvLnN0YXJ0LngpLCBNYXRoLmFicyhvLmVuZC55IC0gby5zdGFydC55KSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc1JlY3RhbmdsZSkobykpIHtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcyhvKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSAoMCwgdmVjXzEudmVjMikoTWF0aC5taW4oLi4udmVydGljZXMubWFwKHYgPT4gdi54KSksIE1hdGgubWluKC4uLnZlcnRpY2VzLm1hcCh2ID0+IHYueSkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKE1hdGgubWF4KC4uLnZlcnRpY2VzLm1hcCh2ID0+IHYueCkpIC0gcG9zaXRpb24ueCwgTWF0aC5tYXgoLi4udmVydGljZXMubWFwKHYgPT4gdi55KSkgLSBwb3NpdGlvbi55KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzQ2lyY2xlKShvKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IHZlY18xLnZlYzIuc3ViKG8ucG9zaXRpb24sICgwLCB2ZWNfMS52ZWMyKShvLnJhZGl1cywgby5yYWRpdXMpKSxcbiAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMyKShvLnJhZGl1cyAqIDIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNQb2x5Z29uKShvKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCB2ZWNfMS52ZWMyKShNYXRoLm1pbiguLi5vLnZlcnRpY2VzLm1hcCh2ID0+IHYueCkpLCBNYXRoLm1pbiguLi5vLnZlcnRpY2VzLm1hcCh2ID0+IHYueSkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKE1hdGgubWF4KC4uLm8udmVydGljZXMubWFwKHYgPT4gdi54KSkgLSBwb3NpdGlvbi54LCBNYXRoLm1heCguLi5vLnZlcnRpY2VzLm1hcCh2ID0+IHYueSkpIC0gcG9zaXRpb24ueSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIEFBQkIgdG8gYSByZWN0YW5nbGVcbiAqL1xuZnVuY3Rpb24gYWFiYlRvUmVjdGFuZ2xlKGFhYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogdmVjXzEudmVjMi5hZGQoYWFiYi5wb3NpdGlvbiwgdmVjXzEudmVjMi5kaXYoYWFiYi5zaXplLCAyKSksXG4gICAgICAgIHNpemU6IGFhYmIuc2l6ZSxcbiAgICAgICAgcm90YXRpb246IDAsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIEFBQkJzIG92ZXJsYXAgYW5kIHJldHVybiB0aGUgb3ZlcmxhcHBpbmcgYXJlYSBpZiBzb1xuICovXG5mdW5jdGlvbiBhYWJic092ZXJsYXAoYSwgYikge1xuICAgIGNvbnN0IG92ZXJsYXBYID0gKDAsIHV0aWxpdGllc18xLm92ZXJsYXBJbnRlcnZhbCkoeyBtaW46IGEucG9zaXRpb24ueCwgbWF4OiBhLnBvc2l0aW9uLnggKyBhLnNpemUueCB9LCB7IG1pbjogYi5wb3NpdGlvbi54LCBtYXg6IGIucG9zaXRpb24ueCArIGIuc2l6ZS54IH0pO1xuICAgIGNvbnN0IG92ZXJsYXBZID0gKDAsIHV0aWxpdGllc18xLm92ZXJsYXBJbnRlcnZhbCkoeyBtaW46IGEucG9zaXRpb24ueSwgbWF4OiBhLnBvc2l0aW9uLnkgKyBhLnNpemUueSB9LCB7IG1pbjogYi5wb3NpdGlvbi55LCBtYXg6IGIucG9zaXRpb24ueSArIGIuc2l6ZS55IH0pO1xuICAgIC8vIElmIHRoZSBBQUJCcyBkb24ndCBvdmVybGFwIG9uIG9uZSBvciBtb3JlIGF4ZXMsIHRoZXkgZG9uJ3Qgb3ZlcmxhcCBhdCBhbGxcbiAgICBpZiAoIW92ZXJsYXBYIHx8ICFvdmVybGFwWSkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBvdmVybGFwOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogKDAsIHZlY18xLnZlYzIpKG92ZXJsYXBYLm1pbiwgb3ZlcmxhcFkubWluKSxcbiAgICAgICAgICAgIHNpemU6ICgwLCB2ZWNfMS52ZWMyKShvdmVybGFwWC5tYXggLSBvdmVybGFwWC5taW4sIG92ZXJsYXBZLm1heCAtIG92ZXJsYXBZLm1pbiksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpcyBpbnNpZGUgYW4gQUFCQlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHBvaW50SW5SZWN0YW5nbGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlclxuICogcm90YXRpb25cbiAqL1xuZnVuY3Rpb24gcG9pbnRJbkFBQkIocG9pbnQsIGFhYmIpIHtcbiAgICBjb25zdCB7IHBvc2l0aW9uLCBzaXplIH0gPSBhYWJiO1xuICAgIGNvbnN0IG1pbiA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IG1heCA9IHZlY18xLnZlYzIuYWRkKHBvc2l0aW9uLCBzaXplKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBBQUJCXG4gICAgY29uc3QgaW50ZXJzZWN0cyA9ICgwLCB1dGlsaXRpZXNfMS52YWx1ZUluSW50ZXJ2YWwpKHBvaW50LngsIHsgbWluOiBtaW4ueCwgbWF4OiBtYXgueCB9KSAmJlxuICAgICAgICAoMCwgdXRpbGl0aWVzXzEudmFsdWVJbkludGVydmFsKShwb2ludC55LCB7IG1pbjogbWluLnksIG1heDogbWF4LnkgfSk7XG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgQUFCQiBwZXJpbWV0ZXIgdG8gdGhlIGdpdmVuIHBvaW50XG4gICAgbGV0IGNsb3Nlc3RQb2ludDtcbiAgICBsZXQgbm9ybWFsID0gdW5kZWZpbmVkO1xuICAgIGlmICghaW50ZXJzZWN0cykge1xuICAgICAgICAvLyBJZiB0aGUgcG9pbnQgaXMgb3V0c2lkZSwgY2xhbXAgdG8gdGhlIGJveFxuICAgICAgICBjbG9zZXN0UG9pbnQgPSAoMCwgdmVjXzEudmVjMikoKDAsIHV0aWxzXzEuY2xhbXApKHBvaW50LngsIG1pbi54LCBtYXgueCksICgwLCB1dGlsc18xLmNsYW1wKShwb2ludC55LCBtaW4ueSwgbWF4LnkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBwb2ludCBpcyBpbnNpZGUsIHByb2plY3QgdG8gdGhlIG5lYXJlc3QgZWRnZVxuICAgICAgICBjb25zdCBkaXN0YW5jZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDogbWluLngsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgICAgICAgICBkOiBNYXRoLmFicyhwb2ludC54IC0gbWluLngpLFxuICAgICAgICAgICAgICAgIG5vcm1hbDogKDAsIHZlY18xLnZlYzIpKC0xLCAwKSxcbiAgICAgICAgICAgIH0sIC8vIGxlZnRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiBtYXgueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgICAgIGQ6IE1hdGguYWJzKHBvaW50LnggLSBtYXgueCksXG4gICAgICAgICAgICAgICAgbm9ybWFsOiAoMCwgdmVjXzEudmVjMikoMSwgMCksXG4gICAgICAgICAgICB9LCAvLyByaWdodFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICAgICAgeTogbWluLnksXG4gICAgICAgICAgICAgICAgZDogTWF0aC5hYnMocG9pbnQueSAtIG1pbi55KSxcbiAgICAgICAgICAgICAgICBub3JtYWw6ICgwLCB2ZWNfMS52ZWMyKSgwLCAtMSksXG4gICAgICAgICAgICB9LCAvLyB0b3BcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IG1heC55LFxuICAgICAgICAgICAgICAgIGQ6IE1hdGguYWJzKHBvaW50LnkgLSBtYXgueSksXG4gICAgICAgICAgICAgICAgbm9ybWFsOiAoMCwgdmVjXzEudmVjMikoMCwgMSksXG4gICAgICAgICAgICB9LCAvLyBib3R0b21cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbmVhcmVzdCA9IGRpc3RhbmNlcy5yZWR1Y2UoKGEsIGIpID0+IChhLmQgPCBiLmQgPyBhIDogYikpO1xuICAgICAgICBjbG9zZXN0UG9pbnQgPSAoMCwgdmVjXzEudmVjMikobmVhcmVzdC54LCBuZWFyZXN0LnkpO1xuICAgICAgICBub3JtYWwgPSBuZWFyZXN0Lm5vcm1hbDtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY2xvc2VzdCBwb2ludFxuICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIocG9pbnQsIGNsb3Nlc3RQb2ludCkpO1xuICAgIC8vIElmIHRoZSBwb2ludCBpcyBpbnNpZGUsIGRpc3RhbmNlIHNob3VsZCBiZSBuZWdhdGl2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHMsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2U6IGludGVyc2VjdHMgPyAtZGlzdGFuY2UgOiBkaXN0YW5jZSxcbiAgICAgICAgbm9ybWFsLFxuICAgIH07XG59XG4vKipcbiAqIEVuY2xvc2UgYSBzZXQgb2YgQUFCQnMgaW4gYSBzaW5nbGUgQUFCQlxuICovXG5mdW5jdGlvbiBlbmNsb3NlQUFCQnMoLi4uYWFiYnMpIHtcbiAgICBpZiAoYWFiYnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHBvc2l0aW9uOiAoMCwgdmVjXzEudmVjMikoKSwgc2l6ZTogKDAsIHZlY18xLnZlYzIpKCkgfTtcbiAgICB9XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWluKC4uLmFhYmJzLm1hcCgoeyBwb3NpdGlvbiB9KSA9PiBwb3NpdGlvbi54KSk7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLmFhYmJzLm1hcCgoeyBwb3NpdGlvbiB9KSA9PiBwb3NpdGlvbi55KSk7XG4gICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KC4uLmFhYmJzLm1hcCgoeyBwb3NpdGlvbiwgc2l6ZSB9KSA9PiBwb3NpdGlvbi54ICsgc2l6ZS54KSk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLmFhYmJzLm1hcCgoeyBwb3NpdGlvbiwgc2l6ZSB9KSA9PiBwb3NpdGlvbi55ICsgc2l6ZS55KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246ICgwLCB2ZWNfMS52ZWMyKShtaW5YLCBtaW5ZKSxcbiAgICAgICAgc2l6ZTogKDAsIHZlY18xLnZlYzIpKG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByZWN0YW5nbGUgaXMgcm90YXRlZFxuICovXG5mdW5jdGlvbiByZWN0YW5nbGVJc1JvdGF0ZWQocmVjdGFuZ2xlKSB7XG4gICAgcmV0dXJuIChyZWN0YW5nbGUucm90YXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBNYXRoLmFicyhyZWN0YW5nbGUucm90YXRpb24pID4gY29uc3RhbnRzLkVQU0lMT04pO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZlcnRpY2VzIG9mIGEgcmVjdGFuZ2xlXG4gKlxuICogVmVydGljZXMgd2lsbCBiZSByZXR1cm5lZCBpbiBjbG9ja3dpc2Ugb3JkZXIgc3RhcnRpbmcgYXQgdGhlIHRvcC1sZWZ0OlxuICogLSBUb3AtbGVmdFxuICogLSBUb3AtcmlnaHRcbiAqIC0gQm90dG9tLXJpZ2h0XG4gKiAtIEJvdHRvbS1sZWZ0XG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZVZlcnRpY2VzKHJlY3RhbmdsZSkge1xuICAgIGNvbnN0IHsgcG9zaXRpb24sIHNpemUsIHJvdGF0aW9uID0gMCB9ID0gcmVjdGFuZ2xlO1xuICAgIGNvbnN0IGhhbGZTaXplID0gdmVjXzEudmVjMi5kaXYoc2l6ZSwgMik7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmb3VyIGNvcm5lcnMgb2YgdGhlIHJlY3RhbmdsZVxuICAgIGxldCB0b3BMZWZ0T2Zmc2V0ID0gdmVjXzEudmVjMi5mcm9tQ29tcG9uZW50cyh2ZWNfMS52ZWMyLnN3aXooaGFsZlNpemUsICdYWScpKTtcbiAgICBsZXQgdG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMyLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzIuc3dpeihoYWxmU2l6ZSwgJ3hZJykpO1xuICAgIGxldCBib3R0b21SaWdodE9mZnNldCA9IHZlY18xLnZlYzIuZnJvbUNvbXBvbmVudHModmVjXzEudmVjMi5zd2l6KGhhbGZTaXplLCAneHknKSk7XG4gICAgbGV0IGJvdHRvbUxlZnRPZmZzZXQgPSB2ZWNfMS52ZWMyLmZyb21Db21wb25lbnRzKHZlY18xLnZlYzIuc3dpeihoYWxmU2l6ZSwgJ1h5JykpO1xuICAgIC8vIFJvdGF0ZSB0aGUgb2Zmc2V0cyBpZiB0aGUgcmVjdGFuZ2xlIGlzIHJvdGF0ZWRcbiAgICBpZiAocmVjdGFuZ2xlSXNSb3RhdGVkKHJlY3RhbmdsZSkpIHtcbiAgICAgICAgdG9wTGVmdE9mZnNldCA9IHZlY18xLnZlYzIucm90KHRvcExlZnRPZmZzZXQsIHJvdGF0aW9uKTtcbiAgICAgICAgdG9wUmlnaHRPZmZzZXQgPSB2ZWNfMS52ZWMyLnJvdCh0b3BSaWdodE9mZnNldCwgcm90YXRpb24pO1xuICAgICAgICBib3R0b21SaWdodE9mZnNldCA9IHZlY18xLnZlYzIucm90KGJvdHRvbVJpZ2h0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgICAgIGJvdHRvbUxlZnRPZmZzZXQgPSB2ZWNfMS52ZWMyLnJvdChib3R0b21MZWZ0T2Zmc2V0LCByb3RhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHZlY18xLnZlYzIuYWRkKHBvc2l0aW9uLCB0b3BMZWZ0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIHRvcFJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIGJvdHRvbVJpZ2h0T2Zmc2V0KSxcbiAgICAgICAgdmVjXzEudmVjMi5hZGQocG9zaXRpb24sIGJvdHRvbUxlZnRPZmZzZXQpLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIHZlcnRpY2VzIHRvIGEgbGlzdCBvZiBlZGdlc1xuICovXG5mdW5jdGlvbiB2ZXJ0aWNlc1RvRWRnZXModmVydGljZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gKDAsIHV0aWxzXzEuYXQpKHZlcnRpY2VzLCBpICsgMSk7XG4gICAgICAgIGVkZ2VzLnB1c2goeyBzdGFydCwgZW5kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXM7XG59XG4vKipcbiAqIEZpbmQgb3V0ZXIgZWRnZXMgaW4gYSBsaXN0IG9mIHBvbHlnb25zXG4gKlxuICogV2UgYXNzdW1lIHRoYXQgdGhlIHBvbHlnb25zIHdlcmUgdGhlIHJlc3VsdCBvZiBkZWNvbXBvc2luZyBhIGNvbmNhdmUgcG9seWdvblxuICogaW50byBhIHNldCBvZiBjb252ZXggcG9seWdvbnMsIGFuZCBhcyBzdWNoIHRoZXkgYXJlIGFsbCBjb252ZXggYW5kIHNoYXJlXG4gKiBvbmUgb3IgbW9yZSBlZGdlc1xuICpcbiAqIFRoaXMgbWVhbnMgd2UgY2FuIGlkZW50aWZ5IG91dGVyIGVkZ2VzIGJlY2F1c2UgdGhleSdsbCBvbmx5IGFwcGVhciBvbmNlXG4gKiBpbiB0aGUgbGlzdCBvZiBlZGdlcywgd2hpbGUgaW5uZXIgZWRnZXMgd2lsbCBhcHBlYXIgdHdpY2UgKG9uY2UgZm9yIGVhY2hcbiAqIHBvbHlnb24gdGhhdCBzaGFyZXMgdGhlbSlcbiAqL1xuZnVuY3Rpb24gZmluZE91dGVyRWRnZXMocG9seWdvbnMpIHtcbiAgICBjb25zdCBhbGxFZGdlcyA9IHBvbHlnb25zLmZsYXRNYXAocG9seWdvbiA9PiB2ZXJ0aWNlc1RvRWRnZXMocG9seWdvbi52ZXJ0aWNlcykpO1xuICAgIC8vIEVkZ2VzIGFyZSB0aGUgZHVwbGljYXRlcyBpZiB0aGV5IG92ZXJsYXAgYnV0IGhhdmUgbm8gaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgLy8gKHRoaXMgaW1wbGllcyB0aGF0IHRoZXkgaGF2ZSBpbmZpbml0ZWx5IG1hbnkgaW50ZXJzZWN0aW9uIHBvaW50cylcbiAgICBjb25zdCBlZGdlc092ZXJsYXAgPSAoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBsaW5lSW50ZXJzZWN0c0xpbmUoYSwgYik7XG4gICAgICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiAhcmVzdWx0LmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAvLyBFZGdlIGNhc2U6IGlmIHRoZSBlZGdlcyBpbnRlcnNlY3QgYW5kIGhhdmUgbm8gaW50ZXJzZWN0IHBvaW50LCBidXRcbiAgICAgICAgICAgIC8vIHNoYXJlIG9ubHkgb25lIGVuZHBvaW50LCB0aGVuIHRoZXkgYXJlbid0IGNvbnNpZGVyZWQgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgIGlmICgoKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoYS5lbmQsIGIuc3RhcnQpICYmXG4gICAgICAgICAgICAgICAgISgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGEuc3RhcnQsIGIuZW5kKSkgfHxcbiAgICAgICAgICAgICAgICAoKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkoYS5zdGFydCwgYi5lbmQpICYmXG4gICAgICAgICAgICAgICAgICAgICEoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShhLmVuZCwgYi5zdGFydCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gRmlsdGVyIG91dCB0aGUgZWRnZXMgdGhhdCBhcHBlYXIgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgYWxsRWRnZXMpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuc29tZShlID0+IGVkZ2VzT3ZlcmxhcChlLCBlZGdlKSkgJiZcbiAgICAgICAgICAgICFhbGxFZGdlcy5zb21lKGUgPT4gZSAhPT0gZWRnZSAmJiBlZGdlc092ZXJsYXAoZSwgZWRnZSkpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChlZGdlKTsgLy8gVGhpcyBlZGdlIGlzIGFuIG91dGVyIGVkZ2VcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvbHlnb24gaXMgY29udmV4XG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbklzQ29udmV4KHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc2lnbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgY29uc3QgYyA9ICgwLCB1dGlsc18xLmF0KShwb2x5Z29uLnZlcnRpY2VzLCBpICsgMik7XG4gICAgICAgIGNvbnN0IGNyb3NzUHJvZHVjdCA9IChiLnggLSBhLngpICogKGMueSAtIGEueSkgLSAoYi55IC0gYS55KSAqIChjLnggLSBhLngpO1xuICAgICAgICBpZiAoY3Jvc3NQcm9kdWN0ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNpZ24gPSBNYXRoLnNpZ24oY3Jvc3NQcm9kdWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguc2lnbihjcm9zc1Byb2R1Y3QpICE9PSBzaWduKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGb3VuZCBhIGNoYW5nZSBpbiBzaWduLCBwb2x5Z29uIGlzIG5vdCBjb252ZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTsgLy8gQWxsIGNyb3NzIHByb2R1Y3RzIGhhdmUgdGhlIHNhbWUgc2lnbiwgcG9seWdvbiBpcyBjb252ZXhcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2x5Z29uIHNlbGYtaW50ZXJzZWN0c1xuICovXG5mdW5jdGlvbiBwb2x5Z29uU2VsZkludGVyc2VjdHMocG9seWdvbikge1xuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBIHBvbHlnb24gbXVzdCBoYXZlIGF0IGxlYXN0IDMgdmVydGljZXNcbiAgICB9XG4gICAgY29uc3QgbiA9IHBvbHlnb24udmVydGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAyOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gcG9seWdvbi52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoMCwgdXRpbHNfMS5hdCkocG9seWdvbi52ZXJ0aWNlcywgaiArIDEpO1xuICAgICAgICAgICAgLy8gU2tpcCBhZGphY2VudCBlZGdlc1xuICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgaiA9PT0gbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50cyAoYSwgYikgYW5kIChjLCBkKSBpbnRlcnNlY3RcbiAgICAgICAgICAgIGNvbnN0IHsgaW50ZXJzZWN0cyB9ID0gbGluZUludGVyc2VjdHNMaW5lKHsgc3RhcnQ6IGEsIGVuZDogYiB9LCB7IHN0YXJ0OiBjLCBlbmQ6IGQgfSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBGb3VuZCBhbiBpbnRlcnNlY3Rpb24sIHBvbHlnb24gc2VsZi1pbnRlcnNlY3RzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBObyBpbnRlcnNlY3Rpb25zIGZvdW5kLCBwb2x5Z29uIGRvZXMgbm90IHNlbGYtaW50ZXJzZWN0XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9seWdvbiBpcyB2YWxpZFxuICpcbiAqIEEgcG9seWdvbiBpcyB2YWxpZCBpZiBpdCBoYXMgYXQgbGVhc3QgMyB2ZXJ0aWNlcyBhbmQgZG9lcyBub3RcbiAqIHNlbGYtaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pIHtcbiAgICByZXR1cm4gcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGggPj0gMyAmJiAhcG9seWdvblNlbGZJbnRlcnNlY3RzKHBvbHlnb24pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIHdpbmRpbmcgb3JkZXIgb2YgYSBwb2x5Z29uJ3MgdmVydGljZXNcbiAqXG4gKiBSZXR1cm5zICdjbG9ja3dpc2UnIG9yICdjb3VudGVyLWNsb2Nrd2lzZScgZGVwZW5kaW5nIG9uIHRoZSBjaG9zZW5cbiAqIGNvb3JkaW5hdGUgc3lzdGVtXG4gKlxuICogQnkgZGVmYXVsdCB3ZSB1c2UgdGhlICdzY3JlZW4nIGNvb3JkaW5hdGUgc3lzdGVtICh5IGluY3JlYXNlcyBkb3dud2FyZHMpXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHRoZSBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbldpbmRpbmdPcmRlcihwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgc3VtICs9IChiLnggLSBhLngpICogKGIueSArIGEueSk7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGVTeXN0ZW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvb3JkaW5hdGVTeXN0ZW0pIHx8ICdzY3JlZW4nO1xuICAgIHN3aXRjaCAoY29vcmRpbmF0ZVN5c3RlbSkge1xuICAgICAgICBjYXNlICdjYXJ0ZXNpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHN1bSA+IDAgPyAnY2xvY2t3aXNlJyA6ICdjb3VudGVyLWNsb2Nrd2lzZSc7XG4gICAgICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICAgICAgICByZXR1cm4gc3VtID4gMCA/ICdjb3VudGVyLWNsb2Nrd2lzZScgOiAnY2xvY2t3aXNlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcmVhIG9mIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgYXJlYSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBwb2x5Z29uLnZlcnRpY2VzW2ldO1xuICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzXzEuYXQpKHBvbHlnb24udmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgYXJlYSArPSB2ZWNfMS52ZWMyLmNyb3NzKGEsIGIpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMoYXJlYSkgLyAyO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkIG9mIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkIG9yIGRlZ2VuZXJhdGUgKGkuZS4gYWxsIHZlcnRpY2VzIGFyZVxuICogY29sbGluZWFyKVxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ2VudHJvaWQocG9seWdvbikge1xuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmV2ZXJ5KCh2LCBpLCBhKSA9PiBwb2ludHNBcmVDb2xsaW5lYXIodiwgKDAsIHV0aWxzXzEuYXQpKGEsIGkgKyAxKSwgKDAsIHV0aWxzXzEuYXQpKGEsIGkgKyAyKSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBBbGwgdmVydGljZXMgYXJlIGNvbGxpbmVhclxuICAgIH1cbiAgICByZXR1cm4gdmVjXzEudmVjMi5kaXYoWy4uLnBvbHlnb24udmVydGljZXNdLnJlZHVjZSgoYSwgYykgPT4gdmVjXzEudmVjMi5hZGQoYSwgYyksICgwLCB2ZWNfMS52ZWMyKSgpKSwgcG9seWdvbi52ZXJ0aWNlcy5sZW5ndGgpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNvbnZleCBodWxsIG9mIGEgcG9seWdvblxuICovXG5mdW5jdGlvbiBwb2x5Z29uQ29udmV4SHVsbChwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2x5Z29uSXNDb252ZXgocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIHBvbHlnb247IC8vIFRoZSBwb2x5Z29uIGlzIGFscmVhZHkgY29udmV4XG4gICAgfVxuICAgIGNvbnN0IGtlZXBXaW5kaW5nT3JkZXIgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2VlcFdpbmRpbmdPcmRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICBjb25zdCBvcmlnaW5hbFdpbmRpbmdPcmRlciA9IHBvbHlnb25XaW5kaW5nT3JkZXIocG9seWdvbik7XG4gICAgLy8gQW5kcmV3J3MgbW9ub3RvbmUgY2hhaW4gYWxnb3JpdGhtIGZvciBjb252ZXggaHVsbFxuICAgIC8vIFNvcnQgdmVydGljZXMgbGV4aWNvZ3JhcGhpY2FsbHkgKGZpcnN0IGJ5IHgsIHRoZW4gYnkgeSlcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4ucG9seWdvbi52ZXJ0aWNlc10uc29ydCgoYSwgYikgPT4gYS54ICE9PSBiLnggPyBhLnggLSBiLnggOiBhLnkgLSBiLnkpO1xuICAgIGNvbnN0IGxvd2VyID0gW107XG4gICAgZm9yIChjb25zdCBwIG9mIHNvcnRlZCkge1xuICAgICAgICB3aGlsZSAobG93ZXIubGVuZ3RoID49IDIgJiZcbiAgICAgICAgICAgIHZlY18xLnZlYzIuY3Jvc3ModmVjXzEudmVjMi5zdWIobG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIGxvd2VyW2xvd2VyLmxlbmd0aCAtIDJdKSwgdmVjXzEudmVjMi5zdWIocCwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0pKSA8PSAwKSB7XG4gICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBsb3dlci5wdXNoKHApO1xuICAgIH1cbiAgICBjb25zdCB1cHBlciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzb3J0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgcCA9IHNvcnRlZFtpXTtcbiAgICAgICAgd2hpbGUgKHVwcGVyLmxlbmd0aCA+PSAyICYmXG4gICAgICAgICAgICB2ZWNfMS52ZWMyLmNyb3NzKHZlY18xLnZlYzIuc3ViKHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCB1cHBlclt1cHBlci5sZW5ndGggLSAyXSksIHZlY18xLnZlYzIuc3ViKHAsIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdKSkgPD0gMCkge1xuICAgICAgICAgICAgdXBwZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBwZXIucHVzaChwKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHBvaW50IG9mIGVhY2ggaGFsZiBiZWNhdXNlIGl0J3MgcmVwZWF0ZWQgYXQgdGhlIHN0YXJ0IG9mXG4gICAgLy8gdGhlIG90aGVyXG4gICAgbG93ZXIucG9wKCk7XG4gICAgdXBwZXIucG9wKCk7XG4gICAgY29uc3QgaHVsbCA9IGxvd2VyLmNvbmNhdCh1cHBlcik7XG4gICAgaWYgKGh1bGwubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gT3B0aW9uYWxseSBlbnN1cmUgdGhlIHdpbmRpbmcgb3JkZXIgaXMgcHJlc2VydmVkXG4gICAgaWYgKGtlZXBXaW5kaW5nT3JkZXIgJiZcbiAgICAgICAgcG9seWdvbldpbmRpbmdPcmRlcih7IHZlcnRpY2VzOiBodWxsIH0pICE9PSBvcmlnaW5hbFdpbmRpbmdPcmRlcikge1xuICAgICAgICBodWxsLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGh1bGwpLFxuICAgIH07XG59XG4vKipcbiAqIFJlbW92ZSBkdXBsaWNhdGUgdmVydGljZXMgZnJvbSBhIGxpc3Qgb2YgdmVydGljZXNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlVmVydGljZXModmVydGljZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc29tZSh2ID0+ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JzQWxtb3N0RXF1YWwpKGN1cnJlbnQsIHYpKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVtb3ZlIGR1cGxpY2F0ZSBhZGphY2VudCB2ZXJ0aWNlcyBmcm9tIGEgbGlzdCBvZiB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVBZGphY2VudFZlcnRpY2VzKHZlcnRpY2VzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdmVydGljZXNbaV07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoMCwgdXRpbHNfMS5hdCkodmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgaWYgKCEoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShjdXJyZW50LCBuZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVtb3ZlIGNvbGxpbmVhciB2ZXJ0aWNlcyBmcm9tIGEgbGlzdCBvZiB2ZXJ0aWNlc1xuICovXG5mdW5jdGlvbiByZW1vdmVDb2xsaW5lYXJWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9ICgwLCB1dGlsc18xLmF0KSh2ZXJ0aWNlcywgaSAtIDEpO1xuICAgICAgICBjb25zdCBiID0gdmVydGljZXNbaV07XG4gICAgICAgIGNvbnN0IGMgPSAoMCwgdXRpbHNfMS5hdCkodmVydGljZXMsIGkgKyAxKTtcbiAgICAgICAgLy8gU2tpcCBjb2xsaW5lYXIgcG9pbnRzXG4gICAgICAgIGlmIChwb2ludHNBcmVDb2xsaW5lYXIoYSwgYiwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBPcHRpbWlzZSBhIHBvbHlnb24gYnkgcmVtb3ZpbmcgY29sbGluZWFyIHZlcnRpY2VzIGFuZCBkdXBsaWNhdGUgYWRqYWNlbnRcbiAqIHZlcnRpY2VzXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXNlUG9seWdvbihwb2x5Z29uKSB7XG4gICAgLy8gRHVwbGljYXRlIGFkamFjZW50IHZlcnRpY2VzIHdpbGwgY291bnQgdGhlIHBvbHlnb24gYXMgc2VsZi1pbnRlcnNlY3RpbmcsXG4gICAgLy8gc28gc2tpcCB0aGF0IGNoZWNrIGZvciBub3cgYW5kIG9ubHkgY2hlY2sgdGhlIG51bWJlciBvZiB2ZXJ0aWNlc1xuICAgIGlmIChwb2x5Z29uLnZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9wdGltaXNlZFZlcnRpY2VzID0gcmVtb3ZlQ29sbGluZWFyVmVydGljZXMocmVtb3ZlRHVwbGljYXRlQWRqYWNlbnRWZXJ0aWNlcyhwb2x5Z29uLnZlcnRpY2VzKSk7XG4gICAgLy8gSWYgd2UgaGF2ZSBsZXNzIHRoYW4gMyB2ZXJ0aWNlcyBhZnRlciBvcHRpbWlzYXRpb24sIHJldHVybiBudWxsXG4gICAgaWYgKG9wdGltaXNlZFZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHZlcnRpY2VzOiBvcHRpbWlzZWRWZXJ0aWNlcyB9O1xufVxuLyoqXG4gKiBEZWNvbXBvc2UgYSBwb2x5Z29uIGludG8gYSBzZXQgb2YgY29udmV4IHBvbHlnb25zIHVzaW5nIHRoZSBCYXlheml0XG4gKiBhbGdvcml0aG1cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZCBvciBjYW5ub3QgYmUgZGVjb21wb3NlZFxuICovXG5mdW5jdGlvbiBkZWNvbXBvc2VQb2x5Z29uKHBvbHlnb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvbHlnb25Jc0NvbnZleChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gW3BvbHlnb25dOyAvLyBUaGUgcG9seWdvbiBpcyBhbHJlYWR5IGNvbnZleFxuICAgIH1cbiAgICBjb25zdCBtb2RlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKSB8fCAnZmFzdCc7XG4gICAgY29uc3Qga2VlcFdpbmRpbmdPcmRlciA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5rZWVwV2luZGluZ09yZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgIGNvbnN0IG9yaWdpbmFsV2luZGluZ09yZGVyID0gcG9seWdvbldpbmRpbmdPcmRlcihwb2x5Z29uKTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHBvbHlnb24udmVydGljZXMubWFwKHYgPT4gW3YueCwgdi55XSk7XG4gICAgaWYgKG9yaWdpbmFsV2luZGluZ09yZGVyID09PSAnY291bnRlci1jbG9ja3dpc2UnKSB7XG4gICAgICAgIHZlcnRpY2VzLnJldmVyc2UoKTsgLy8gRW5zdXJlIGNsb2Nrd2lzZSB3aW5kaW5nXG4gICAgfVxuICAgIC8vIERlY29tcG9zZSB0aGUgcG9seWdvblxuICAgIGxldCBjb252ZXhQb2x5Z29ucyA9IFtdO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICAgIGNvbnZleFBvbHlnb25zID0gZGVjb21wLnF1aWNrRGVjb21wKHZlcnRpY2VzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcHRpbWFsJzpcbiAgICAgICAgICAgIGNvbnZleFBvbHlnb25zID0gZGVjb21wLmRlY29tcCh2ZXJ0aWNlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgcmVzdWx0IGludG8gYSBsaXN0IG9mIFBvbHlnb24gb2JqZWN0c1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgY29udmV4IG9mIGNvbnZleFBvbHlnb25zKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiBjb252ZXgubWFwKHYgPT4gKDAsIHZlY18xLnZlYzIpKHZbMF0sIHZbMV0pKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbmFsbHkgZW5zdXJlIHRoZSB3aW5kaW5nIG9yZGVyIGlzIHByZXNlcnZlZFxuICAgIGlmIChrZWVwV2luZGluZ09yZGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9seSBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uV2luZGluZ09yZGVyKHBvbHkpICE9PSBvcmlnaW5hbFdpbmRpbmdPcmRlcikge1xuICAgICAgICAgICAgICAgIHBvbHkudmVydGljZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSByYXlcbiAqL1xuZnVuY3Rpb24gcG9pbnRPblJheShwb2ludCwgcmF5KSB7XG4gICAgLy8gVmVjdG9yIGZyb20gcmF5IG9yaWdpbiB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMyLnN1Yihwb2ludCwgcmF5Lm9yaWdpbik7XG4gICAgLy8gR2V0IG5vcm1hbGl6ZWQgcmF5IGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpcmVjdGlvbiA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIFByb2plY3QgdG9Qb2ludCBvbnRvIHRoZSByYXkgZGlyZWN0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzIuZG90KHRvUG9pbnQsIHJheURpcmVjdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIGNsb3Nlc3QgcG9pbnQgb24gcmF5XG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gdmVjXzEudmVjMi5hZGQocmF5Lm9yaWdpbiwgdmVjXzEudmVjMi5tdWwocmF5RGlyZWN0aW9uLCBNYXRoLm1heCgwLCBwcm9qZWN0aW9uKSkpO1xuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIGNsb3Nlc3QgcG9pbnRcbiAgICBjb25zdCBkaXN0YW5jZSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKHBvaW50LCBjbG9zZXN0UG9pbnQpKTtcbiAgICAvLyBUaGUgcG9pbnQgaW50ZXJzZWN0cyB0aGUgcmF5IGlmIHRoZSBkaXN0YW5jZSBpcyBlZmZlY3RpdmVseSB6ZXJvIGFuZCB0aGVcbiAgICAvLyBwcm9qZWN0aW9uIGlzIG5vbi1uZWdhdGl2ZSAobWVhbmluZyB0aGUgcG9pbnQgaXMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAvLyByYXkgYW5kIG5vdCBiZWhpbmQgaXQpXG4gICAgY29uc3QgaW50ZXJzZWN0cyA9IGRpc3RhbmNlIDwgY29uc3RhbnRzLkVQU0lMT04gJiYgcHJvamVjdGlvbiA+PSAwO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIG5vcm1hbFxuICAgIGxldCBub3JtYWw7XG4gICAgaWYgKCFpbnRlcnNlY3RzKSB7XG4gICAgICAgIC8vIEdldCBhIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSByYXkgZGlyZWN0aW9uIGJ5IHJvdGF0aW5nIGl0IDkwIGRlZ3JlZXNcbiAgICAgICAgY29uc3QgcmF5Tm9ybWFsID0gdmVjXzEudmVjMi5yb3RmKHJheURpcmVjdGlvbiwgLTEpO1xuICAgICAgICAvLyBVc2UgdGhlIGNyb3NzIHByb2R1Y3QgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpZGUgb2YgdGhlIHJheSB0aGUgcG9pbnQgaXMgb25cbiAgICAgICAgY29uc3QgY3Jvc3NQcm9kdWN0ID0gdmVjXzEudmVjMi5jcm9zcyhyYXlEaXJlY3Rpb24sIHRvUG9pbnQpO1xuICAgICAgICAvLyBJZiBjcm9zcyBwcm9kdWN0IGlzIG5lZ2F0aXZlLCBwb2ludCBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgcmF5XG4gICAgICAgIC8vIElmIHBvc2l0aXZlLCBwb2ludCBpcyBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgIG5vcm1hbCA9IHZlY18xLnZlYzIubXVsKHJheU5vcm1hbCwgTWF0aC5zaWduKGNyb3NzUHJvZHVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBub3JtYWwsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgbGluZSBzZWdtZW50XG4gKi9cbmZ1bmN0aW9uIHBvaW50T25MaW5lKHBvaW50LCBsaW5lKSB7XG4gICAgLy8gR2V0IHZlY3RvciBmcm9tIGxpbmUgc3RhcnQgdG8gZW5kXG4gICAgY29uc3QgbGluZVZlY3RvciA9IHZlY18xLnZlYzIuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KTtcbiAgICAvLyBHZXQgbm9ybWFsaXplZCBsaW5lIGRpcmVjdGlvblxuICAgIGNvbnN0IGxpbmVEaXJlY3Rpb24gPSB2ZWNfMS52ZWMyLm5vcihsaW5lVmVjdG9yKTtcbiAgICAvLyBHZXQgdmVjdG9yIGZyb20gbGluZSBzdGFydCB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMyLnN1Yihwb2ludCwgbGluZS5zdGFydCk7XG4gICAgLy8gUHJvamVjdCB0b1BvaW50IG9udG8gdGhlIGxpbmUgZGlyZWN0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzIuZG90KHRvUG9pbnQsIGxpbmVEaXJlY3Rpb24pO1xuICAgIC8vIEdldCBsaW5lIGxlbmd0aFxuICAgIGNvbnN0IGxpbmVMZW5ndGggPSB2ZWNfMS52ZWMyLmxlbihsaW5lVmVjdG9yKTtcbiAgICAvLyBDbGFtcCBwcm9qZWN0aW9uIHRvIGxpbmUgc2VnbWVudFxuICAgIGNvbnN0IGNsYW1wZWRQcm9qZWN0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGluZUxlbmd0aCwgcHJvamVjdGlvbikpO1xuICAgIC8vIENhbGN1bGF0ZSBjbG9zZXN0IHBvaW50IG9uIGxpbmUgc2VnbWVudFxuICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IHZlY18xLnZlYzIuYWRkKGxpbmUuc3RhcnQsIHZlY18xLnZlYzIubXVsKGxpbmVEaXJlY3Rpb24sIGNsYW1wZWRQcm9qZWN0aW9uKSk7XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGZyb20gcG9pbnQgdG8gY2xvc2VzdCBwb2ludFxuICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIocG9pbnQsIGNsb3Nlc3RQb2ludCkpO1xuICAgIC8vIFBvaW50IGlzIG9uIGxpbmUgaWYgZGlzdGFuY2UgaXMgZWZmZWN0aXZlbHkgemVyb1xuICAgIGNvbnN0IGludGVyc2VjdHMgPSBkaXN0YW5jZSA8IGNvbnN0YW50cy5FUFNJTE9OO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIG5vcm1hbFxuICAgIGxldCBub3JtYWw7XG4gICAgaWYgKCFpbnRlcnNlY3RzKSB7XG4gICAgICAgIC8vIEdldCBhIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSByYXkgZGlyZWN0aW9uIGJ5IHJvdGF0aW5nIGl0IDkwIGRlZ3JlZXNcbiAgICAgICAgY29uc3QgcmF5Tm9ybWFsID0gdmVjXzEudmVjMi5yb3RmKGxpbmVEaXJlY3Rpb24sIC0xKTtcbiAgICAgICAgLy8gVXNlIHRoZSBjcm9zcyBwcm9kdWN0IHRvIGRldGVybWluZSB3aGljaCBzaWRlIG9mIHRoZSByYXkgdGhlIHBvaW50IGlzIG9uXG4gICAgICAgIGNvbnN0IGNyb3NzUHJvZHVjdCA9IHZlY18xLnZlYzIuY3Jvc3MobGluZURpcmVjdGlvbiwgdG9Qb2ludCk7XG4gICAgICAgIC8vIElmIGNyb3NzIHByb2R1Y3QgaXMgbmVnYXRpdmUsIHBvaW50IGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSByYXlcbiAgICAgICAgLy8gSWYgcG9zaXRpdmUsIHBvaW50IGlzIG9uIHRoZSBsZWZ0IHNpZGVcbiAgICAgICAgbm9ybWFsID0gdmVjXzEudmVjMi5tdWwocmF5Tm9ybWFsLCBNYXRoLnNpZ24oY3Jvc3NQcm9kdWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHMsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIG5vcm1hbCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhIGNpcmNsZVxuICovXG5mdW5jdGlvbiBwb2ludEluQ2lyY2xlKHBvaW50LCBjaXJjbGUpIHtcbiAgICAvLyBDYWxjdWxhdGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byBwb2ludFxuICAgIGNvbnN0IHRvUG9pbnQgPSB2ZWNfMS52ZWMyLnN1Yihwb2ludCwgY2lyY2xlLnBvc2l0aW9uKTtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgZnJvbSBwb2ludCB0byBjaXJjbGUgY2VudGVyXG4gICAgY29uc3QgZGlzdGFuY2VUb0NlbnRlciA9IHZlY18xLnZlYzIubGVuKHRvUG9pbnQpO1xuICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgY2lyY2xlXG4gICAgY29uc3QgaW50ZXJzZWN0cyA9IGRpc3RhbmNlVG9DZW50ZXIgPD0gY2lyY2xlLnJhZGl1cztcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2lyY2xlIGVkZ2VcbiAgICBjb25zdCBkaXN0YW5jZSA9IGludGVyc2VjdHNcbiAgICAgICAgPyAtKGNpcmNsZS5yYWRpdXMgLSBkaXN0YW5jZVRvQ2VudGVyKSAvLyBOZWdhdGl2ZSBpZiBpbnNpZGVcbiAgICAgICAgOiBkaXN0YW5jZVRvQ2VudGVyIC0gY2lyY2xlLnJhZGl1czsgLy8gUG9zaXRpdmUgaWYgb3V0c2lkZVxuICAgIC8vIENhbGN1bGF0ZSBjbG9zZXN0IHBvaW50IG9uIGNpcmNsZSBlZGdlXG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gdmVjXzEudmVjMi5hZGQoY2lyY2xlLnBvc2l0aW9uLCB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcih0b1BvaW50KSwgY2lyY2xlLnJhZGl1cykpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIG5vcm1hbFxuICAgIGNvbnN0IG5vcm1hbCA9IGludGVyc2VjdHNcbiAgICAgICAgPyB2ZWNfMS52ZWMyLm5vcih0b1BvaW50KSAvLyBOb3JtYWwgcG9pbnRzIG91dHdhcmQgZnJvbSBjaXJjbGUgY2VudGVyXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHMsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIG5vcm1hbCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluc2lkZSBhIHJlY3RhbmdsZVxuICpcbiAqIEluIGNhc2VzIHdoZXJlIHRoZSBjbG9zZXN0IHBvaW50IGlzIGFtYmlndW91cyAoZS5nLiBjb3JuZXJzKSwgdGhlIGZpcnN0IGVkZ2VcbiAqIGVuY291bnRlcmVkIHdpdGggYSBjbG9zZXN0IHBvaW50IHdpbGwgYmUgcmV0dXJuZWQgYWZ0ZXIgZXZhbHVhdGluZyBlZGdlcyBpblxuICogdGhpcyBvcmRlcjpcbiAqIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCAoYmVmb3JlIGFwcGx5aW5nIHRoZSByZWN0YW5nbGUncyByb3RhdGlvbilcbiAqL1xuZnVuY3Rpb24gcG9pbnRJblJlY3RhbmdsZShwb2ludCwgcmVjdGFuZ2xlKSB7XG4gICAgLy8gRWRnZSBjYXNlOiB6ZXJvLXNpemUgcmVjdGFuZ2xlXG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShyZWN0YW5nbGUuc2l6ZSkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlY3RhbmdsZSBoYXMgbm8gc2l6ZSwgY2hlY2sgaWYgdGhlIHBvaW50IGlzIGF0IHRoZSByZWN0YW5nbGUnc1xuICAgICAgICAvLyBwb3NpdGlvblxuICAgICAgICBjb25zdCBpc0F0UG9zaXRpb24gPSAoMCwgdXRpbGl0aWVzXzEudmVjdG9yc0FsbW9zdEVxdWFsKShwb2ludCwgcmVjdGFuZ2xlLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IGlzQXRQb3NpdGlvbixcbiAgICAgICAgICAgIGNsb3Nlc3RQb2ludDogcmVjdGFuZ2xlLnBvc2l0aW9uLFxuICAgICAgICAgICAgZGlzdGFuY2U6IGlzQXRQb3NpdGlvblxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIocG9pbnQsIHJlY3RhbmdsZS5wb3NpdGlvbikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHJlY3RhbmdsZSB0byBwb2x5Z29uXG4gICAgY29uc3QgdmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGUpO1xuICAgIGNvbnN0IHBvbHlnb25SZXN1bHQgPSBwb2ludEluUG9seWdvbihwb2ludCwgeyB2ZXJ0aWNlcyB9KTtcbiAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGhhdmUgYSB2YWxpZCBwb2x5Z29uLCBidXQganVzdCBpbiBjYXNlLi4uXG4gICAgaWYgKCFwb2x5Z29uUmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWN0YW5nbGUgdmVydGljZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlnb25SZXN1bHQ7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvbHlnb24gaXMgdmFsaWRcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgcG9seWdvbidzIHdpbmRpbmcgb3JkZXIgKHdlJ2xsIG5lZWQgdGhpcyBsYXRlciB0byBjYWxjdWxhdGVcbiAgICAvLyB0aGUgaW50ZXJzZWN0aW5nIHN1cmZhY2Ugbm9ybWFsKVxuICAgIGNvbnN0IHdpbmRpbmdPcmRlciA9IHBvbHlnb25XaW5kaW5nT3JkZXIocG9seWdvbik7XG4gICAgLy8gRmluZCBpZiBwb2ludCBpcyBpbnNpZGUgcG9seWdvbiB1c2luZyByYXkgY2FzdGluZyBhbGdvcml0aG1cbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgY29uc3QgdmVydGljZXMgPSBwb2x5Z29uLnZlcnRpY2VzO1xuICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBlZGdlIHdoaWxlIHdlIGl0ZXJhdGVcbiAgICBsZXQgbWluRGlzdGFuY2VTcXVhcmVkID0gSW5maW5pdHk7XG4gICAgbGV0IGNsb3Nlc3RQb2ludCA9IHBvaW50O1xuICAgIGxldCBub3JtYWwgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gKGkgKyAxKSAlIHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdmkgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgY29uc3QgdmogPSB2ZXJ0aWNlc1tqXTtcbiAgICAgICAgLy8gUmF5IGNhc3RpbmcgYWxnb3JpdGhtXG4gICAgICAgIGlmICh2aS55ID4gcG9pbnQueSAhPT0gdmoueSA+IHBvaW50LnkgJiZcbiAgICAgICAgICAgIHBvaW50LnggPCAoKHZqLnggLSB2aS54KSAqIChwb2ludC55IC0gdmkueSkpIC8gKHZqLnkgLSB2aS55KSArIHZpLngpIHtcbiAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBjbG9zZXN0IHBvaW50IG9uIHRoaXMgZWRnZVxuICAgICAgICBjb25zdCBlZGdlID0geyBzdGFydDogdmksIGVuZDogdmogfTtcbiAgICAgICAgY29uc3QgeyBjbG9zZXN0UG9pbnQ6IGVkZ2VDbG9zZXN0LCBkaXN0YW5jZTogZWRnZURpc3RhbmNlIH0gPSBwb2ludE9uTGluZShwb2ludCwgZWRnZSk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IGVkZ2VEaXN0YW5jZSAqIGVkZ2VEaXN0YW5jZTtcbiAgICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VTcXVhcmVkO1xuICAgICAgICAgICAgY2xvc2VzdFBvaW50ID0gZWRnZUNsb3Nlc3Q7XG4gICAgICAgICAgICBub3JtYWwgPSB2ZWNfMS52ZWMyLnJvdGYodmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIodmosIHZpKSksIHdpbmRpbmdPcmRlciA9PT0gJ2Nsb2Nrd2lzZScgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlU3F1YXJlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW5zaWRlLFxuICAgICAgICBjbG9zZXN0UG9pbnQsXG4gICAgICAgIGRpc3RhbmNlOiBpbnNpZGUgPyAtZGlzdGFuY2UgOiBkaXN0YW5jZSxcbiAgICAgICAgbm9ybWFsOiBpbnNpZGUgPyBub3JtYWwgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgd2hpY2ggZ3JpZCBjZWxscyBhIHJheSB0cmF2ZXJzZXNcbiAqXG4gKiBCYXNlZCBvbiBcIkEgRmFzdCBWb3hlbCBUcmF2ZXJzYWwgQWxnb3JpdGhtIGZvciBSYXkgVHJhY2luZ1wiIGJ5IEFtYW5hdGlkZXNcbiAqIGFuZCBXb29cbiAqXG4gKiBXZSBjYW4gb3B0aW9uYWxseSBsaW1pdCB0aGUgbnVtYmVyIG9mIGNlbGxzIHRyYXZlcnNlZCBieSB0aGUgcmF5LCBvciBzZXRcbiAqIG1heENlbGxzIHRvIC0xIHRvIGNvbnRpbnVlIHRyYXZlcnNpbmcgdW50aWwgdGhlIHJheSBleGl0cyB0aGUgZ3JpZCAob3IgdW50aWxcbiAqIHdlIGhpdCB0aGUgaGFyZCBsaW1pdCBvZiAxMDAwMCBjZWxscykuXG4gKi9cbmZ1bmN0aW9uIHJheVRyYXZlcnNlR3JpZChyYXksIGNlbGxTaXplLCBncmlkVG9wTGVmdCwgZ3JpZEJvdHRvbVJpZ2h0LCBtYXhDZWxscyA9IC0xKSB7XG4gICAgaWYgKGNlbGxTaXplIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHsgY2VsbHM6IFtdIH07IC8vIEludmFsaWQgY2VsbCBzaXplLCByZXR1cm4gZW1wdHkgY2VsbHMgYXJyYXlcbiAgICB9XG4gICAgLy8gU2V0IGEgbGltaXQgb24gdGhlIG51bWJlciBvZiBjZWxscyB0cmF2ZXJzZWRcbiAgICBjb25zdCBIQVJEX0xJTUlUID0gMTAwMDA7XG4gICAgbWF4Q2VsbHMgPSAoMCwgdXRpbHNfMS5jbGFtcCkobWF4Q2VsbHMgPT09IC0xID8gSEFSRF9MSU1JVCA6IG1heENlbGxzLCAwLCBIQVJEX0xJTUlUKTtcbiAgICBpZiAobWF4Q2VsbHMgPD0gMCkge1xuICAgICAgICByZXR1cm4geyBjZWxsczogW10gfTsgLy8gTm8gY2VsbHMgdG8gdHJhdmVyc2VcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBncmlkIHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgYm91bmRhcmllcyBhcmUgaW50ZWdlcnNcbiAgICBncmlkVG9wTGVmdCA9IHZlY18xLnZlYzIubWFwKGdyaWRUb3BMZWZ0LCBNYXRoLmZsb29yKTtcbiAgICBncmlkQm90dG9tUmlnaHQgPSB2ZWNfMS52ZWMyLm1hcChncmlkQm90dG9tUmlnaHQsIE1hdGguY2VpbCk7XG4gICAgLy8gTm9ybWFsaXplIHJheSBkaXJlY3Rpb24gYW5kIGhhbmRsZSB6ZXJvIGNvbXBvbmVudHNcbiAgICBjb25zdCByYXlEaXIgPSB2ZWNfMS52ZWMyLm5vcihyYXkuZGlyZWN0aW9uKTtcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKHJheURpcikpIHtcbiAgICAgICAgcmV0dXJuIHsgY2VsbHM6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgLy8gQ2FsY3VsYXRlIGluaXRpYWwgY2VsbCBjb29yZGluYXRlc1xuICAgIGxldCBjdXJyZW50Q2VsbCA9IHZlY18xLnZlYzIubWFwKHZlY18xLnZlYzIuZGl2KHZlY18xLnZlYzIuc3ViKHJheS5vcmlnaW4sIGdyaWRUb3BMZWZ0KSwgY2VsbFNpemUpLCBNYXRoLmZsb29yKTtcbiAgICAvLyBDYWxjdWxhdGUgZ3JpZCBzaXplIGluIGNlbGxzXG4gICAgY29uc3QgZ3JpZFNpemUgPSB2ZWNfMS52ZWMyLnN1YihncmlkQm90dG9tUmlnaHQsIGdyaWRUb3BMZWZ0KTtcbiAgICAvLyBJZiBzdGFydGluZyBwb2ludCBpcyBvdXRzaWRlIGdyaWQgYm91bmRzLCBmaW5kIGVudHJ5IHBvaW50XG4gICAgaWYgKGN1cnJlbnRDZWxsLnggPCAwIHx8XG4gICAgICAgIGN1cnJlbnRDZWxsLnggPj0gZ3JpZFNpemUueCB8fFxuICAgICAgICBjdXJyZW50Q2VsbC55IDwgMCB8fFxuICAgICAgICBjdXJyZW50Q2VsbC55ID49IGdyaWRTaXplLnkpIHtcbiAgICAgICAgLy8gVXNlIHJheUludGVyc2VjdHNSZWN0YW5nbGUgdG8gZmluZCBncmlkIGVudHJ5IHBvaW50XG4gICAgICAgIGNvbnN0IGdyaWRSZWN0ID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IHZlY18xLnZlYzIuYWRkKGdyaWRUb3BMZWZ0LCB2ZWNfMS52ZWMyLmRpdih2ZWNfMS52ZWMyLnN1YihncmlkQm90dG9tUmlnaHQsIGdyaWRUb3BMZWZ0KSwgMikpLFxuICAgICAgICAgICAgc2l6ZTogdmVjXzEudmVjMi5zdWIoZ3JpZEJvdHRvbVJpZ2h0LCBncmlkVG9wTGVmdCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IHJheUludGVyc2VjdHNSZWN0YW5nbGUocmF5LCBncmlkUmVjdCk7XG4gICAgICAgIGlmICghaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgfHwgIWludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNlbGxzIH07IC8vIFJheSBtaXNzZXMgZ3JpZCBlbnRpcmVseVxuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgZmlyc3QgaW50ZXJzZWN0aW9uIHBvaW50IChjbG9zZXN0IHRvIHJheSBvcmlnaW4pXG4gICAgICAgIGNvbnN0IGVudHJ5UG9pbnQgPSBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnRzWzBdO1xuICAgICAgICBjdXJyZW50Q2VsbCA9IHZlY18xLnZlYzIubWFwKHZlY18xLnZlYzIuZGl2KHZlY18xLnZlYzIuc3ViKGVudHJ5UG9pbnQsIGdyaWRUb3BMZWZ0KSwgY2VsbFNpemUpLCBNYXRoLmZsb29yKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgcG9pbnQgaXMgdmFsaWQgKHRoaXMgc2hvdWxkIG5ldmVyIGZhaWwgYnV0IGNoZWNrIGFueXdheSlcbiAgICAgICAgaWYgKGN1cnJlbnRDZWxsLnggPCAwIHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC54ID49IGdyaWRTaXplLnggfHxcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnkgPCAwIHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC55ID49IGdyaWRTaXplLnkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNlbGxzIH07IC8vIE5vIHZhbGlkIGVudHJ5IHBvaW50IGZvdW5kXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHN0ZXAgZGlyZWN0aW9uIChlaXRoZXIgMSBvciAtMSkgZm9yIGVhY2ggYXhpc1xuICAgIGNvbnN0IHN0ZXAgPSB7XG4gICAgICAgIHg6IE1hdGguc2lnbihyYXlEaXIueCksXG4gICAgICAgIHk6IE1hdGguc2lnbihyYXlEaXIueSksXG4gICAgfTtcbiAgICAvLyBDYWxjdWxhdGUgdERlbHRhIC0gZGlzdGFuY2UgYWxvbmcgcmF5IGZyb20gb25lIGdyaWQgbGluZSB0byBuZXh0XG4gICAgY29uc3QgdERlbHRhID0ge1xuICAgICAgICB4OiByYXlEaXIueCAhPT0gMCA/IE1hdGguYWJzKGNlbGxTaXplIC8gcmF5RGlyLngpIDogSW5maW5pdHksXG4gICAgICAgIHk6IHJheURpci55ICE9PSAwID8gTWF0aC5hYnMoY2VsbFNpemUgLyByYXlEaXIueSkgOiBJbmZpbml0eSxcbiAgICB9O1xuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIGNlbGwgYm91bmRhcnkgcG9zaXRpb25zXG4gICAgY29uc3QgaW5pdGlhbEJvdW5kYXJ5ID0gKDAsIHZlY18xLnZlYzIpKGdyaWRUb3BMZWZ0LnggKyAoY3VycmVudENlbGwueCArIChzdGVwLnggPiAwID8gMSA6IDApKSAqIGNlbGxTaXplLCBncmlkVG9wTGVmdC55ICsgKGN1cnJlbnRDZWxsLnkgKyAoc3RlcC55ID4gMCA/IDEgOiAwKSkgKiBjZWxsU2l6ZSk7XG4gICAgLy8gQ2FsY3VsYXRlIGluaXRpYWwgdE1heCB2YWx1ZXMsIGhhbmRsaW5nIGJvdW5kYXJ5IGNhc2VzXG4gICAgY29uc3QgdE1heCA9IHtcbiAgICAgICAgeDogcmF5RGlyLnggIT09IDBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoKGluaXRpYWxCb3VuZGFyeS54IC0gcmF5Lm9yaWdpbi54KSAvIHJheURpci54KVxuICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgeTogcmF5RGlyLnkgIT09IDBcbiAgICAgICAgICAgID8gTWF0aC5hYnMoKGluaXRpYWxCb3VuZGFyeS55IC0gcmF5Lm9yaWdpbi55KSAvIHJheURpci55KVxuICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICB9O1xuICAgIC8vIElmIHdlJ3JlIGV4YWN0bHkgb24gYSBib3VuZGFyeSwgd2UgbmVlZCB0byBhZGp1c3QgdE1heFxuICAgIGlmIChNYXRoLmFicyhyYXkub3JpZ2luLnggLSBpbml0aWFsQm91bmRhcnkueCkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICB0TWF4LnggPSB0RGVsdGEueDtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHJheS5vcmlnaW4ueSAtIGluaXRpYWxCb3VuZGFyeS55KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHRNYXgueSA9IHREZWx0YS55O1xuICAgIH1cbiAgICAvLyBBZGQgc3RhcnRpbmcgY2VsbFxuICAgIGNlbGxzLnB1c2goKDAsIHZlY18xLnZlYzIpKGN1cnJlbnRDZWxsLngsIGN1cnJlbnRDZWxsLnkpKTtcbiAgICBsZXQgY2VsbENvdW50ID0gMTtcbiAgICAvLyBNYWluIGxvb3BcbiAgICB3aGlsZSAoY2VsbENvdW50IDwgbWF4Q2VsbHMgJiZcbiAgICAgICAgY3VycmVudENlbGwueCA+PSAwICYmXG4gICAgICAgIGN1cnJlbnRDZWxsLnggPCBncmlkU2l6ZS54ICYmXG4gICAgICAgIGN1cnJlbnRDZWxsLnkgPj0gMCAmJlxuICAgICAgICBjdXJyZW50Q2VsbC55IDwgZ3JpZFNpemUueSkge1xuICAgICAgICAvLyBBZHZhbmNlIHRvIG5leHQgY2VsbCBiYXNlZCBvbiBzaG9ydGVzdCB0TWF4XG4gICAgICAgIGlmICh0TWF4LnggPCB0TWF4LnkpIHtcbiAgICAgICAgICAgIHRNYXgueCArPSB0RGVsdGEueDtcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsLnggKz0gc3RlcC54O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdE1heC55ICs9IHREZWx0YS55O1xuICAgICAgICAgICAgY3VycmVudENlbGwueSArPSBzdGVwLnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RpbGwgaW4gYm91bmRzXG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC54IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueCA+PSBncmlkU2l6ZS54IHx8XG4gICAgICAgICAgICBjdXJyZW50Q2VsbC55IDwgMCB8fFxuICAgICAgICAgICAgY3VycmVudENlbGwueSA+PSBncmlkU2l6ZS55KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgY3VycmVudCBjZWxsXG4gICAgICAgIGNlbGxzLnB1c2goKDAsIHZlY18xLnZlYzIpKGN1cnJlbnRDZWxsLngsIGN1cnJlbnRDZWxsLnkpKTtcbiAgICAgICAgY2VsbENvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiB7IGNlbGxzIH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byByYXlzIGludGVyc2VjdFxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzUmF5KHJheUEsIHJheUIpIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgZGlyQSA9IHZlY18xLnZlYzIubm9yKHJheUEuZGlyZWN0aW9uKTtcbiAgICBjb25zdCBkaXJCID0gdmVjXzEudmVjMi5ub3IocmF5Qi5kaXJlY3Rpb24pO1xuICAgIC8vIElmIGVpdGhlciByYXkgaGFzIHplcm8gZGlyZWN0aW9uLCB0aGV5IGNhbm5vdCBpbnRlcnNlY3RcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKGRpckEpIHx8ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShkaXJCKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY3Jvc3MgcHJvZHVjdCBkZXRlcm1pbmFudFxuICAgIGNvbnN0IGRldCA9IHZlY18xLnZlYzIuY3Jvc3MoZGlyQSwgZGlyQik7XG4gICAgLy8gR2V0IHRoZSB2ZWN0b3IgYmV0d2VlbiBzdGFydGluZyBwb2ludHNcbiAgICBjb25zdCBzdGFydERpZmYgPSB2ZWNfMS52ZWMyLnN1YihyYXlCLm9yaWdpbiwgcmF5QS5vcmlnaW4pO1xuICAgIC8vIElmIGRldGVybWluYW50IGlzIGNsb3NlIHRvIDAsIHJheXMgYXJlIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcmF5cyBhcmUgY29sbGluZWFyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgZGlyQSkpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIFJheXMgYXJlIGNvbGxpbmVhciAtIGNoZWNrIGlmIHRoZXkgb3ZlcmxhcFxuICAgICAgICAgICAgY29uc3QgdCA9IHZlY18xLnZlYzIuZG90KHN0YXJ0RGlmZiwgZGlyQSk7XG4gICAgICAgICAgICAvLyBGb3IgcmF5cyBwb2ludGluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb246XG4gICAgICAgICAgICAvLyBJZiB0IDw9IDA6IHJheUEncyBvcmlnaW4gaXMgYmVoaW5kIG9yIGF0IHJheUIncyBvcmlnaW5cbiAgICAgICAgICAgIC8vIElmIHQgPj0gMDogcmF5QidzIG9yaWdpbiBpcyBiZWhpbmQgb3IgYXQgcmF5QSdzIG9yaWdpblxuICAgICAgICAgICAgLy8gZG90KGRpckEsIGRpckIpIHNob3VsZCBiZSBjbG9zZSB0byAxIGZvciBzYW1lIGRpcmVjdGlvblxuICAgICAgICAgICAgaWYgKCh0IDw9IDAgfHwgdCA+PSAwKSAmJiB2ZWNfMS52ZWMyLmRvdChkaXJBLCBkaXJCKSA+IDEgLSBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnQgZm9yIG92ZXJsYXBwaW5nIHJheXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwYXJhbWV0ZXJzXG4gICAgY29uc3QgdCA9IHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBkaXJCKSAvIGRldDtcbiAgICBjb25zdCBzID0gdmVjXzEudmVjMi5jcm9zcyhzdGFydERpZmYsIGRpckEpIC8gZGV0O1xuICAgIC8vIENoZWNrIGlmIGludGVyc2VjdGlvbiBvY2N1cnMgb24gYm90aCByYXlzICh0ID49IDAgYW5kIHMgPj0gMClcbiAgICBpZiAodCA+PSAwICYmIHMgPj0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50OiB2ZWNfMS52ZWMyLmFkZChyYXlBLm9yaWdpbiwgdmVjXzEudmVjMi5tdWwoZGlyQSwgdCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJheSBpbnRlcnNlY3RzIGEgbGluZSBzZWdtZW50XG4gKi9cbmZ1bmN0aW9uIHJheUludGVyc2VjdHNMaW5lKHJheSwgbGluZSkge1xuICAgIC8vIENvbnZlcnQgbGluZSB0byBhIGRpcmVjdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBsaW5lRGlyID0gdmVjXzEudmVjMi5zdWIobGluZS5lbmQsIGxpbmUuc3RhcnQpO1xuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcmF5IGRpcmVjdGlvblxuICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgIC8vIElmIGVpdGhlciB0aGUgcmF5IG9yIHRoZSBsaW5lIGhhcyB6ZXJvIGRpcmVjdGlvbiwgdGhleSBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShsaW5lRGlyKSB8fCAoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmF5RGlyKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY3Jvc3MgcHJvZHVjdCBkZXRlcm1pbmFudFxuICAgIGNvbnN0IGRldCA9IHZlY18xLnZlYzIuY3Jvc3MocmF5RGlyLCBsaW5lRGlyKTtcbiAgICAvLyBHZXQgdGhlIHZlY3RvciBiZXR3ZWVuIHJheSBvcmlnaW4gYW5kIGxpbmUgc3RhcnRcbiAgICBjb25zdCBzdGFydERpZmYgPSB2ZWNfMS52ZWMyLnN1YihsaW5lLnN0YXJ0LCByYXkub3JpZ2luKTtcbiAgICAvLyBJZiBkZXRlcm1pbmFudCBpcyBjbG9zZSB0byAwLCByYXkgYW5kIGxpbmUgYXJlIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgY29sbGluZWFyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgcmF5RGlyKSkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAgICAgLy8gVGhleSBhcmUgY29sbGluZWFyIC0gcHJvamVjdCB0aGUgbGluZSBlbmRwb2ludHMgb250byB0aGUgcmF5XG4gICAgICAgICAgICBjb25zdCB0MSA9IHZlY18xLnZlYzIuZG90KHZlY18xLnZlYzIuc3ViKGxpbmUuc3RhcnQsIHJheS5vcmlnaW4pLCByYXlEaXIpO1xuICAgICAgICAgICAgY29uc3QgdDIgPSB2ZWNfMS52ZWMyLmRvdCh2ZWNfMS52ZWMyLnN1YihsaW5lLmVuZCwgcmF5Lm9yaWdpbiksIHJheURpcik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgcGFydCBvZiB0aGUgbGluZSBzZWdtZW50IGlzIGluIGZyb250IG9mIHRoZSByYXlcbiAgICAgICAgICAgIGlmICgodDEgPj0gMCB8fCB0MiA+PSAwKSAmJiBNYXRoLm1pbih0MSwgdDIpIDw9IHZlY18xLnZlYzIubGVuKGxpbmVEaXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludCBmb3Igb3ZlcmxhcHBpbmcgc2VnbWVudHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwYXJhbWV0ZXJzXG4gICAgY29uc3QgdCA9IHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBsaW5lRGlyKSAvIGRldDsgLy8gUmF5IHBhcmFtZXRlclxuICAgIGNvbnN0IHMgPSB2ZWNfMS52ZWMyLmNyb3NzKHN0YXJ0RGlmZiwgcmF5RGlyKSAvIGRldDsgLy8gTGluZSBwYXJhbWV0ZXJcbiAgICAvLyBDaGVjayBpZiBpbnRlcnNlY3Rpb24gb2NjdXJzIG9uIHRoZSByYXkgKHQgPj0gMCkgYW5kIHdpdGhpbiB0aGUgbGluZVxuICAgIC8vIHNlZ21lbnQgKDAgPD0gcyA8PSAxKVxuICAgIGlmICh0ID49IDAgJiYgcyA+PSAwICYmIHMgPD0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50OiB2ZWNfMS52ZWMyLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMyLm11bChyYXlEaXIsIHQpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByYXkgaW50ZXJzZWN0cyBhIGNpcmNsZVxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzQ2lyY2xlKHJheSwgY2lyY2xlKSB7XG4gICAgLy8gMS4gUGFyYW1ldGVyaXplZCByYXkgZXF1YXRpb246IFAodCkgPSBvcmlnaW4gKyB0ICogZGlyZWN0aW9uXG4gICAgY29uc3QgcmF5RGlyID0gdmVjXzEudmVjMi5ub3IocmF5LmRpcmVjdGlvbik7XG4gICAgLy8gQ2FsY3VsYXRlIHZlY3RvciBmcm9tIHJheSBvcmlnaW4gdG8gY2lyY2xlIGNlbnRlclxuICAgIGNvbnN0IHRvQ2VudGVyID0gdmVjXzEudmVjMi5zdWIoY2lyY2xlLnBvc2l0aW9uLCByYXkub3JpZ2luKTtcbiAgICAvLyAyLiBTdWJzdGl0dXRlIHJheSBlcXVhdGlvbiBpbnRvIGNpcmNsZSBlcXVhdGlvbjpcbiAgICAvLyAob3JpZ2luLnggKyB0KmRpci54IC0gY2lyY2xlLngpwrIgKyAob3JpZ2luLnkgKyB0KmRpci55IC0gY2lyY2xlLnkpwrIgPSBywrJcbiAgICAvLyBFeHBhbmQgYW5kIGNvbGxlY3QgdGVybXMgdG8gZ2V0IHF1YWRyYXRpYyBlcXVhdGlvbjogYXTCsiArIGJ0ICsgYyA9IDBcbiAgICAvLyBhID0gZG90KGRpciwgZGlyKSAoc2hvdWxkIGJlIDEgc2luY2UgZGlyIGlzIG5vcm1hbGl6ZWQpXG4gICAgY29uc3QgYSA9IHZlY18xLnZlYzIuZG90KHJheURpciwgcmF5RGlyKTtcbiAgICAvLyBiID0gMiAqIGRvdChkaXIsIChvcmlnaW4gLSBjZW50ZXIpKVxuICAgIGNvbnN0IGIgPSAyICogdmVjXzEudmVjMi5kb3QocmF5RGlyLCB2ZWNfMS52ZWMyLm11bCh0b0NlbnRlciwgLTEpKTtcbiAgICAvLyBjID0gZG90KChvcmlnaW4gLSBjZW50ZXIpLCAob3JpZ2luIC0gY2VudGVyKSkgLSByYWRpdXPCslxuICAgIGNvbnN0IGMgPSB2ZWNfMS52ZWMyLmRvdCh0b0NlbnRlciwgdG9DZW50ZXIpIC0gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXM7XG4gICAgLy8gMy4gU29sdmUgcXVhZHJhdGljIGVxdWF0aW9uIHVzaW5nIGRpc2NyaW1pbmFudFxuICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgIC8vIDQuIENoZWNrIGlmIHNvbHV0aW9ucyBleGlzdCAoZGlzY3JpbWluYW50ID49IDApXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IC1jb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSByYXkganVzdCB0b3VjaGVzIGNpcmNsZSAoZGlzY3JpbWluYW50IOKJiCAwKVxuICAgIGlmIChNYXRoLmFicyhkaXNjcmltaW5hbnQpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgY29uc3QgdCA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSB2ZWNfMS52ZWMyLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMyLm11bChyYXlEaXIsIHQpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IFtwb2ludF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIDUuIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZvciBkaXNjcmltaW5hbnQgPiAwXG4gICAgY29uc3Qgc3FydERpc2NyaW1pbmFudCA9IE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIGNvbnN0IHQxID0gKC1iIC0gc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iICsgc3FydERpc2NyaW1pbmFudCkgLyAoMiAqIGEpO1xuICAgIC8vIElmIGJvdGggdCB2YWx1ZXMgYXJlIG5lZ2F0aXZlLCByYXkgcG9pbnRzIGF3YXkgZnJvbSBjaXJjbGVcbiAgICBpZiAodDIgPCAwKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZvciBwb3NpdGl2ZSB0IHZhbHVlc1xuICAgIGxldCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBpZiAodDEgPj0gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh2ZWNfMS52ZWMyLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMyLm11bChyYXlEaXIsIHQxKSkpO1xuICAgIH1cbiAgICBpZiAodDIgPj0gMCkge1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaCh2ZWNfMS52ZWMyLmFkZChyYXkub3JpZ2luLCB2ZWNfMS52ZWMyLm11bChyYXlEaXIsIHQyKSkpO1xuICAgIH1cbiAgICBpbnRlcnNlY3Rpb25Qb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgYSByZWN0YW5nbGVcbiAqL1xuZnVuY3Rpb24gcmF5SW50ZXJzZWN0c1JlY3RhbmdsZShyYXksIHJlY3RhbmdsZSkge1xuICAgIC8vIEdldCB2ZXJ0aWNlcyBvZiB0aGUgcmVjdGFuZ2xlIGluIGNsb2Nrd2lzZSBvcmRlclxuICAgIGNvbnN0IHZlcnRpY2VzID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlKTtcbiAgICBsZXQgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBlZGdlIG9mIHRoZSByZWN0YW5nbGUgZm9yIGludGVyc2VjdGlvblxuICAgIGNvbnN0IGVkZ2VzID0gdmVydGljZXNUb0VkZ2VzKHZlcnRpY2VzKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmF5SW50ZXJzZWN0c0xpbmUocmF5LCBlZGdlKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIHNvcnQgYnkgZGlzdGFuY2UgdG8gcmF5IG9yaWdpblxuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHJheURpciA9IHZlY18xLnZlYzIubm9yKHJheS5kaXJlY3Rpb24pO1xuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdEEgPSB2ZWNfMS52ZWMyLmRvdCh2ZWNfMS52ZWMyLnN1YihhLCByYXkub3JpZ2luKSwgcmF5RGlyKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RCID0gdmVjXzEudmVjMi5kb3QodmVjXzEudmVjMi5zdWIoYiwgcmF5Lm9yaWdpbiksIHJheURpcik7XG4gICAgICAgICAgICByZXR1cm4gZGlzdEEgLSBkaXN0QjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgcmF5IGludGVyc2VjdHMgdGhlIGVkZ2VzIG9mIGEgY29udmV4IHBvbHlnb25cbiAqXG4gKiBXZSBhc3N1bWUgdGhlIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciB2YWxpZGl0eSBhbmQgY29udmV4aXR5XG4gKi9cbmZ1bmN0aW9uIHJheUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhyYXksIGVkZ2VzKSB7XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggb3V0ZXIgZWRnZSBmb3IgaW50ZXJzZWN0aW9uc1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSByYXlJbnRlcnNlY3RzTGluZShyYXksIGVkZ2UpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBhbmQgc29ydCBieSBkaXN0YW5jZSB0byByYXkgb3JpZ2luXG4gICAgaW50ZXJzZWN0aW9uUG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlVmVydGljZXMoaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgcmF5RGlyID0gdmVjXzEudmVjMi5ub3IocmF5LmRpcmVjdGlvbik7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0QSA9IHZlY18xLnZlYzIuZG90KHZlY18xLnZlYzIuc3ViKGEsIHJheS5vcmlnaW4pLCByYXlEaXIpO1xuICAgICAgICAgICAgY29uc3QgZGlzdEIgPSB2ZWNfMS52ZWMyLmRvdCh2ZWNfMS52ZWMyLnN1YihiLCByYXkub3JpZ2luKSwgcmF5RGlyKTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0QSAtIGRpc3RCO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSByYXkgaW50ZXJzZWN0cyBhIHBvbHlnb25cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZFxuICovXG5mdW5jdGlvbiByYXlJbnRlcnNlY3RzUG9seWdvbihyYXksIHBvbHlnb24pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgcG9seWdvbiBpcyB2YWxpZFxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIElmIHBvbHlnb24gaXMgbm90IGNvbnZleCwgZGVjb21wb3NlIGl0IGludG8gY29udmV4IHBvbHlnb25zXG4gICAgaWYgKCFwb2x5Z29uSXNDb252ZXgocG9seWdvbikpIHtcbiAgICAgICAgY29uc3QgY29udmV4UG9seWdvbnMgPSBkZWNvbXBvc2VQb2x5Z29uKHBvbHlnb24pO1xuICAgICAgICBpZiAoIWNvbnZleFBvbHlnb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGUgcmF5IGFnYWluc3QgdGhlIG91dGVyIGVkZ2VzIG9mIGVhY2ggY29udmV4IHBvbHlnb25zXG4gICAgICAgIHJldHVybiByYXlJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMocmF5LCBmaW5kT3V0ZXJFZGdlcyhjb252ZXhQb2x5Z29ucykpO1xuICAgIH1cbiAgICAvLyBGb3IgY29udmV4IHBvbHlnb25zLCBjaGVjayBlYWNoIGVkZ2VcbiAgICByZXR1cm4gcmF5SW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzKHJheSwgdmVydGljZXNUb0VkZ2VzKHBvbHlnb24udmVydGljZXMpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIHJheVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c1JheShsaW5lLCByYXkpIHtcbiAgICByZXR1cm4gcmF5SW50ZXJzZWN0c0xpbmUocmF5LCBsaW5lKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0XG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsaW5lQSwgbGluZUIpIHtcbiAgICAvLyBHZXQgdGhlIHZlY3RvcnMgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb25zIG9mIGVhY2ggbGluZVxuICAgIGNvbnN0IGRpckEgPSB2ZWNfMS52ZWMyLnN1YihsaW5lQS5lbmQsIGxpbmVBLnN0YXJ0KTtcbiAgICBjb25zdCBkaXJCID0gdmVjXzEudmVjMi5zdWIobGluZUIuZW5kLCBsaW5lQi5zdGFydCk7XG4gICAgLy8gSWYgZWl0aGVyIGxpbmUgaGFzIHplcm8gZGlyZWN0aW9uLCB0aGV5IGNhbm5vdCBpbnRlcnNlY3RcbiAgICBpZiAoKDAsIHV0aWxpdGllc18xLnZlY3RvckFsbW9zdFplcm8pKGRpckEpIHx8ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShkaXJCKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY3Jvc3MgcHJvZHVjdCBkZXRlcm1pbmFudFxuICAgIGNvbnN0IGRldCA9IHZlY18xLnZlYzIuY3Jvc3MoZGlyQSwgZGlyQik7XG4gICAgLy8gR2V0IHRoZSB2ZWN0b3IgYmV0d2VlbiBzdGFydGluZyBwb2ludHNcbiAgICBjb25zdCBzdGFydERpZmYgPSB2ZWNfMS52ZWMyLnN1YihsaW5lQi5zdGFydCwgbGluZUEuc3RhcnQpO1xuICAgIC8vIElmIGRldGVybWluYW50IGlzIGNsb3NlIHRvIDAsIGxpbmVzIGFyZSBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IGNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGxpbmVzIGFyZSBjb2xsaW5lYXJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBkaXJBKSkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIGNvbGxpbmVhciAtIGNoZWNrIGlmIHRoZXkgb3ZlcmxhcFxuICAgICAgICAgICAgY29uc3QgdDAgPSB2ZWNfMS52ZWMyLmRvdChzdGFydERpZmYsIGRpckEpIC8gdmVjXzEudmVjMi5kb3QoZGlyQSwgZGlyQSk7XG4gICAgICAgICAgICBjb25zdCB0MSA9IHQwICsgdmVjXzEudmVjMi5kb3QoZGlyQiwgZGlyQSkgLyB2ZWNfMS52ZWMyLmRvdChkaXJBLCBkaXJBKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlZ21lbnRzIG92ZXJsYXBcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsMCA9IE1hdGgubWluKHQwLCB0MSk7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbDEgPSBNYXRoLm1heCh0MCwgdDEpO1xuICAgICAgICAgICAgaWYgKGludGVydmFsMCA8PSAxICYmIGludGVydmFsMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludCBmb3Igb3ZlcmxhcHBpbmcgbGluZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwYXJhbWV0ZXJzXG4gICAgY29uc3QgdCA9IHZlY18xLnZlYzIuY3Jvc3Moc3RhcnREaWZmLCBkaXJCKSAvIGRldDtcbiAgICBjb25zdCBzID0gdmVjXzEudmVjMi5jcm9zcyhzdGFydERpZmYsIGRpckEpIC8gZGV0O1xuICAgIC8vIENoZWNrIGlmIGludGVyc2VjdGlvbiBvY2N1cnMgd2l0aGluIGJvdGggbGluZSBzZWdtZW50c1xuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxICYmIHMgPj0gMCAmJiBzIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludDogdmVjXzEudmVjMi5hZGQobGluZUEuc3RhcnQsIHZlY18xLnZlYzIubXVsKGRpckEsIHQpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogZmFsc2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyBhIGNpcmNsZVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0c0NpcmNsZShsaW5lLCBjaXJjbGUpIHtcbiAgICAvLyAxLiBQYXJhbWV0ZXJpemVkIGxpbmUgZXF1YXRpb246IFAodCkgPSBzdGFydCArIHQgKiAoZW5kIC0gc3RhcnQpXG4gICAgY29uc3QgbGluZURpciA9IHZlY18xLnZlYzIuc3ViKGxpbmUuZW5kLCBsaW5lLnN0YXJ0KTtcbiAgICBjb25zdCBsaW5lTGVuZ3RoU3F1YXJlZCA9IHZlY18xLnZlYzIuZG90KGxpbmVEaXIsIGxpbmVEaXIpO1xuICAgIC8vIElmIHRoZSBsaW5lIHNlZ21lbnQgaGFzIHplcm8gbGVuZ3RoLCBpdCBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKGxpbmVMZW5ndGhTcXVhcmVkIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSWYgYm90aCBlbmRwb2ludHMgb2YgdGhlIGxpbmUgYXJlIGluc2lkZSB0aGUgY2lyY2xlLCB0aGVuIHdlIGhhdmUgYW5cbiAgICAvLyBpbnRlcnNlY3Rpb24gKGJ1dCBubyBpbnRlcnNlY3Rpb24gcG9pbnRzKVxuICAgIGlmIChwb2ludEluQ2lyY2xlKGxpbmUuc3RhcnQsIGNpcmNsZSkuaW50ZXJzZWN0cyAmJlxuICAgICAgICBwb2ludEluQ2lyY2xlKGxpbmUuZW5kLCBjaXJjbGUpLmludGVyc2VjdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdmVjdG9yIGZyb20gY2lyY2xlIGNlbnRlciB0byBsaW5lIHN0YXJ0XG4gICAgY29uc3QgdG9DZW50ZXIgPSB2ZWNfMS52ZWMyLnN1YihjaXJjbGUucG9zaXRpb24sIGxpbmUuc3RhcnQpO1xuICAgIC8vIDIuIFN1YnN0aXR1dGUgbGluZSBlcXVhdGlvbiBpbnRvIGNpcmNsZSBlcXVhdGlvbjpcbiAgICAvLyAoc3RhcnQueCArIHQqZGlyLnggLSBjaXJjbGUueCnCsiArIChzdGFydC55ICsgdCpkaXIueSAtIGNpcmNsZS55KcKyID0gcsKyXG4gICAgLy8gRXhwYW5kIGFuZCBjb2xsZWN0IHRlcm1zIHRvIGdldCBxdWFkcmF0aWMgZXF1YXRpb246IGF0wrIgKyBidCArIGMgPSAwXG4gICAgLy8gYSA9IGRvdChkaXIsIGRpcilcbiAgICBjb25zdCBhID0gbGluZUxlbmd0aFNxdWFyZWQ7XG4gICAgLy8gYiA9IDIgKiBkb3QoZGlyLCAoc3RhcnQgLSBjZW50ZXIpKVxuICAgIGNvbnN0IGIgPSAyICogdmVjXzEudmVjMi5kb3QobGluZURpciwgdmVjXzEudmVjMi5tdWwodG9DZW50ZXIsIC0xKSk7XG4gICAgLy8gYyA9IGRvdCgoc3RhcnQgLSBjZW50ZXIpLCAoc3RhcnQgLSBjZW50ZXIpKSAtIHJhZGl1c8KyXG4gICAgY29uc3QgYyA9IHZlY18xLnZlYzIuZG90KHRvQ2VudGVyLCB0b0NlbnRlcikgLSBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cztcbiAgICAvLyAzLiBTb2x2ZSBxdWFkcmF0aWMgZXF1YXRpb24gdXNpbmcgZGlzY3JpbWluYW50XG4gICAgY29uc3QgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gICAgLy8gSWYgZGlzY3JpbWluYW50IGlzIG5lZ2F0aXZlLCBubyBpbnRlcnNlY3Rpb25cbiAgICBpZiAoZGlzY3JpbWluYW50IDwgLWNvbnN0YW50cy5FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIGxpbmUganVzdCB0b3VjaGVzIGNpcmNsZSAoZGlzY3JpbWluYW50IOKJiCAwKVxuICAgIGlmIChNYXRoLmFicyhkaXNjcmltaW5hbnQpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgY29uc3QgdCA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gdmVjXzEudmVjMi5hZGQobGluZS5zdGFydCwgdmVjXzEudmVjMi5tdWwobGluZURpciwgdCkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50czogW3BvaW50XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBwb2ludHMgZm9yIGRpc2NyaW1pbmFudCA+IDBcbiAgICBjb25zdCBzcXJ0RGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdDEgPSAoLWIgLSBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgY29uc3QgdDIgPSAoLWIgKyBzcXJ0RGlzY3JpbWluYW50KSAvICgyICogYSk7XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIElmIGJvdGggdCB2YWx1ZXMgYXJlIG91dHNpZGUgWzAsIDFdLCBubyBpbnRlcnNlY3Rpb25cbiAgICBpZiAodDIgPCAwIHx8IHQxID4gMSkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3IgdmFsaWQgdCB2YWx1ZXNcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzIuYWRkKGxpbmUuc3RhcnQsIHZlY18xLnZlYzIubXVsKGxpbmVEaXIsIHQxKSkpO1xuICAgIH1cbiAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKHZlY18xLnZlYzIuYWRkKGxpbmUuc3RhcnQsIHZlY18xLnZlYzIubXVsKGxpbmVEaXIsIHQyKSkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIHNvcnQgYnkgZGlzdGFuY2UgdG8gbGluZSBzdGFydFxuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0QSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGEsIGxpbmUuc3RhcnQpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RCID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoYiwgbGluZS5zdGFydCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RBIC0gZGlzdEI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIGEgcmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzUmVjdGFuZ2xlKGxpbmUsIHJlY3RhbmdsZSkge1xuICAgIC8vIEVkZ2UgY2FzZTogemVyby1zaXplIHJlY3RhbmdsZVxuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmVjdGFuZ2xlLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gR2V0IHZlcnRpY2VzIG9mIHRoZSByZWN0YW5nbGUgaW4gY2xvY2t3aXNlIG9yZGVyXG4gICAgY29uc3QgdmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGUpO1xuICAgIC8vIElmIGJvdGggZW5kcG9pbnRzIGFyZSBpbnNpZGUsIGxpbmUgaXMgY29tcGxldGVseSBjb250YWluZWRcbiAgICBpZiAocG9pbnRJblJlY3RhbmdsZShsaW5lLnN0YXJ0LCByZWN0YW5nbGUpLmludGVyc2VjdHMgJiZcbiAgICAgICAgcG9pbnRJblJlY3RhbmdsZShsaW5lLmVuZCwgcmVjdGFuZ2xlKS5pbnRlcnNlY3RzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBlZGdlIG9mIHRoZSByZWN0YW5nbGUgZm9yIGludGVyc2VjdGlvblxuICAgIGNvbnN0IGVkZ2VzID0gdmVydGljZXNUb0VkZ2VzKHZlcnRpY2VzKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdHNMaW5lKGxpbmUsIGVkZ2UpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBhbmQgc29ydCBieSBkaXN0YW5jZSB0byBsaW5lIHN0YXJ0XG4gICAgaW50ZXJzZWN0aW9uUG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlVmVydGljZXMoaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RBID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoYSwgbGluZS5zdGFydCkpO1xuICAgICAgICAgICAgY29uc3QgZGlzdEIgPSB2ZWNfMS52ZWMyLmxlbih2ZWNfMS52ZWMyLnN1YihiLCBsaW5lLnN0YXJ0KSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdEEgLSBkaXN0QjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAwID8gaW50ZXJzZWN0aW9uUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgbGluZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGVkZ2VzIG9mIGEgY29udmV4IHBvbHlnb25cbiAqXG4gKiBXZSBhc3N1bWUgdGhlIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciB2YWxpZGl0eSBhbmQgY29udmV4aXR5XG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMobGluZSwgcG9seWdvbiwgZWRnZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxpbmUgc2VnbWVudCBpcyBlbnRpcmVseSBpbnNpZGUgcG9seWdvblxuICAgIGNvbnN0IG1pZHBvaW50ID0ge1xuICAgICAgICB4OiAobGluZS5zdGFydC54ICsgbGluZS5lbmQueCkgLyAyLFxuICAgICAgICB5OiAobGluZS5zdGFydC55ICsgbGluZS5lbmQueSkgLyAyLFxuICAgIH07XG4gICAgY29uc3QgcG9pbnRJbnNpZGUgPSBwb2ludEluUG9seWdvbihtaWRwb2ludCwgcG9seWdvbik7XG4gICAgY29uc3Qgc3RhcnRJbnNpZGUgPSBwb2ludEluUG9seWdvbihsaW5lLnN0YXJ0LCBwb2x5Z29uKTtcbiAgICBjb25zdCBlbmRJbnNpZGUgPSBwb2ludEluUG9seWdvbihsaW5lLmVuZCwgcG9seWdvbik7XG4gICAgaWYgKChwb2ludEluc2lkZSA9PT0gbnVsbCB8fCBwb2ludEluc2lkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRJbnNpZGUuaW50ZXJzZWN0cykgJiZcbiAgICAgICAgKHN0YXJ0SW5zaWRlID09PSBudWxsIHx8IHN0YXJ0SW5zaWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFydEluc2lkZS5pbnRlcnNlY3RzKSAmJlxuICAgICAgICAoZW5kSW5zaWRlID09PSBudWxsIHx8IGVuZEluc2lkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kSW5zaWRlLmludGVyc2VjdHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgaW50ZXJzZWN0aW9uUG9pbnRzID0gW107XG4gICAgLy8gQ2hlY2sgZWFjaCBvdXRlciBlZGdlIGZvciBpbnRlcnNlY3Rpb25zXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzTGluZShsaW5lLCBlZGdlKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbi5pbnRlcnNlY3RzICYmIGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25Qb2ludCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIHNvcnQgYnkgZGlzdGFuY2UgdG8gbGluZSBzdGFydFxuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0QSA9IHZlY18xLnZlYzIubGVuKHZlY18xLnZlYzIuc3ViKGEsIGxpbmUuc3RhcnQpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RCID0gdmVjXzEudmVjMi5sZW4odmVjXzEudmVjMi5zdWIoYiwgbGluZS5zdGFydCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RBIC0gZGlzdEI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiBpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCA/IGludGVyc2VjdGlvblBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGxpbmUgc2VnbWVudCBpbnRlcnNlY3RzIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzUG9seWdvbihsaW5lLCBwb2x5Z29uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHBvbHlnb24gaXMgdmFsaWRcbiAgICBpZiAoIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBJZiBwb2x5Z29uIGlzIG5vdCBjb252ZXgsIGRlY29tcG9zZSBpdCBpbnRvIGNvbnZleCBwb2x5Z29uc1xuICAgIGlmICghcG9seWdvbklzQ29udmV4KHBvbHlnb24pKSB7XG4gICAgICAgIGNvbnN0IGNvbnZleFBvbHlnb25zID0gZGVjb21wb3NlUG9seWdvbihwb2x5Z29uKTtcbiAgICAgICAgaWYgKCFjb252ZXhQb2x5Z29ucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlIGxpbmUgYWdhaW5zdCB0aGUgb3V0ZXIgZWRnZXMgb2YgZWFjaCBjb252ZXggcG9seWdvblxuICAgICAgICByZXR1cm4gbGluZUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhsaW5lLCBwb2x5Z29uLCBmaW5kT3V0ZXJFZGdlcyhjb252ZXhQb2x5Z29ucykpO1xuICAgIH1cbiAgICAvLyBGb3IgY29udmV4IHBvbHlnb25zLCBjaGVjayBlYWNoIGVkZ2VcbiAgICByZXR1cm4gbGluZUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhsaW5lLCBwb2x5Z29uLCB2ZXJ0aWNlc1RvRWRnZXMocG9seWdvbi52ZXJ0aWNlcykpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gY2lyY2xlcyBpbnRlcnNlY3RcbiAqL1xuZnVuY3Rpb24gY2lyY2xlSW50ZXJzZWN0c0NpcmNsZShjaXJjbGVBLCBjaXJjbGVCKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB2ZWN0b3IgZnJvbSBjZW50ZXIgQSB0byBjZW50ZXIgQlxuICAgIGNvbnN0IGNlbnRlclRvQ2VudGVyVmVjID0gdmVjXzEudmVjMi5zdWIoY2lyY2xlQi5wb3NpdGlvbiwgY2lyY2xlQS5wb3NpdGlvbik7XG4gICAgY29uc3QgY2VudGVyVG9DZW50ZXIgPSB2ZWNfMS52ZWMyLmxlbihjZW50ZXJUb0NlbnRlclZlYyk7XG4gICAgY29uc3Qgc3VtUmFkaWkgPSBjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzO1xuICAgIC8vIElmIGRpc3RhbmNlIGJldHdlZW4gY2VudGVycyBpcyBncmVhdGVyIHRoYW4gc3VtIG9mIHJhZGlpLCB0aGUgY2lyY2xlc1xuICAgIC8vIGRvbid0IGludGVyc2VjdFxuICAgIGlmIChjZW50ZXJUb0NlbnRlciA+IHN1bVJhZGlpICsgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHsgaW50ZXJzZWN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgLy8gSWYgY2lyY2xlcyBhcmUgaWRlbnRpY2FsIChzYW1lIHBvc2l0aW9uIGFuZCByYWRpdXMpLCB0aGV5IGhhdmUgaW5maW5pdGVseVxuICAgIC8vIG1hbnkgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgIGlmIChjZW50ZXJUb0NlbnRlciA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGNpcmNsZUEucmFkaXVzIC0gY2lyY2xlQi5yYWRpdXMpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbjogdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi51eCgpLCAyICogY2lyY2xlQS5yYWRpdXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBvbmUgY2lyY2xlIGlzIGluc2lkZSB0aGUgb3RoZXIgKG5vIGludGVyc2VjdGlvbiBwb2ludHMgYnV0IHN0aWxsXG4gICAgLy8gaW50ZXJzZWN0aW5nKVxuICAgIGNvbnN0IHJhZGl1c0RpZmYgPSBNYXRoLmFicyhjaXJjbGVBLnJhZGl1cyAtIGNpcmNsZUIucmFkaXVzKTtcbiAgICBpZiAoY2VudGVyVG9DZW50ZXIgPCByYWRpdXNEaWZmIC0gY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbjogdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IoY2VudGVyVG9DZW50ZXJWZWMpLCBjaXJjbGVBLnJhZGl1cyAtIGNlbnRlclRvQ2VudGVyICsgY2lyY2xlQi5yYWRpdXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmb3Igc3RhbmRhcmQgaW50ZXJzZWN0aW5nIGNhc2VcbiAgICAvLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1DaXJjbGVJbnRlcnNlY3Rpb24uaHRtbFxuICAgIGNvbnN0IGEgPSAoY2lyY2xlQS5yYWRpdXMgKiBjaXJjbGVBLnJhZGl1cyAtXG4gICAgICAgIGNpcmNsZUIucmFkaXVzICogY2lyY2xlQi5yYWRpdXMgK1xuICAgICAgICBjZW50ZXJUb0NlbnRlciAqIGNlbnRlclRvQ2VudGVyKSAvXG4gICAgICAgICgyICogY2VudGVyVG9DZW50ZXIpO1xuICAgIGNvbnN0IGggPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgY2lyY2xlQS5yYWRpdXMgKiBjaXJjbGVBLnJhZGl1cyAtIGEgKiBhKSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2ludCBvbiB0aGUgbGluZSBiZXR3ZWVuIGNlbnRlcnMgdGhhdCBpcyBkaXN0YW5jZSAnYScgZnJvbVxuICAgIC8vIGNpcmNsZSBBJ3MgY2VudGVyXG4gICAgY29uc3QgcCA9IHZlY18xLnZlYzIuYWRkKGNpcmNsZUEucG9zaXRpb24sIHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKGNlbnRlclRvQ2VudGVyVmVjKSwgYSkpO1xuICAgIC8vIElmIGNpcmNsZXMgYXJlIHRhbmdlbnQgKHRvdWNoaW5nIGF0IG9uZSBwb2ludClcbiAgICBpZiAoTWF0aC5hYnMoY2VudGVyVG9DZW50ZXIgLSBzdW1SYWRpaSkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50czogW3BdLFxuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb246ICgwLCB2ZWNfMS52ZWMyKSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIGdldCBib3RoIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICBjb25zdCBwZXJwVmVjID0gdmVjXzEudmVjMi5tdWwoKDAsIHZlY18xLnZlYzIpKHsgeDogLWNlbnRlclRvQ2VudGVyVmVjLnksIHk6IGNlbnRlclRvQ2VudGVyVmVjLnggfSksIGggLyBjZW50ZXJUb0NlbnRlcik7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUG9pbnRzID0gW3ZlY18xLnZlYzIuYWRkKHAsIHBlcnBWZWMpLCB2ZWNfMS52ZWMyLnN1YihwLCBwZXJwVmVjKV07XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHNlcGFyYXRpb24gdmVjdG9yXG4gICAgY29uc3QgbWluaW11bVNlcGFyYXRpb24gPSB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcihjZW50ZXJUb0NlbnRlclZlYyksIHN1bVJhZGlpIC0gY2VudGVyVG9DZW50ZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyc2VjdHM6IHRydWUsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50cyxcbiAgICAgICAgbWluaW11bVNlcGFyYXRpb24sXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjaXJjbGUgaW50ZXJzZWN0cyBhIHJlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBjaXJjbGVJbnRlcnNlY3RzUmVjdGFuZ2xlKGNpcmNsZSwgcmVjdGFuZ2xlKSB7XG4gICAgLy8gR2V0IHJlY3RhbmdsZSB2ZXJ0aWNlcyBzbyB3ZSBjYW4gdGVzdCBhZ2FpbnN0IHJvdGF0ZWQgcmVjdGFuZ2xlc1xuICAgIGNvbnN0IHZlcnRpY2VzID0gcmVjdGFuZ2xlVmVydGljZXMocmVjdGFuZ2xlKTtcbiAgICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzVG9FZGdlcyh2ZXJ0aWNlcyk7XG4gICAgLy8gQ2hlY2sgaWYgY2lyY2xlJ3MgY2VudGVyIGlzIGluc2lkZSByZWN0YW5nbGVcbiAgICBjb25zdCBwb2ludEluUmVjdFJlc3VsdCA9IHBvaW50SW5SZWN0YW5nbGUoY2lyY2xlLnBvc2l0aW9uLCByZWN0YW5nbGUpO1xuICAgIGNvbnN0IGNpcmNsZUNlbnRlckluc2lkZVJlY3RhbmdsZSA9IHBvaW50SW5SZWN0UmVzdWx0LmludGVyc2VjdHM7XG4gICAgLy8gQ2hlY2sgaWYgcmVjdGFuZ2xlJ3MgY2VudGVyIGlzIGluc2lkZSBjaXJjbGVcbiAgICBjb25zdCBwb2ludEluQ2lyY2xlUmVzdWx0ID0gcG9pbnRJbkNpcmNsZShyZWN0YW5nbGUucG9zaXRpb24sIGNpcmNsZSk7XG4gICAgY29uc3QgcmVjdGFuZ2xlQ2VudGVySW5zaWRlQ2lyY2xlID0gcG9pbnRJbkNpcmNsZVJlc3VsdC5pbnRlcnNlY3RzO1xuICAgIC8vIENoZWNrIGNpcmNsZSBpbnRlcnNlY3Rpb24gd2l0aCByZWN0YW5nbGUgZWRnZXNcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25Qb2ludHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbGluZUludGVyc2VjdHNDaXJjbGUoZWRnZSwgY2lyY2xlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pbnRlcnNlY3RzICYmIHJlc3VsdC5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKC4uLnJlc3VsdC5pbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBzZXBhcmF0aW9uIHZlY3RvclxuICAgIGxldCBtaW5pbXVtU2VwYXJhdGlvbjtcbiAgICBpZiAoTWF0aC5hYnMocG9pbnRJblJlY3RSZXN1bHQuZGlzdGFuY2UpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgbWluaW11bVNlcGFyYXRpb24gPSAoMCwgdmVjXzEudmVjMikoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocG9pbnRJblJlY3RSZXN1bHQuZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIocG9pbnRJblJlY3RSZXN1bHQuY2xvc2VzdFBvaW50LCBjaXJjbGUucG9zaXRpb24pKSwgY2lyY2xlLnJhZGl1cyArIE1hdGguYWJzKHBvaW50SW5SZWN0UmVzdWx0LmRpc3RhbmNlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKGNpcmNsZS5wb3NpdGlvbiwgcG9pbnRJblJlY3RSZXN1bHQuY2xvc2VzdFBvaW50KSksIGNpcmNsZS5yYWRpdXMgLSBwb2ludEluUmVjdFJlc3VsdC5kaXN0YW5jZSk7XG4gICAgfVxuICAgIC8vIElmIGVpdGhlciBzaGFwZSdzIGNlbnRlciBpcyBpbnNpZGUgdGhlIG90aGVyIGFuZCB0aGVyZSBhcmUgbm8gaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzLCBpdCBtZWFucyBvbmUgb2YgdGhlIHNoYXBlcyBjb21wbGV0ZWx5IGVuY2xvc2VzIHRoZSBvdGhlclxuICAgIGlmICgoY2lyY2xlQ2VudGVySW5zaWRlUmVjdGFuZ2xlIHx8IHJlY3RhbmdsZUNlbnRlckluc2lkZUNpcmNsZSkgJiZcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICBjb25zdCB1bmlxdWVQb2ludHMgPSByZW1vdmVEdXBsaWNhdGVWZXJ0aWNlcyhpbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgIGlmICh1bmlxdWVQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW50ZXJzZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50czogdW5pcXVlUG9pbnRzLFxuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY2lyY2xlIGludGVyc2VjdHMgdGhlIGVkZ2VzIG9mIGEgY29udmV4IHBvbHlnb25cbiAqXG4gKiBXZSBhc3N1bWUgdGhlIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciB2YWxpZGl0eSBhbmQgY29udmV4aXR5XG4gKi9cbmZ1bmN0aW9uIGNpcmNsZUludGVyc2VjdHNWYWxpZENvbnZleFBvbHlnb25FZGdlcyhjaXJjbGUsIGVkZ2VzLCBjaXJjbGVDZW50ZXJJbnNpZGVQb2x5Z29uLCBwb2x5Z29uQ2VudGVySW5zaWRlQ2lyY2xlKSB7XG4gICAgbGV0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIC8vIENoZWNrIGVhY2ggb3V0ZXIgZWRnZSBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBjaXJjbGVcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbGluZUludGVyc2VjdHNDaXJjbGUoZWRnZSwgY2lyY2xlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pbnRlcnNlY3RzICYmIHJlc3VsdC5pbnRlcnNlY3Rpb25Qb2ludHMpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50cy5wdXNoKC4uLnJlc3VsdC5pbnRlcnNlY3Rpb25Qb2ludHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIGVpdGhlciBzaGFwZSdzIGNlbnRlciBpcyBpbnNpZGUgdGhlIG90aGVyIGFuZCB0aGVyZSBhcmUgbm9cbiAgICAvLyBpbnRlcnNlY3Rpb24gcG9pbnRzLCBvbmUgc2hhcGUgY29tcGxldGVseSBlbmNsb3NlcyB0aGUgb3RoZXJcbiAgICBpZiAoKGNpcmNsZUNlbnRlckluc2lkZVBvbHlnb24gfHwgcG9seWdvbkNlbnRlckluc2lkZUNpcmNsZSkgJiZcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiB0cnVlIH07XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgIGludGVyc2VjdGlvblBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW50ZXJzZWN0czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAsXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50czogaW50ZXJzZWN0aW9uUG9pbnRzLmxlbmd0aCA+IDAgPyBpbnRlcnNlY3Rpb25Qb2ludHMgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjaXJjbGUgaW50ZXJzZWN0cyBhIHBvbHlnb25cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgdGhlIHBvbHlnb24gaXMgaW52YWxpZFxuICovXG5mdW5jdGlvbiBjaXJjbGVJbnRlcnNlY3RzUG9seWdvbihjaXJjbGUsIHBvbHlnb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgcG9seWdvbiBpcyB2YWxpZFxuICAgIGlmICghcG9seWdvbklzVmFsaWQocG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IE1BWF9JVEVSQVRJT05TID0gMTA7XG4gICAgY29uc3QgZmluZE1pbmltdW1TZXBhcmF0aW9uID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbmRNaW5pbXVtU2VwYXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgY2lyY2xlJ3MgY2VudGVyIGlzIGluc2lkZSBwb2x5Z29uXG4gICAgY29uc3QgcG9pbnRJblBvbHlnb25SZXN1bHQgPSBwb2ludEluUG9seWdvbihjaXJjbGUucG9zaXRpb24sIHBvbHlnb24pO1xuICAgIGNvbnN0IGNpcmNsZUNlbnRlckluc2lkZVBvbHlnb24gPSAoX2IgPSBwb2ludEluUG9seWdvblJlc3VsdCA9PT0gbnVsbCB8fCBwb2ludEluUG9seWdvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRJblBvbHlnb25SZXN1bHQuaW50ZXJzZWN0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgLy8gSWYgcG9seWdvbiBpcyBub3QgY29udmV4LCBkZWNvbXBvc2UgaXQgaW50byBjb252ZXggcG9seWdvbnNcbiAgICBpZiAoIXBvbHlnb25Jc0NvbnZleChwb2x5Z29uKSkge1xuICAgICAgICBjb25zdCBjb252ZXhQb2x5Z29ucyA9IGRlY29tcG9zZVBvbHlnb24ocG9seWdvbik7XG4gICAgICAgIGlmICghY29udmV4UG9seWdvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBhIGNvbmNhdmUgcG9seWdvbiwgdGhlIGNlbnRyb2lkIG1pZ2h0IGJlIG91dHNpZGUgb2YgdGhlIHBvbHlnb24sIHNvXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBwb2x5Z29uIGlzIGVudGlyZWx5IGluc2lkZSB0aGUgY2lyY2xlLCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIGlmIGFsbCBzdWItcG9seWdvbiBjZW50cm9pZHMgYXJlIGluc2lkZSB0aGUgY2lyY2xlXG4gICAgICAgIGNvbnN0IHBvbHlnb25DZW50ZXJJbnNpZGVDaXJjbGUgPSBjb252ZXhQb2x5Z29ucy5ldmVyeShjb252ZXhQb2x5Z29uID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRyb2lkID0gcG9seWdvbkNlbnRyb2lkKGNvbnZleFBvbHlnb24pO1xuICAgICAgICAgICAgaWYgKCFjZW50cm9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBjZW50cm9pZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHBvaW50SW5DaXJjbGUoY2VudHJvaWQsIGNpcmNsZSkuaW50ZXJzZWN0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBGaW5kIG91dGVyIGVkZ2VzIGZyb20gdGhlIGRlY29tcG9zZWQgcG9seWdvbnNcbiAgICAgICAgY29uc3Qgb3V0ZXJFZGdlcyA9IGZpbmRPdXRlckVkZ2VzKGNvbnZleFBvbHlnb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2lyY2xlSW50ZXJzZWN0c1ZhbGlkQ29udmV4UG9seWdvbkVkZ2VzKGNpcmNsZSwgb3V0ZXJFZGdlcywgY2lyY2xlQ2VudGVySW5zaWRlUG9seWdvbiwgcG9seWdvbkNlbnRlckluc2lkZUNpcmNsZSk7XG4gICAgICAgIGlmIChyZXN1bHQuaW50ZXJzZWN0cyAmJiBmaW5kTWluaW11bVNlcGFyYXRpb24pIHtcbiAgICAgICAgICAgIGxldCBpdGVyYXRpb24gPSAwO1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzU2VwYXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlcGFyYXRpb24gPSAoMCwgdmVjXzEudmVjMikoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U2VwYXJhdGlvbkludGVyc2VjdHMgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgLy8gQ29udGludWUgaWYgd2Ugc3RpbGwgaGF2ZW4ndCBmb3VuZCBhIHNlcGFyYXRpb24gdGhhdCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAgIGN1cnJlbnRTZXBhcmF0aW9uSW50ZXJzZWN0cyAmJlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGlmIHdlJ3JlIHN0aWxsIGNvbnZlcmdpbmcgKGkuZS4gaWYgd2UgZGlkbid0IG1ha2UgYW55XG4gICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgaW4gdGhlIGxhc3QgaXRlcmF0aW9uIHRoZW4gd2UgY2FuIHN0b3ApXG4gICAgICAgICAgICAgICAgKHByZXZpb3VzU2VwYXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAhKDAsIHV0aWxpdGllc18xLnZlY3RvcnNBbG1vc3RFcXVhbCkocHJldmlvdXNTZXBhcmF0aW9uLCBjdXJyZW50U2VwYXJhdGlvbikpICYmXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgdW50aWwgd2UgcmVhY2ggdGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICArK2l0ZXJhdGlvbiA8IE1BWF9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pbmltdW1TZXBhcmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjaXJjbGVQb3NpdGlvbiA9IHZlY18xLnZlYzIuYWRkKGNpcmNsZS5wb3NpdGlvbiwgY3VycmVudFNlcGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgbWluaW11bSBzZXBhcmF0aW9uIHZlY3RvcnMgZm9yIGVhY2ggY29udmV4IHN1Yi1wb2x5Z29uXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb252ZXhQb2x5Z29uIG9mIGNvbnZleFBvbHlnb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0ID0gcG9pbnRJblBvbHlnb24oY2lyY2xlUG9zaXRpb24sIGNvbnZleFBvbHlnb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWluaW11bVNlcGFyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwb2ludEluQ29udmV4UG9seWdvblJlc3VsdC5kaXN0YW5jZSkgPCBjb25zdGFudHMuRVBTSUxPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb24gPSAoMCwgdmVjXzEudmVjMikoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludEluQ29udmV4UG9seWdvblJlc3VsdC5kaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIocG9pbnRJbkNvbnZleFBvbHlnb25SZXN1bHQuY2xvc2VzdFBvaW50LCBjaXJjbGVQb3NpdGlvbikpLCBjaXJjbGUucmFkaXVzICsgTWF0aC5hYnMocG9pbnRJbkNvbnZleFBvbHlnb25SZXN1bHQuZGlzdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gdmVjXzEudmVjMi5tdWwodmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5zdWIoY2lyY2xlUG9zaXRpb24sIHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0LmNsb3Nlc3RQb2ludCkpLCBjaXJjbGUucmFkaXVzIC0gcG9pbnRJbkNvbnZleFBvbHlnb25SZXN1bHQuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRpb246IG1pbmltdW1TZXBhcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IE1hdGguYWJzKHBvaW50SW5Db252ZXhQb2x5Z29uUmVzdWx0LmRpc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNvcnQgbWluaW11bSBzZXBhcmF0aW9ucyBieSBwZW5ldHJhdGlvbiBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9ucyA9IG1pbmltdW1TZXBhcmF0aW9ucy5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZXBhcmF0aW9uID0gdmVjXzEudmVjMi5jcHkoY3VycmVudFNlcGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXBhcmF0aW9uID0gdmVjXzEudmVjMi5hZGQoY3VycmVudFNlcGFyYXRpb24sICgoX2MgPSBtaW5pbXVtU2VwYXJhdGlvbnNbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXBhcmF0aW9uKSB8fCAoMCwgdmVjXzEudmVjMikoKSk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgc2VwYXJhdGlvbiBzdGlsbCBpbnRlcnNlY3RzXG4gICAgICAgICAgICAgICAgY3VycmVudFNlcGFyYXRpb25JbnRlcnNlY3RzID1cbiAgICAgICAgICAgICAgICAgICAgKF9lID0gKF9kID0gY2lyY2xlSW50ZXJzZWN0c1BvbHlnb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2lyY2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHZlY18xLnZlYzIuYWRkKGNpcmNsZS5wb3NpdGlvbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBzbWFsbCBidWZmZXIgdG8gYXZvaWQgbnVtZXJpY2FsL3ByZWNpc2lvbiBpc3N1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlY18xLnZlYzIubXVsKGN1cnJlbnRTZXBhcmF0aW9uLCAxLjAxKSksXG4gICAgICAgICAgICAgICAgICAgIH0sIHBvbHlnb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZWN1cnNlIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5kTWluaW11bVNlcGFyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmludGVyc2VjdHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb246IGN1cnJlbnRTZXBhcmF0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBwb2x5Z29uJ3MgY2VudHJvaWQgaXMgaW5zaWRlIGNpcmNsZVxuICAgIC8vIEZvciBhIGNvbnZleCBwb2x5Z29uLCB0aGUgY2VudHJvaWQgaXMgYWx3YXlzIGluc2lkZSB0aGUgcG9seWdvblxuICAgIGNvbnN0IHBvbHlnb25DZW50ZXIgPSBwb2x5Z29uQ2VudHJvaWQocG9seWdvbik7XG4gICAgY29uc3QgcG9pbnRJbkNpcmNsZVJlc3VsdCA9IHBvaW50SW5DaXJjbGUocG9seWdvbkNlbnRlciwgY2lyY2xlKTtcbiAgICBjb25zdCBwb2x5Z29uQ2VudGVySW5zaWRlQ2lyY2xlID0gKF9mID0gcG9pbnRJbkNpcmNsZVJlc3VsdC5pbnRlcnNlY3RzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcbiAgICAvLyBGb3IgY29udmV4IHBvbHlnb25zLCBjaGVjayBlYWNoIGVkZ2UgZGlyZWN0bHlcbiAgICBjb25zdCBlZGdlcyA9IHZlcnRpY2VzVG9FZGdlcyhwb2x5Z29uLnZlcnRpY2VzKTtcbiAgICBjb25zdCByZXN1bHQgPSBjaXJjbGVJbnRlcnNlY3RzVmFsaWRDb252ZXhQb2x5Z29uRWRnZXMoY2lyY2xlLCBlZGdlcywgY2lyY2xlQ2VudGVySW5zaWRlUG9seWdvbiwgcG9seWdvbkNlbnRlckluc2lkZUNpcmNsZSk7XG4gICAgaWYgKHJlc3VsdC5pbnRlcnNlY3RzICYmIGZpbmRNaW5pbXVtU2VwYXJhdGlvbikge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG1pbmltdW0gc2VwYXJhdGlvbiB2ZWN0b3JcbiAgICAgICAgbGV0IG1pbmltdW1TZXBhcmF0aW9uO1xuICAgICAgICBpZiAoTWF0aC5hYnMocG9pbnRJblBvbHlnb25SZXN1bHQuZGlzdGFuY2UpIDwgY29uc3RhbnRzLkVQU0lMT04pIHtcbiAgICAgICAgICAgIG1pbmltdW1TZXBhcmF0aW9uID0gKDAsIHZlY18xLnZlYzIpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9pbnRJblBvbHlnb25SZXN1bHQuZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKHZlY18xLnZlYzIubm9yKHZlY18xLnZlYzIuc3ViKHBvaW50SW5Qb2x5Z29uUmVzdWx0LmNsb3Nlc3RQb2ludCwgY2lyY2xlLnBvc2l0aW9uKSksIGNpcmNsZS5yYWRpdXMgKyBNYXRoLmFicyhwb2ludEluUG9seWdvblJlc3VsdC5kaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWluaW11bVNlcGFyYXRpb24gPSB2ZWNfMS52ZWMyLm11bCh2ZWNfMS52ZWMyLm5vcih2ZWNfMS52ZWMyLnN1YihjaXJjbGUucG9zaXRpb24sIHBvaW50SW5Qb2x5Z29uUmVzdWx0LmNsb3Nlc3RQb2ludCkpLCBjaXJjbGUucmFkaXVzIC0gcG9pbnRJblBvbHlnb25SZXN1bHQuZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUHJvamVjdCB2ZXJ0aWNlcyBvbnRvIGFuIGF4aXMgYW5kIHJldHVybiB0aGUgbWluL21heCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gcHJvamVjdFZlcnRpY2VzVG9BeGlzKHZlcnRpY2VzLCBheGlzKSB7XG4gICAgbGV0IG1pbiA9IEluZmluaXR5O1xuICAgIGxldCBtYXggPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgdmVydGljZXMpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHZlY18xLnZlYzIuZG90KHZlcnRleCwgYXhpcyk7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcHJvamVjdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byByZWN0YW5nbGVzIGludGVyc2VjdFxuICovXG5mdW5jdGlvbiByZWN0YW5nbGVJbnRlcnNlY3RzUmVjdGFuZ2xlKHJlY3RhbmdsZUEsIHJlY3RhbmdsZUIpIHtcbiAgICAvLyBFZGdlIGNhc2U6IGlmIGVpdGhlciByZWN0YW5nbGUgaGFzIHplcm8gc2l6ZSwgdGhleSBjYW5ub3QgaW50ZXJzZWN0XG4gICAgaWYgKCgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShyZWN0YW5nbGVBLnNpemUpIHx8ICgwLCB1dGlsaXRpZXNfMS52ZWN0b3JBbG1vc3RaZXJvKShyZWN0YW5nbGVCLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIEdldCB2ZXJ0aWNlcyBvZiBib3RoIHJlY3RhbmdsZXNcbiAgICBjb25zdCB2ZXJ0aWNlc0EgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGVBKTtcbiAgICBjb25zdCB2ZXJ0aWNlc0IgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGVCKTtcbiAgICAvLyBHZXQgZWRnZXMgb2YgYm90aCByZWN0YW5nbGVzXG4gICAgY29uc3QgZWRnZXNBID0gdmVydGljZXNUb0VkZ2VzKHZlcnRpY2VzQSk7XG4gICAgY29uc3QgZWRnZXNCID0gdmVydGljZXNUb0VkZ2VzKHZlcnRpY2VzQik7XG4gICAgLy8gR2V0IHNlcGFyYXRpbmcgYXhlcyBieSBjYWxjdWxhdGluZyB0aGUgbm9ybWFscyBvZiBlYWNoIGVkZ2VcbiAgICBjb25zdCBheGVzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIFsuLi5lZGdlc0EsIC4uLmVkZ2VzQl0pIHtcbiAgICAgICAgY29uc3QgZWRnZVZlYyA9IHZlY18xLnZlYzIuc3ViKGVkZ2UuZW5kLCBlZGdlLnN0YXJ0KTtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gdmVjXzEudmVjMi5ub3IodmVjXzEudmVjMi5yb3RmKGVkZ2VWZWMsIC0xKSk7XG4gICAgICAgIC8vIE9ubHkgYWRkIHVuaXF1ZSBheGVzXG4gICAgICAgIGlmICghYXhlcy5zb21lKGF4aXMgPT4gTWF0aC5hYnModmVjXzEudmVjMi5kb3QoYXhpcywgbm9ybWFsKSkgPiAxIC0gY29uc3RhbnRzLkVQU0lMT04pKSB7XG4gICAgICAgICAgICBheGVzLnB1c2gobm9ybWFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcmFjayBtaW5pbXVtIHBlbmV0cmF0aW9uIGZvciBzZXBhcmF0aW9uIHZlY3RvclxuICAgIGxldCBtaW5QZW5ldHJhdGlvbiA9IEluZmluaXR5O1xuICAgIGxldCBtaW5BeGlzID0gKDAsIHZlY18xLnZlYzIpKCk7XG4gICAgLy8gVGVzdCBlYWNoIGF4aXNcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgICAvLyBQcm9qZWN0IGJvdGggcmVjdGFuZ2xlcyBvbnRvIHRoZSBheGlzXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25BID0gcHJvamVjdFZlcnRpY2VzVG9BeGlzKHZlcnRpY2VzQSwgYXhpcyk7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25CID0gcHJvamVjdFZlcnRpY2VzVG9BeGlzKHZlcnRpY2VzQiwgYXhpcyk7XG4gICAgICAgIC8vIElmIHdlIGZpbmQgYSBzZXBhcmF0aW5nIGF4aXMsIHRoZSByZWN0YW5nbGVzIGRvbid0IGludGVyc2VjdFxuICAgICAgICBpZiAocHJvamVjdGlvbkEubWF4IDwgcHJvamVjdGlvbkIubWluIHx8XG4gICAgICAgICAgICBwcm9qZWN0aW9uQi5tYXggPCBwcm9qZWN0aW9uQS5taW4pIHtcbiAgICAgICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBlbmV0cmF0aW9uIGRlcHRoXG4gICAgICAgIGNvbnN0IG92ZXJsYXAgPSBNYXRoLm1pbihwcm9qZWN0aW9uQS5tYXggLSBwcm9qZWN0aW9uQi5taW4sIHByb2plY3Rpb25CLm1heCAtIHByb2plY3Rpb25BLm1pbik7XG4gICAgICAgIC8vIFRyYWNrIG1pbmltdW0gcGVuZXRyYXRpb24gYW5kIGl0cyBheGlzXG4gICAgICAgIGlmIChvdmVybGFwIDwgbWluUGVuZXRyYXRpb24pIHtcbiAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIG1pbkF4aXMgPSBheGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIHBvaW50cyBieSBjaGVja2luZyBlYWNoIGVkZ2Ugb2YgcmVjdGFuZ2xlIEEgYWdhaW5zdCBlYWNoXG4gICAgLy8gZWRnZSBvZiByZWN0YW5nbGUgQlxuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRnZUEgb2YgZWRnZXNBKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWRnZUIgb2YgZWRnZXNCKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0c0xpbmUoZWRnZUEsIGVkZ2VCKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0cyAmJiBpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHMucHVzaChpbnRlcnNlY3Rpb24uaW50ZXJzZWN0aW9uUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgIGNvbnN0IHVuaXF1ZVBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZVZlcnRpY2VzKGludGVyc2VjdGlvblBvaW50cyk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIHNlcGFyYXRpb24gdmVjdG9yXG4gICAgY29uc3QgY2VudGVyQSA9IHJlY3RhbmdsZUEucG9zaXRpb247XG4gICAgY29uc3QgY2VudGVyQiA9IHJlY3RhbmdsZUIucG9zaXRpb247XG4gICAgY29uc3QgY2VudGVyVG9DZW50ZXIgPSB2ZWNfMS52ZWMyLnN1YihjZW50ZXJCLCBjZW50ZXJBKTtcbiAgICAvLyBJZiB0aGUgZG90IHByb2R1Y3QgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gZmxpcCB0aGUgYXhpc1xuICAgIGlmICh2ZWNfMS52ZWMyLmRvdChtaW5BeGlzLCBjZW50ZXJUb0NlbnRlcikgPCAwKSB7XG4gICAgICAgIG1pbkF4aXMgPSB2ZWNfMS52ZWMyLm11bChtaW5BeGlzLCAtMSk7XG4gICAgfVxuICAgIC8vIFRoZSBtaW5pbXVtIHNlcGFyYXRpb24gdmVjdG9yIGlzIHRoZSBheGlzIHNjYWxlZCBieSB0aGUgcGVuZXRyYXRpb24gZGVwdGhcbiAgICBjb25zdCBtaW5pbXVtU2VwYXJhdGlvbiA9IHZlY18xLnZlYzIubXVsKG1pbkF4aXMsIG1pblBlbmV0cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB0cnVlLFxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludHM6IHVuaXF1ZVBvaW50cy5sZW5ndGggPiAwID8gdW5pcXVlUG9pbnRzIDogdW5kZWZpbmVkLFxuICAgICAgICBtaW5pbXVtU2VwYXJhdGlvbixcbiAgICB9O1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHJlY3RhbmdsZSBpbnRlcnNlY3RzIGEgcG9seWdvblxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB0aGUgcG9seWdvbiBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHJlY3RhbmdsZUludGVyc2VjdHNQb2x5Z29uKHJlY3RhbmdsZSwgcG9seWdvbikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBwb2x5Z29uIGlzIHZhbGlkXG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRWRnZSBjYXNlOiBpZiB0aGUgcmVjdGFuZ2xlIGhhcyB6ZXJvIHNpemUsIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvblxuICAgIGlmICgoMCwgdXRpbGl0aWVzXzEudmVjdG9yQWxtb3N0WmVybykocmVjdGFuZ2xlLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB7IGludGVyc2VjdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIC8vIENvbnZlcnQgcmVjdGFuZ2xlIHRvIHBvbHlnb25cbiAgICBjb25zdCByZWN0VmVydGljZXMgPSByZWN0YW5nbGVWZXJ0aWNlcyhyZWN0YW5nbGUpO1xuICAgIGNvbnN0IHJlY3RQb2x5Z29uID0ge1xuICAgICAgICB2ZXJ0aWNlczogcmVjdFZlcnRpY2VzLFxuICAgIH07XG4gICAgLy8gVXNlIHBvbHlnb24gaW50ZXJzZWN0aW9uIGFsZ29yaXRobVxuICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0c1BvbHlnb24ocmVjdFBvbHlnb24sIHBvbHlnb24pO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gcG9seWdvbnMgaW50ZXJzZWN0XG4gKlxuICogUmV0dXJucyBudWxsIGlmIGVpdGhlciBwb2x5Z29uIGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdHNQb2x5Z29uKHBvbHlnb25BLCBwb2x5Z29uQikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGJvdGggcG9seWdvbnMgYXJlIHZhbGlkXG4gICAgaWYgKCFwb2x5Z29uSXNWYWxpZChwb2x5Z29uQSkgfHwgIXBvbHlnb25Jc1ZhbGlkKHBvbHlnb25CKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRGVjb21wb3NlIHBvbHlnb24gQSBpZiBpdCdzIGNvbmNhdmVcbiAgICBsZXQgY29udmV4UG9seWdvbnNBID0gW107XG4gICAgaWYgKCFwb2x5Z29uSXNDb252ZXgocG9seWdvbkEpKSB7XG4gICAgICAgIGNvbnN0IGRlY29tcG9zZWRBID0gZGVjb21wb3NlUG9seWdvbihwb2x5Z29uQSk7XG4gICAgICAgIGlmICghZGVjb21wb3NlZEEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZleFBvbHlnb25zQSA9IGRlY29tcG9zZWRBO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udmV4UG9seWdvbnNBID0gW3BvbHlnb25BXTtcbiAgICB9XG4gICAgLy8gRGVjb21wb3NlIHBvbHlnb24gQiBpZiBpdCdzIGNvbmNhdmVcbiAgICBsZXQgY29udmV4UG9seWdvbnNCID0gW107XG4gICAgaWYgKCFwb2x5Z29uSXNDb252ZXgocG9seWdvbkIpKSB7XG4gICAgICAgIGNvbnN0IGRlY29tcG9zZWRCID0gZGVjb21wb3NlUG9seWdvbihwb2x5Z29uQik7XG4gICAgICAgIGlmICghZGVjb21wb3NlZEIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZleFBvbHlnb25zQiA9IGRlY29tcG9zZWRCO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udmV4UG9seWdvbnNCID0gW3BvbHlnb25CXTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBvdXRlciBlZGdlcyBvZiB0aGUgZGVjb21wb3NlZCBwb2x5Z29uc1xuICAgIGNvbnN0IG91dGVyRWRnZXNBID0gZmluZE91dGVyRWRnZXMoY29udmV4UG9seWdvbnNBKTtcbiAgICBjb25zdCBvdXRlckVkZ2VzQiA9IGZpbmRPdXRlckVkZ2VzKGNvbnZleFBvbHlnb25zQik7XG4gICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gcG9pbnRzIGJldHdlZW4gb3V0ZXIgZWRnZXMgb25seVxuICAgIGNvbnN0IGludGVyc2VjdGlvblBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRnZUEgb2Ygb3V0ZXJFZGdlc0EpIHtcbiAgICAgICAgZm9yIChjb25zdCBlZGdlQiBvZiBvdXRlckVkZ2VzQikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdHNMaW5lKGVkZ2VBLCBlZGdlQik7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLmludGVyc2VjdHMgJiYgaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLnB1c2goaW50ZXJzZWN0aW9uLmludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBpZiBvbmUgcG9seWdvbiBpcyBjb250YWluZWQgd2l0aGluIHRoZSBvdGhlclxuICAgIC8vIEEgcG9seWdvbiBpcyBjb250YWluZWQgd2l0aGluIGFub3RoZXIgaWYgdGhlIGNlbnRyb2lkcyBvZiBhbGwgaXRzXG4gICAgLy8gY29udmV4IHN1Yi1wb2x5Z29ucyBhcmUgaW5zaWRlIHRoZSBvdGhlciBwb2x5Z29uXG4gICAgaWYgKGludGVyc2VjdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgcG9seWdvbkFDZW50cm9pZHMgPSBjb252ZXhQb2x5Z29uc0FcbiAgICAgICAgICAgIC5tYXAocG9seWdvbkNlbnRyb2lkKVxuICAgICAgICAgICAgLmZpbHRlcihjZW50cm9pZCA9PiAhIWNlbnRyb2lkKTtcbiAgICAgICAgaWYgKHBvbHlnb25BQ2VudHJvaWRzLmV2ZXJ5KGNlbnRyb2lkID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcG9pbnRJblBvbHlnb24oY2VudHJvaWQsIHBvbHlnb25CKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmludGVyc2VjdHM7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9seWdvbkJDZW50cm9pZHMgPSBjb252ZXhQb2x5Z29uc0JcbiAgICAgICAgICAgIC5tYXAocG9seWdvbkNlbnRyb2lkKVxuICAgICAgICAgICAgLmZpbHRlcihjZW50cm9pZCA9PiAhIWNlbnRyb2lkKTtcbiAgICAgICAgaWYgKHBvbHlnb25CQ2VudHJvaWRzLmV2ZXJ5KGNlbnRyb2lkID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcG9pbnRJblBvbHlnb24oY2VudHJvaWQsIHBvbHlnb25BKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmludGVyc2VjdHM7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnRlcnNlY3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgY29uc3QgdW5pcXVlUG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlVmVydGljZXMoaW50ZXJzZWN0aW9uUG9pbnRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnRlcnNlY3RzOiB1bmlxdWVQb2ludHMubGVuZ3RoID4gMCxcbiAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzOiB1bmlxdWVQb2ludHMubGVuZ3RoID4gMCA/IHVuaXF1ZVBvaW50cyA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjLzJkL3R5cGVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjLzJkL3R5cGVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuZXhwb3J0cy5pc1JheSA9IGlzUmF5O1xuZXhwb3J0cy5pc0xpbmUgPSBpc0xpbmU7XG5leHBvcnRzLmlzQ2lyY2xlID0gaXNDaXJjbGU7XG5leHBvcnRzLmlzQUFCQiA9IGlzQUFCQjtcbmV4cG9ydHMuaXNSZWN0YW5nbGUgPSBpc1JlY3RhbmdsZTtcbmV4cG9ydHMuaXNQb2x5Z29uID0gaXNQb2x5Z29uO1xuY29uc3QgdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxpdGllcy90eXBlcyAqLyBcIi4vc3JjL3V0aWxpdGllcy90eXBlcy50c1wiKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGEgUG9pbnRcbiAqL1xuZnVuY3Rpb24gaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgdHlwZXNfMS5pc1ZlYzIpKHZhbHVlKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFJheVxuICovXG5mdW5jdGlvbiBpc1JheSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnb3JpZ2luJyBpbiB2YWx1ZSAmJlxuICAgICAgICBpc1BvaW50KHZhbHVlLm9yaWdpbikgJiZcbiAgICAgICAgJ2RpcmVjdGlvbicgaW4gdmFsdWUgJiZcbiAgICAgICAgKDAsIHR5cGVzXzEuaXNWZWMyKSh2YWx1ZS5kaXJlY3Rpb24pKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIExpbmVcbiAqL1xuZnVuY3Rpb24gaXNMaW5lKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdzdGFydCcgaW4gdmFsdWUgJiZcbiAgICAgICAgaXNQb2ludCh2YWx1ZS5zdGFydCkgJiZcbiAgICAgICAgJ2VuZCcgaW4gdmFsdWUgJiZcbiAgICAgICAgaXNQb2ludCh2YWx1ZS5lbmQpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIENpcmNsZVxuICovXG5mdW5jdGlvbiBpc0NpcmNsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncG9zaXRpb24nIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUucG9zaXRpb24pICYmXG4gICAgICAgICdyYWRpdXMnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5yYWRpdXMgPT09ICdudW1iZXInKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBBQUJCXG4gKi9cbmZ1bmN0aW9uIGlzQUFCQih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncG9zaXRpb24nIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUucG9zaXRpb24pICYmXG4gICAgICAgICdzaXplJyBpbiB2YWx1ZSAmJlxuICAgICAgICAoMCwgdHlwZXNfMS5pc1ZlYzIpKHZhbHVlLnNpemUpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFJlY3RhbmdsZVxuICovXG5mdW5jdGlvbiBpc1JlY3RhbmdsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncG9zaXRpb24nIGluIHZhbHVlICYmXG4gICAgICAgIGlzUG9pbnQodmFsdWUucG9zaXRpb24pICYmXG4gICAgICAgICdzaXplJyBpbiB2YWx1ZSAmJlxuICAgICAgICAoMCwgdHlwZXNfMS5pc1ZlYzIpKHZhbHVlLnNpemUpICYmXG4gICAgICAgICgncm90YXRpb24nIGluIHZhbHVlID8gdHlwZW9mIHZhbHVlLnJvdGF0aW9uID09PSAnbnVtYmVyJyA6IHRydWUpKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFBvbHlnb25cbiAqL1xuZnVuY3Rpb24gaXNQb2x5Z29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2ZXJ0aWNlcycgaW4gdmFsdWUgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZS52ZXJ0aWNlcykgJiZcbiAgICAgICAgdmFsdWUudmVydGljZXMuZXZlcnkoaXNQb2ludCkpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWxpdGllcy9jb25zdGFudHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsaXRpZXMvY29uc3RhbnRzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRVBTSUxPTiA9IHZvaWQgMDtcbmV4cG9ydHMuRVBTSUxPTiA9IDFlLTY7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbGl0aWVzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsaXRpZXMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMudmVjdG9yQWxtb3N0WmVybyA9IHZlY3RvckFsbW9zdFplcm87XG5leHBvcnRzLnZlY3RvcnNBbG1vc3RFcXVhbCA9IHZlY3RvcnNBbG1vc3RFcXVhbDtcbmV4cG9ydHMudmFsdWVJbkludGVydmFsID0gdmFsdWVJbkludGVydmFsO1xuZXhwb3J0cy5pbnRlcnZhbHNPdmVybGFwID0gaW50ZXJ2YWxzT3ZlcmxhcDtcbmV4cG9ydHMub3ZlcmxhcEludGVydmFsID0gb3ZlcmxhcEludGVydmFsO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzICovIFwiLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50c1wiKSk7XG5jb25zdCB0eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcyAqLyBcIi4vc3JjL3V0aWxpdGllcy90eXBlcy50c1wiKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvdXRpbGl0aWVzL3R5cGVzLnRzXCIpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIHZlY3RvckFsbW9zdFplcm8odikge1xuICAgIGlmICgoMCwgdHlwZXNfMS5pc1ZlYzMpKHYpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnModi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyh2LnkpIDwgY29uc3RhbnRzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHYueikgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc1ZlYzIpKHYpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnModi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmIE1hdGguYWJzKHYueSkgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZlY3RvcnNBbG1vc3RFcXVhbChhLCBiKSB7XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzVmVjMykoYSkgJiYgKDAsIHR5cGVzXzEuaXNWZWMzKShiKSkge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGEueCAtIGIueCkgPCBjb25zdGFudHMuRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYS55IC0gYi55KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnogLSBiLnopIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNWZWMyKShhKSAmJiAoMCwgdHlwZXNfMS5pc1ZlYzIpKGIpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoYS54IC0gYi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnkgLSBiLnkpIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgd2l0aGluIGEgc3BlY2lmaWVkIGludGVydmFsXG4gKi9cbmZ1bmN0aW9uIHZhbHVlSW5JbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcbiAgICBjb25zdCB7IG1pbiwgbWluSW5jbHVzaXZlID0gdHJ1ZSwgbWF4LCBtYXhJbmNsdXNpdmUgPSB0cnVlIH0gPSBpbnRlcnZhbDtcbiAgICByZXR1cm4gKChtaW5JbmNsdXNpdmUgPyB2YWx1ZSA+PSBtaW4gOiB2YWx1ZSA+IG1pbikgJiZcbiAgICAgICAgKG1heEluY2x1c2l2ZSA/IHZhbHVlIDw9IG1heCA6IHZhbHVlIDwgbWF4KSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBpbnRlcnZhbHMgKGExLCBhMikgYW5kIChiMSwgYjIpIG92ZXJsYXBcbiAqL1xuZnVuY3Rpb24gaW50ZXJ2YWxzT3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGEubWluLCBiLm1pbikgPD0gTWF0aC5taW4oYS5tYXgsIGIubWF4KTtcbn1cbi8qKlxuICogR2V0IHRoZSBvdmVybGFwcGluZyBwYXJ0IG9mIHR3byBpbnRlcnZhbHMgKGExLCBhMikgYW5kIChiMSwgYjIpXG4gKlxuICogSWYgdGhlIGludGVydmFscyBkbyBub3Qgb3ZlcmxhcCwgcmV0dXJuIG51bGxcbiAqL1xuZnVuY3Rpb24gb3ZlcmxhcEludGVydmFsKGEsIGIpIHtcbiAgICBpZiAoIWludGVydmFsc092ZXJsYXAoYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogTWF0aC5tYXgoYS5taW4sIGIubWluKSwgbWF4OiBNYXRoLm1pbihhLm1heCwgYi5tYXgpIH07XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbGl0aWVzL3R5cGVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsaXRpZXMvdHlwZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmlzVmVjMiA9IGlzVmVjMjtcbmV4cG9ydHMuaXNWZWMzID0gaXNWZWMzO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdmVjMlxuICovXG5mdW5jdGlvbiBpc1ZlYzIodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3gnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS54ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAneScgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnkgPT09ICdudW1iZXInICYmXG4gICAgICAgICEoJ3onIGluIHZhbHVlKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2ZWMzXG4gKi9cbmZ1bmN0aW9uIGlzVmVjMyh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAneCcgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnggPT09ICdudW1iZXInICYmXG4gICAgICAgICd5JyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUueSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgJ3onIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS56ID09PSAnbnVtYmVyJyk7XG59XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjLzJkL2luZGV4LnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL3NyYy91dGlsaXRpZXMvY29uc3RhbnRzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FUFNJTE9OID0gdm9pZCAwO1xuZXhwb3J0cy5FUFNJTE9OID0gMWUtNjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsaXRpZXMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWxpdGllcy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMudmVjdG9yQWxtb3N0WmVybyA9IHZlY3RvckFsbW9zdFplcm87XG5leHBvcnRzLnZlY3RvcnNBbG1vc3RFcXVhbCA9IHZlY3RvcnNBbG1vc3RFcXVhbDtcbmV4cG9ydHMudmFsdWVJbkludGVydmFsID0gdmFsdWVJbkludGVydmFsO1xuZXhwb3J0cy5pbnRlcnZhbHNPdmVybGFwID0gaW50ZXJ2YWxzT3ZlcmxhcDtcbmV4cG9ydHMub3ZlcmxhcEludGVydmFsID0gb3ZlcmxhcEludGVydmFsO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnRzICovIFwiLi9zcmMvdXRpbGl0aWVzL2NvbnN0YW50cy50c1wiKSk7XG5jb25zdCB0eXBlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90eXBlcyAqLyBcIi4vc3JjL3V0aWxpdGllcy90eXBlcy50c1wiKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3R5cGVzICovIFwiLi9zcmMvdXRpbGl0aWVzL3R5cGVzLnRzXCIpLCBleHBvcnRzKTtcbmZ1bmN0aW9uIHZlY3RvckFsbW9zdFplcm8odikge1xuICAgIGlmICgoMCwgdHlwZXNfMS5pc1ZlYzMpKHYpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnModi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyh2LnkpIDwgY29uc3RhbnRzLkVQU0lMT04gJiZcbiAgICAgICAgICAgIE1hdGguYWJzKHYueikgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIGlmICgoMCwgdHlwZXNfMS5pc1ZlYzIpKHYpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnModi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmIE1hdGguYWJzKHYueSkgPCBjb25zdGFudHMuRVBTSUxPTik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHZlY3RvcnNBbG1vc3RFcXVhbChhLCBiKSB7XG4gICAgaWYgKCgwLCB0eXBlc18xLmlzVmVjMykoYSkgJiYgKDAsIHR5cGVzXzEuaXNWZWMzKShiKSkge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGEueCAtIGIueCkgPCBjb25zdGFudHMuRVBTSUxPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYS55IC0gYi55KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnogLSBiLnopIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgIH1cbiAgICBpZiAoKDAsIHR5cGVzXzEuaXNWZWMyKShhKSAmJiAoMCwgdHlwZXNfMS5pc1ZlYzIpKGIpKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hYnMoYS54IC0gYi54KSA8IGNvbnN0YW50cy5FUFNJTE9OICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhLnkgLSBiLnkpIDwgY29uc3RhbnRzLkVQU0lMT04pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgd2l0aGluIGEgc3BlY2lmaWVkIGludGVydmFsXG4gKi9cbmZ1bmN0aW9uIHZhbHVlSW5JbnRlcnZhbCh2YWx1ZSwgaW50ZXJ2YWwpIHtcbiAgICBjb25zdCB7IG1pbiwgbWluSW5jbHVzaXZlID0gdHJ1ZSwgbWF4LCBtYXhJbmNsdXNpdmUgPSB0cnVlIH0gPSBpbnRlcnZhbDtcbiAgICByZXR1cm4gKChtaW5JbmNsdXNpdmUgPyB2YWx1ZSA+PSBtaW4gOiB2YWx1ZSA+IG1pbikgJiZcbiAgICAgICAgKG1heEluY2x1c2l2ZSA/IHZhbHVlIDw9IG1heCA6IHZhbHVlIDwgbWF4KSk7XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBpbnRlcnZhbHMgKGExLCBhMikgYW5kIChiMSwgYjIpIG92ZXJsYXBcbiAqL1xuZnVuY3Rpb24gaW50ZXJ2YWxzT3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGEubWluLCBiLm1pbikgPD0gTWF0aC5taW4oYS5tYXgsIGIubWF4KTtcbn1cbi8qKlxuICogR2V0IHRoZSBvdmVybGFwcGluZyBwYXJ0IG9mIHR3byBpbnRlcnZhbHMgKGExLCBhMikgYW5kIChiMSwgYjIpXG4gKlxuICogSWYgdGhlIGludGVydmFscyBkbyBub3Qgb3ZlcmxhcCwgcmV0dXJuIG51bGxcbiAqL1xuZnVuY3Rpb24gb3ZlcmxhcEludGVydmFsKGEsIGIpIHtcbiAgICBpZiAoIWludGVydmFsc092ZXJsYXAoYSwgYikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IG1pbjogTWF0aC5tYXgoYS5taW4sIGIubWluKSwgbWF4OiBNYXRoLm1pbihhLm1heCwgYi5tYXgpIH07XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbGl0aWVzL3R5cGVzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsaXRpZXMvdHlwZXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5pc1ZlYzIgPSBpc1ZlYzI7XG5leHBvcnRzLmlzVmVjMyA9IGlzVmVjMztcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHZlYzJcbiAqL1xuZnVuY3Rpb24gaXNWZWMyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd4JyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUueCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgJ3knIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS55ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAhKCd6JyBpbiB2YWx1ZSkpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdmVjM1xuICovXG5mdW5jdGlvbiBpc1ZlYzModmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3gnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS54ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAneScgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnkgPT09ICdudW1iZXInICYmXG4gICAgICAgICd6JyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUueiA9PT0gJ251bWJlcicpO1xufVxuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy91dGlsaXRpZXMvaW5kZXgudHNcIik7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyIsIi8qXG4gKiBBVFRFTlRJT046IFRoZSBcImV2YWxcIiBkZXZ0b29sIGhhcyBiZWVuIHVzZWQgKG1heWJlIGJ5IGRlZmF1bHQgaW4gbW9kZTogXCJkZXZlbG9wbWVudFwiKS5cbiAqIFRoaXMgZGV2dG9vbCBpcyBuZWl0aGVyIG1hZGUgZm9yIHByb2R1Y3Rpb24gbm9yIGZvciByZWFkYWJsZSBvdXRwdXQgZmlsZXMuXG4gKiBJdCB1c2VzIFwiZXZhbCgpXCIgY2FsbHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgc291cmNlIGZpbGUgaW4gdGhlIGJyb3dzZXIgZGV2dG9vbHMuXG4gKiBJZiB5b3UgYXJlIHRyeWluZyB0byByZWFkIHRoZSBvdXRwdXQgZmlsZSwgc2VsZWN0IGEgZGlmZmVyZW50IGRldnRvb2wgKGh0dHBzOi8vd2VicGFjay5qcy5vcmcvY29uZmlndXJhdGlvbi9kZXZ0b29sLylcbiAqIG9yIGRpc2FibGUgdGhlIGRlZmF1bHQgZGV2dG9vbCB3aXRoIFwiZGV2dG9vbDogZmFsc2VcIi5cbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgcHJvZHVjdGlvbi1yZWFkeSBvdXRwdXQgZmlsZXMsIHNlZSBtb2RlOiBcInByb2R1Y3Rpb25cIiAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvKS5cbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuZXZhbChcIlxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcXG5leHBvcnRzLlNjZW5lID0gZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSA9IHZvaWQgMDtcXG52YXIgU2NlbmVUcmFuc2l0aW9uU3RhdGU7XFxuKGZ1bmN0aW9uIChTY2VuZVRyYW5zaXRpb25TdGF0ZSkge1xcbiAgICBTY2VuZVRyYW5zaXRpb25TdGF0ZVtcXFwiSW5cXFwiXSA9IFxcXCJpblxcXCI7XFxuICAgIFNjZW5lVHJhbnNpdGlvblN0YXRlW1xcXCJPdXRcXFwiXSA9IFxcXCJvdXRcXFwiO1xcbiAgICBTY2VuZVRyYW5zaXRpb25TdGF0ZVtcXFwiTm9uZVxcXCJdID0gXFxcIm5vbmVcXFwiO1xcbn0pKFNjZW5lVHJhbnNpdGlvblN0YXRlID0gZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSB8fCAoZXhwb3J0cy5TY2VuZVRyYW5zaXRpb25TdGF0ZSA9IHt9KSk7XFxuZnVuY3Rpb24gY2xhbXAoYSwgbWluID0gMCwgbWF4ID0gMSkge1xcbiAgICByZXR1cm4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XFxufVxcbmNsYXNzIFNjZW5lTWFuYWdlciB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgICAgdGhpcy5zY2VuZXMgPSBbXTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGlzZSB0aGUgc2NlbmUgbWFuYWdlciBmb3IgbWFuYWdpbmcgZ2FtZSBzY2VuZXNcXG4gICAgICovXFxuICAgIHN0YXRpYyBpbml0aWFsaXNlKCkge1xcbiAgICAgICAgaWYgKFNjZW5lTWFuYWdlci5pbnN0YW5jZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmVNYW5hZ2VyIGFscmVhZHkgaW5pdGlhbGlzZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFNjZW5lTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBTY2VuZU1hbmFnZXIoKTtcXG4gICAgfVxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XFxuICAgICAgICBpZiAoIVNjZW5lTWFuYWdlci5pbnN0YW5jZSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmVNYW5hZ2VyIG5vdCBwcm9wZXJseSBpbml0aWFsaXNlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFNjZW5lTWFuYWdlci5pbnN0YW5jZTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUHVzaCBhIHNjZW5lIG9udG8gdGhlIHNjZW5lIHN0YWNrIGFuZCBzdGFydCB0cmFuc2l0aW9uaW5nIGluXFxuICAgICAqL1xcbiAgICBzdGF0aWMgcHVzaChzY2VuZSwgLi4uYXJncykge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnNjZW5lcy5wdXNoKHNjZW5lKTtcXG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHNjZW5lIGFuZCBzdGFydCB0aGUgdHJhbnNpdGlvblxcbiAgICAgICAgc2NlbmUuaW5pdGlhbGlzZSguLi5hcmdzKTtcXG4gICAgICAgIHNjZW5lLnRyYW5zaXRpb25JbigpO1xcbiAgICAgICAgcmV0dXJuIHNjZW5lO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZW1vdmUgYSBzY2VuZSBmcm9tIHRoZSBzY2VuZSBzdGFjayBhZnRlciB0cmFuc2l0aW9uaW5nIG91dFxcbiAgICAgKi9cXG4gICAgc3RhdGljIHBvcCgpIHtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2NlbmVzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBsZXQgbGFzdCA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGggLSAxO1xcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG9wLW1vc3Qgc2NlbmUgdGhhdCBpc24ndCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgICAgICB3aGlsZSAobGFzdCA+IDAgJiZcXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzW2xhc3RdLnRyYW5zaXRpb25TdGF0ZSA9PT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0KSB7XFxuICAgICAgICAgICAgICAgIGxhc3QtLTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGxhc3QgPj0gMCkge1xcbiAgICAgICAgICAgICAgICBjb25zdCBzY2VuZSA9IGluc3RhbmNlLnNjZW5lc1tsYXN0XTtcXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvbk91dCgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NlbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVtb3ZlIGFsbCBzY2VuZSBmcm9tIHRoZSBzY2VuZSBzdGFja1xcbiAgICAgKi9cXG4gICAgc3RhdGljIGNsZWFyKCkge1xcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBTY2VuZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIGluc3RhbmNlLnNjZW5lcy5mb3JFYWNoKHNjZW5lID0+IHtcXG4gICAgICAgICAgICBpZiAoc2NlbmUudHJhbnNpdGlvblN0YXRlICE9PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5PdXQpIHtcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvbk91dCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBVcGRhdGUgdGhlIHNjZW5lIG1hbmFnZXIgYW5kIHRoZSBjdXJyZW50IHNjZW5lXFxuICAgICAqL1xcbiAgICBzdGF0aWMgdXBkYXRlKGR0LCAuLi5hcmdzKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgaWYgKGluc3RhbmNlLnNjZW5lcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHRvcC1tb3N0IHNjZW5lIHRoYXQgaXNuJ3QgY3VycmVudGx5IHRyYW5zaXRpb25pbmcgb3V0XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnNjZW5lc1tpXS50cmFuc2l0aW9uU3RhdGUgIT09IFNjZW5lVHJhbnNpdGlvblN0YXRlLk91dCkge1xcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzW2ldLnVwZGF0ZShkdCwgLi4uYXJncyk7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNjZW5lIHRyYW5zaXRpb25zXFxuICAgICAgICAgICAgaW5zdGFuY2Uuc2NlbmVzLmZvckVhY2goc2NlbmUgPT4ge1xcbiAgICAgICAgICAgICAgICBzY2VuZS51cGRhdGVUcmFuc2l0aW9uKGR0KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IGRpc3Bvc2VkIHNjZW5lc1xcbiAgICAgICAgICAgIGluc3RhbmNlLnNjZW5lcyA9IGluc3RhbmNlLnNjZW5lcy5maWx0ZXIoc2NlbmUgPT4gIXNjZW5lLmRpc3Bvc2VkKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmVuZGVyIHNjZW5lcyBvbiB0aGUgc2NyZWVuXFxuICAgICAqL1xcbiAgICBzdGF0aWMgZHJhdyhjb250ZXh0LCAuLi5hcmdzKSB7XFxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IFNjZW5lTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBzY2VuZXMgd2UgbmVlZCB0byBkcmF3XFxuICAgICAgICBjb25zdCBkcmF3TGlzdCA9IFtdO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IGluc3RhbmNlLnNjZW5lcy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IGluc3RhbmNlLnNjZW5lc1tpXTtcXG4gICAgICAgICAgICBkcmF3TGlzdC5wdXNoKHNjZW5lKTtcXG4gICAgICAgICAgICAvLyBJZiB0cmFuc2l0aW9uaW5nLCB0aGlzIHNjZW5lIGlzIGFzc3VtZWQgdG8gYmUgdHJhbnNwYXJlbnRcXG4gICAgICAgICAgICAvLyAod2UgbWlnaHQgd2FudCB0byBzaG93IHRoZSBzY2VuZSB1bmRlcm5lYXRoIGlmIHdlJ3JlIGRvaW5nIGUuZy4gYSBmYWRlKVxcbiAgICAgICAgICAgIGlmICghc2NlbmUudHJhbnNwYXJlbnQgJiZcXG4gICAgICAgICAgICAgICAgc2NlbmUudHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIERyYXcgdGhlIHNjZW5lcyBpbiBib3R0b20gLT4gdG9wIG9yZGVyXFxuICAgICAgICBkcmF3TGlzdC5yZXZlcnNlKCkuZm9yRWFjaChzY2VuZSA9PiB7XFxuICAgICAgICAgICAgc2NlbmUuZHJhdyhjb250ZXh0LCAuLi5hcmdzKTtcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBMZXQgYWxsIHNjZW5lcyBrbm93IHRoYXQgYSByZXNpemUgZXZlbnQgaGFzIG9jY3VycmVkXFxuICAgICAqL1xcbiAgICBzdGF0aWMgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgICAgIHZhciBfYTtcXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gU2NlbmVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxuICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIGluc3RhbmNlLnNjZW5lcykge1xcbiAgICAgICAgICAgIChfYSA9IHNjZW5lLnJlc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc2NlbmUsIHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IFNjZW5lTWFuYWdlcjtcXG5jbGFzcyBTY2VuZSB7XFxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWU6IDIsXFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RhdGUgPSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lO1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uQW1vdW50ID0gMDtcXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWUgPSAwO1xcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xcbiAgICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVGltZSA9IGFjdHVhbE9wdGlvbnMudHJhbnNpdGlvblRpbWU7XFxuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gYWN0dWFsT3B0aW9ucy50cmFuc3BhcmVudDtcXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uZWRJbiA9IGFjdHVhbE9wdGlvbnMub25UcmFuc2l0aW9uZWRJbjtcXG4gICAgICAgIHRoaXMub25UcmFuc2l0aW9uZWRPdXQgPSBhY3R1YWxPcHRpb25zLm9uVHJhbnNpdGlvbmVkT3V0O1xcbiAgICB9XFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICB0cmFuc2l0aW9uSW4oKSB7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLkluO1xcbiAgICB9XFxuICAgIHRyYW5zaXRpb25PdXQoKSB7XFxuICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLk91dDtcXG4gICAgfVxcbiAgICB1cGRhdGVUcmFuc2l0aW9uKGR0KSB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgY29uc3QgYW1vdW50ID0gZHQgLyB0aGlzLnRyYW5zaXRpb25UaW1lO1xcbiAgICAgICAgLy8gVHJhbnNpdGlvbmluZyBpblxcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblN0YXRlID09PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Jbikge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25BbW91bnQgPCAxKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkFtb3VudCA9IGNsYW1wKHRoaXMudHJhbnNpdGlvbkFtb3VudCArIGFtb3VudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSA9IFNjZW5lVHJhbnNpdGlvblN0YXRlLk5vbmU7XFxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMub25UcmFuc2l0aW9uZWRJbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gVHJhbnNpdGlvbmluZyBvdXRcXG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSA9PT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuT3V0KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbkFtb3VudCA+IDApIHtcXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQW1vdW50ID0gY2xhbXAodGhpcy50cmFuc2l0aW9uQW1vdW50IC0gYW1vdW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0YXRlID0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMub25UcmFuc2l0aW9uZWRPdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5leHBvcnRzLlNjZW5lID0gU2NlbmU7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlci8uL2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfbW9kdWxlc19fW1wiLi9pbmRleC50c1wiXSgwLCBfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7IiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBsaWJyYXJ5IG9mIHVzZWZ1bCBmdW5jdGlvbnNcbiAqIEBhdXRob3IgR29yZG9uIExhcnJpZ2FuXG4gKi9cblxuLyoqXG4gKiBNZW1vaXplIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvblxuICovXG5jb25zdCBtZW1vaXplID0gZiA9PiB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjYWNoZVthcmdzXSA/PyAoY2FjaGVbYXJnc10gPSBmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXIgYlxuICogQHBhcmFtIHtudW1iZXJ9IFtwPU51bWJlci5FUFNJTE9OXSBUaGUgcHJlY2lzaW9uIHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG51bWJlcnMgYSBhbmQgYiBhcmUgYXBwcm94aW1hdGVseSBlcXVhbFxuICovXG5jb25zdCBmbG9hdEVxdWFscyA9IChhLCBiLCBwID0gTnVtYmVyLkVQU0lMT04pID0+IE1hdGguYWJzKGEgLSBiKSA8IHA7XG5cbi8qKlxuICogQ2xhbXAgYSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBudW1iZXJcbiAqL1xuY29uc3QgY2xhbXAgPSAoYSwgbWluID0gMCwgbWF4ID0gMSkgPT4gYSA8IG1pbiA/IG1pbiA6IChhID4gbWF4ID8gbWF4IDogYSk7XG5cbi8qKlxuICogR2V0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBudW1iZXIgZnJvbSB3aGljaCB0byBnZXQgdGhlIGZyYWN0aW9uYWwgcGFydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSBudW1iZXJcbiAqL1xuY29uc3QgZnJhYyA9IGEgPT4gYSA+PSAwID8gYSAtIE1hdGguZmxvb3IoYSkgOiBhIC0gTWF0aC5jZWlsKGEpO1xuXG4vKipcbiAqIFJvdW5kIG4gdG8gZCBkZWNpbWFsIHBsYWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZFxuICogQHBhcmFtIHtudW1iZXJ9IFtkPTBdIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG9cbiAqIEByZXR1cm4ge251bWJlcn0gQSByb3VuZGVkIG51bWJlclxuICovXG5jb25zdCByb3VuZCA9IChuLCBkID0gMCkgPT4ge1xuICBjb25zdCBwID0gTWF0aC5wb3coMTAsIGQpO1xuICByZXR1cm4gTWF0aC5yb3VuZChuICogcCArIE51bWJlci5FUFNJTE9OKSAvIHA7XG59XG5cbi8qKlxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSwgc2hvdWxkIGJlIGluIHRoZSBpbnRlcnZhbCBbMCwgMV1cbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuY29uc3QgbGVycCA9IChhLCBiLCBpKSA9PiBhICsgKGIgLSBhKSAqIGk7XG5cbi8qKlxuICogR2V0IHRoZSBwb3NpdGlvbiBvZiBpIGJldHdlZW4gYSBhbmQgYlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcG9zaXRpb24gb2YgaSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuY29uc3QgdW5sZXJwID0gKGEsIGIsIGkpID0+IChpIC0gYSkgLyAoYiAtIGEpO1xuXG4vKipcbiAqIERvIGEgYmlsaW5lYXIgaW50ZXJwb2xhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGMwMCBUb3AtbGVmdCB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGMxMCBUb3AtcmlnaHQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMDEgQm90dG9tLWxlZnQgdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjMTEgQm90dG9tLXJpZ2h0IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaXggSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB4XG4gKiBAcGFyYW0ge251bWJlcn0gaXkgSW50ZXJwb2xhdGlvbiB2YWx1ZSBhbG9uZyB5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgYmlsaW5lYXIgaW50ZXJwb2xhdGVkIHZhbHVlXG4gKi9cbmNvbnN0IGJsZXJwID0gKGMwMCwgYzEwLCBjMDEsIGMxMSwgaXgsIGl5KSA9PiBsZXJwKGxlcnAoYzAwLCBjMTAsIGl4KSwgbGVycChjMDEsIGMxMSwgaXgpLCBpeSk7XG5cbi8qKlxuICogUmUtbWFwIGEgbnVtYmVyIGkgZnJvbSByYW5nZSBhMS4uLmEyIHRvIGIxLi4uYjJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBudW1iZXIgdG8gcmUtbWFwXG4gKiBAcGFyYW0ge251bWJlcn0gYTFcbiAqIEBwYXJhbSB7bnVtYmVyfSBhMlxuICogQHBhcmFtIHtudW1iZXJ9IGIxXG4gKiBAcGFyYW0ge251bWJlcn0gYjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgcmVtYXAgPSAoaSwgYTEsIGEyLCBiMSwgYjIpID0+IGIxICsgKGkgLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSk7XG5cbi8qKlxuICogRG8gYSBzbW9vdGggaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGEgYW5kIGJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIFRoZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgVGhlIG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfSBBbiBpbnRlcnBvbGF0ZWQgdmFsdWUgaW4gdGhlIGludGVydmFsIFthLCBiXVxuICovXG5jb25zdCBzbW9vdGhzdGVwID0gKGEsIGIsIGkpID0+IGxlcnAoYSwgYiwgMyAqIE1hdGgucG93KGksIDIpIC0gMiAqIE1hdGgucG93KGksIDMpKTtcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuY29uc3QgcmFkaWFucyA9IGRlZ3JlZXMgPT4gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcblxuLyoqXG4gKiBHZXQgYW4gYW5nbGUgaW4gZGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IHJhZGlhbnMgVGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqL1xuY29uc3QgZGVncmVlcyA9IHJhZGlhbnMgPT4gKDE4MCAvIE1hdGguUEkpICogcmFkaWFucztcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFttaW4sIG1heClcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gSW5jbHVzaXZlIG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBFeGNsdXNpdmUgbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXgpXG4gKi9cbmNvbnN0IHJhbmRvbUJldHdlZW4gPSAobWluLCBtYXgpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcblxuLyoqXG4gKiBHZXQgYSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBJbmNsdXNpdmUgbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IEluY2x1c2l2ZSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgW21pbiwgbWF4XVxuICovXG5jb25zdCByYW5kb21JbnRCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbXU9MC41XSBUaGUgbWVhbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtzaWdtYT0wLjVdIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlcz0yXSBUaGUgbnVtYmVyIG9mIHNhbXBsZXNcbiAqIEByZXR1cm4ge251bWJlcn0gQSBub3JtYWxseS1kaXN0cmlidXRlZCByYW5kb20gbnVtYmVyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbSA9IChtdSA9IDAuNSwgc2lnbWEgPSAwLjUsIHNhbXBsZXMgPSAyKSA9PiB7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSBzYW1wbGVzOyBpLS07KSB7XG4gICAgdG90YWwgKz0gTWF0aC5yYW5kb20oKTtcbiAgfVxuICByZXR1cm4gbXUgKyAodG90YWwgLSBzYW1wbGVzIC8gMikgLyAoc2FtcGxlcyAvIDIpICogc2lnbWE7XG59O1xuXG4vKipcbiAqIEdldCBhIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBbbWluLCBtYXhdXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIEluY2x1c2l2ZSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggSW5jbHVzaXZlIG1heFxuICogQHJldHVybiB7bnVtYmVyfSBBIG5vcm1hbGx5LWRpc3RyaWJ1dGVkIHJhbmRvbSBpbnRlZ2VyXG4gKi9cbmNvbnN0IGNsdFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihtaW4gKyBjbHRSYW5kb20oMC41LCAwLjUsIDIpICogKG1heCArIDEgLSBtaW4pKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB3ZWlnaHRlZCByYW5kb20gaW50ZWdlclxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB3IEFuIGFycmF5IG9mIHdlaWdodHNcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gaW5kZXggZnJvbSB3XG4gKi9cbmNvbnN0IHdlaWdodGVkUmFuZG9tID0gdyA9PiB7XG4gIGxldCB0b3RhbCA9IHcucmVkdWNlKChhLCBpKSA9PiBhICsgaSwgMCksIG4gPSAwO1xuICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHRvdGFsO1xuICB3aGlsZSAodG90YWwgPiByKSB7XG4gICAgdG90YWwgLT0gd1tuKytdO1xuICB9XG4gIHJldHVybiBuIC0gMTtcbn07XG5cbi8qKlxuICogQW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvblxuICogQGNhbGxiYWNrIEludGVycG9sYXRpb25GdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG1pbmltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgbWF4aW11bSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlLCBzaG91bGQgYmUgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlIGluIHRoZSBpbnRlcnZhbCBbYSwgYl1cbiAqL1xuXG4vKipcbiAqIFJldHVybiBhbiBpbnRlcnBvbGF0ZWQgdmFsdWUgZnJvbSBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhIEFuIGFycmF5IG9mIHZhbHVlcyBpbnRlcnBvbGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQSBudW1iZXIgaW4gdGhlIGludGVydmFsIFswLCAxXVxuICogQHBhcmFtIHtJbnRlcnBvbGF0aW9uRnVuY3Rpb259IFtmPU1hdGgubGVycF0gVGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24gdG8gdXNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVycG9sYXRlZCB2YWx1ZSBpbiB0aGUgaW50ZXJ2YWwgW21pbihhKSwgbWF4KGEpXVxuICovXG5jb25zdCBsZXJwQXJyYXkgPSAoYSwgaSwgZiA9IGxlcnApID0+IHtcbiAgY29uc3QgcyA9IGkgKiAoYS5sZW5ndGggLSAxKTtcbiAgY29uc3QgcCA9IGNsYW1wKE1hdGgudHJ1bmMocyksIDAsIGEubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBmKGFbcF0gfHwgMCwgYVtwICsgMV0gfHwgMCwgZnJhYyhzKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xuY29uc3QgZG90ID0gKGEsIGIpID0+IGEucmVkdWNlKChuLCB2LCBpKSA9PiBuICsgdiAqIGJbaV0sIDApO1xuXG4vKipcbiAqIEdldCB0aGUgZmFjdG9yaWFsIG9mIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHJldHVybiB7bnVtYmVyfSBhIVxuICovXG5jb25zdCBmYWN0b3JpYWwgPSBhID0+IHtcbiAgbGV0IHJlc3VsdCA9IDE7XG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IGE7IGkrKykge1xuICAgIHJlc3VsdCAqPSBpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbnVtYmVyIG9mIHBlcm11dGF0aW9ucyBvZiByIGVsZW1lbnRzIGZyb20gYSBzZXQgb2YgbiBlbGVtZW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSB7bnVtYmVyfSByXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG5QclxuICovXG5jb25zdCBucHIgPSAobiwgcikgPT4gZmFjdG9yaWFsKG4pIC8gZmFjdG9yaWFsKG4gLSByKTtcblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjb21iaW5hdGlvbnMgb2YgciBlbGVtZW50cyBmcm9tIGEgc2V0IG9mIG4gZWxlbWVudHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gclxuICogQHJldHVybiB7bnVtYmVyfSBuQ3JcbiAqL1xuY29uc3QgbmNyID0gKG4sIHIpID0+IGZhY3RvcmlhbChuKSAvIChmYWN0b3JpYWwocikgKiBmYWN0b3JpYWwobiAtIHIpKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgcGVybXV0YXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogcGVybXV0YXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgMV0sXG4gKiAgIFsyLCAzXSxcbiAqICAgWzMsIDFdLFxuICogICBbMywgMl1cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBwZXJtdXRhdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBwZXJtdXRhdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgcGVybXV0YXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLnBlcm11dGF0aW9ucyhhLnNsaWNlKDAsIGkpLmNvbmNhdChhLnNsaWNlKGkgKyAxKSksIHIgLSAxKS5tYXAoYyA9PiBbaXRlbSwgLi4uY10pLFxuICAgIF0sXG4gICAgW11cbiAgKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbGwgY29tYmluYXRpb25zIG9mIHIgZWxlbWVudHMgZnJvbSBhbiBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29tYmluYXRpb25zKFsxLCAyLCAzXSwgMik7XG4gKiBgYGBcbiAqXG4gKiBPdXRwdXQ6XG4gKiBgYGBqc29uXG4gKiBbXG4gKiAgIFsxLCAyXSxcbiAqICAgWzEsIDNdLFxuICogICBbMiwgM11cbiAqIF1cbiAqIGBgYFxuICogQHBhcmFtIHtBcnJheTwqPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBjaG9vc2UgaW4gZWFjaCBjb21iaW5hdGlvblxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBjb21iaW5hdGlvbiBhcnJheXNcbiAqL1xuY29uc3QgY29tYmluYXRpb25zID0gKGEsIHIpID0+IHtcbiAgaWYgKHIgPT09IDEpIHtcbiAgICByZXR1cm4gYS5tYXAoaXRlbSA9PiBbaXRlbV0pO1xuICB9XG5cbiAgcmV0dXJuIGEucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0sIGkpID0+IFtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLmNvbWJpbmF0aW9ucyhhLnNsaWNlKGkgKyAxKSwgciAtIDEpLm1hcChjID0+IFtpdGVtLCAuLi5jXSksXG4gICAgXSxcbiAgICBbXVxuICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBjYXJ0ZXNpYW4gcHJvZHVjdCBvZiBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNhcnRlc2lhbihbMSwgMiwgM10sIFsnYScsICdiJ10pO1xuICogYGBgXG4gKlxuICogT3V0cHV0OlxuICogYGBganNvblxuICogW1xuICogICBbMSwgXCJhXCJdLFxuICogICBbMSwgXCJiXCJdLFxuICogICBbMiwgXCJhXCJdLFxuICogICBbMiwgXCJiXCJdLFxuICogICBbMywgXCJhXCJdLFxuICogICBbMywgXCJiXCJdXG4gKiBdXG4gKiBgYGBcbiAqL1xuY29uc3QgY2FydGVzaWFuID0gKC4uLmFycikgPT5cbiAgYXJyLnJlZHVjZShcbiAgICAoYSwgYikgPT4gYS5mbGF0TWFwKGMgPT4gYi5tYXAoZCA9PiBbLi4uYywgZF0pKSxcbiAgICBbW11dXG4gICk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBhcnJheSB2YWx1ZXNcbiAqIEBjYWxsYmFjayBUaW1lc0Z1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IFRoZSBhcnJheSB2YWx1ZVxuICovXG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggbGVuZ3RoIG4gYnkgY2FsbGluZyBmdW5jdGlvbiBmKGkpIG9uIGVhY2ggZWxlbWVudFxuICogQHBhcmFtIHtUaW1lc0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PCo+fVxuICovXG5jb25zdCB0aW1lcyA9IChmLCBuKSA9PiBBcnJheShuKS5maWxsKDApLm1hcCgoXywgaSkgPT4gZihpKSk7XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgbnVtYmVycyAwLT4obiAtIDEpXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuIGFycmF5IG9mIGludGVnZXJzIDAtPihuIC0gMSlcbiAqL1xuY29uc3QgcmFuZ2UgPSBuID0+IHRpbWVzKGkgPT4gaSwgbik7XG5cbi8qKlxuICogWmlwIG11bHRpcGxlIGFycmF5cyB0b2dldGhlciwgaS5lLiAoWzEsIDIsIDNdLCBbYSwgYiwgY10pID0+IFtbMSwgYV0sIFsyLCBiXSwgWzMsIGNdXVxuICogQHBhcmFtIHsuLi5BcnJheTwqPn0gYSBUaGUgYXJyYXlzIHRvIHppcFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fVxuICovXG5jb25zdCB6aXAgPSAoLi4uYSkgPT4gdGltZXMoaSA9PiBhLm1hcChhID0+IGFbaV0pLCBNYXRoLm1heCguLi5hLm1hcChhID0+IGEubGVuZ3RoKSkpO1xuXG4vKipcbiAqIFJldHVybiBhcnJheVtpXSB3aXRoIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB3cmFwcGluZ1xuICogQHBhcmFtIHtBcnJheTwqPn0gYSBUaGUgYXJyYXkgdG8gYWNjZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcG9zaXRpdmVseS9uZWdhdGl2ZWx5IHdyYXBwZWQgYXJyYXkgaW5kZXhcbiAqIEByZXR1cm4geyp9IEFuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgYXQgPSAoYSwgaSkgPT4gYVtpIDwgMCA/IGEubGVuZ3RoIC0gKE1hdGguYWJzKGkgKyAxKSAlIGEubGVuZ3RoKSAtIDEgOiBpICUgYS5sZW5ndGhdO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5IHdpdGhvdXQgcmVtb3ZpbmcgaXRcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEByZXR1cm4geyp9IFRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqL1xuY29uc3QgcGVlayA9IChhKSA9PiB7XG4gIGlmICghYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBmb3IgYSBnaXZlbiBwb3NpdGlvbiBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHggcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggaW4gdGhlIHVucm9sbGVkIGFycmF5XG4gKi9cbmNvbnN0IGluZCA9ICh4LCB5LCB3KSA9PiB4ICsgeSAqIHc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwb3NpdGlvbiBmb3IgYSBnaXZlbiBpbmRleCBpbiBhbiB1bnJvbGxlZCAyZCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIDJkIGFycmF5XG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHBvc2l0aW9uIGFzIGEgMi10dXBsZVxuICovXG5jb25zdCBwb3MgPSAoaSwgdykgPT4gW2kgJSB3LCBNYXRoLmZsb29yKGkgLyB3KV07XG5cbi8qKlxuICogQ2hvcCBhbiBhcnJheSBpbnRvIGNodW5rcyBvZiBzaXplIG5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBjaHVuayBzaXplXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTwqPj59IEFuIGFycmF5IG9mIGFycmF5IGNodW5rc1xuICovXG5jb25zdCBjaHVuayA9IChhLCBuKSA9PiB0aW1lcyhpID0+IGEuc2xpY2UoaSAqIG4sIGkgKiBuICsgbiksIE1hdGguY2VpbChhLmxlbmd0aCAvIG4pKTtcblxuLyoqXG4gKiBSYW5kb21seSBzaHVmZmxlIGEgc2hhbGxvdyBjb3B5IG9mIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gVGhlIHNodWZmbGVkIGFycmF5XG4gKi9cbmNvbnN0IHNodWZmbGUgPSBhID0+IGEuc2xpY2UoKS5zb3J0KCgpID0+IE1hdGgucmFuZG9tKCkgLSAwLjUpO1xuXG4vKipcbiAqIEZsYXR0ZW4gYW4gb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gb1xuICogQHBhcmFtIHtzdHJpbmd9IGNvbmNhdGVuYXRvciBUaGUgc3RyaW5nIHRvIHVzZSBmb3IgY29uY2F0ZW5hdGluZyBrZXlzXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCBmbGF0ID0gKG8sIGNvbmNhdGVuYXRvciA9ICcuJykgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMobykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGlmIChvW2tleV0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBvW2tleV0udG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8ICFvW2tleV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2tleV06IG9ba2V5XSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXQob1trZXldLCBjb25jYXRlbmF0b3IpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIC4uLk9iamVjdC5rZXlzKGZsYXR0ZW5lZCkucmVkdWNlKFxuICAgICAgICAoY2hpbGRBY2MsIGNoaWxkS2V5KSA9PiAoe1xuICAgICAgICAgIC4uLmNoaWxkQWNjLFxuICAgICAgICAgIFtgJHtrZXl9JHtjb25jYXRlbmF0b3J9JHtjaGlsZEtleX1gXTogZmxhdHRlbmVkW2NoaWxkS2V5XSxcbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApLFxuICAgIH07XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogVW5mbGF0dGVuIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25jYXRlbmF0b3IgVGhlIHN0cmluZyB0byBjaGVjayBmb3IgaW4gY29uY2F0ZW5hdGVkIGtleXNcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gdW4tZmxhdHRlbmVkIG9iamVjdFxuICovXG5jb25zdCB1bmZsYXQgPSAobywgY29uY2F0ZW5hdG9yID0gJy4nKSA9PiB7XG4gIGxldCByZXN1bHQgPSB7fSwgdGVtcCwgc3Vic3RyaW5ncywgcHJvcGVydHksIGk7XG5cbiAgZm9yIChwcm9wZXJ0eSBpbiBvKSB7XG4gICAgc3Vic3RyaW5ncyA9IHByb3BlcnR5LnNwbGl0KGNvbmNhdGVuYXRvcik7XG4gICAgdGVtcCA9IHJlc3VsdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICghKHN1YnN0cmluZ3NbaV0gaW4gdGVtcCkpIHtcbiAgICAgICAgaWYgKGlzRmluaXRlKHN1YnN0cmluZ3NbaSArIDFdKSkge1xuICAgICAgICAgIHRlbXBbc3Vic3RyaW5nc1tpXV0gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wW3N1YnN0cmluZ3NbaV1dID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSB0ZW1wW3N1YnN0cmluZ3NbaV1dO1xuICAgIH1cbiAgICB0ZW1wW3N1YnN0cmluZ3Nbc3Vic3RyaW5ncy5sZW5ndGggLSAxXV0gPSBvW3Byb3BlcnR5XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEEgc3BsaXQgcHJlZGljYXRlXG4gKiBAY2FsbGJhY2sgU3BsaXRQcmVkaWNhdGVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgY3VycmVudCB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJyYXkgc2hvdWxkIHNwbGl0IGF0IHRoaXMgaW5kZXhcbiAqL1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IGludG8gc3ViLWFycmF5cyBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXlcbiAqIEBwYXJhbSB7U3BsaXRQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBBbiBhcnJheSBvZiBhcnJheXNcbiAqL1xuY29uc3Qgc3BsaXQgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gW3ZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnB1c2goY3VycmVudCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGx1Y2sga2V5cyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBrZXlzIFRoZSBrZXlzIHRvIHBsdWNrIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGx1Y2tlZCBrZXlzXG4gKi9cbmNvbnN0IHBsdWNrID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChyZXN1bHQsIGtleSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW2tleV06IG9ba2V5XSB9KSxcbiAgICB7fVxuICApO1xufTtcblxuLyoqXG4gKiBFeGNsdWRlIGtleXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBUaGUga2V5cyB0byBleGNsdWRlIGZyb20gdGhlIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5cyBleGNlcHQgZXhjbHVkZWQga2V5c1xuICovXG5jb25zdCBleGNsdWRlID0gKG8sIC4uLmtleXMpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKVxuICApO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1lbW9pemUsXG4gICAgZmxvYXRFcXVhbHMsXG4gICAgY2xhbXAsXG4gICAgZnJhYyxcbiAgICByb3VuZCxcbiAgICBsZXJwLFxuICAgIHVubGVycCxcbiAgICBibGVycCxcbiAgICByZW1hcCxcbiAgICBzbW9vdGhzdGVwLFxuICAgIHJhZGlhbnMsXG4gICAgZGVncmVlcyxcbiAgICByYW5kb21CZXR3ZWVuLFxuICAgIHJhbmRvbUludEJldHdlZW4sXG4gICAgY2x0UmFuZG9tLFxuICAgIGNsdFJhbmRvbUludCxcbiAgICB3ZWlnaHRlZFJhbmRvbSxcbiAgICBsZXJwQXJyYXksXG4gICAgZG90LFxuICAgIGZhY3RvcmlhbCxcbiAgICBucHIsXG4gICAgbmNyLFxuICAgIHBlcm11dGF0aW9ucyxcbiAgICBjb21iaW5hdGlvbnMsXG4gICAgY2FydGVzaWFuLFxuICAgIHRpbWVzLFxuICAgIHJhbmdlLFxuICAgIHppcCxcbiAgICBhdCxcbiAgICBwZWVrLFxuICAgIGluZCxcbiAgICBwb3MsXG4gICAgY2h1bmssXG4gICAgc2h1ZmZsZSxcbiAgICBmbGF0LFxuICAgIHVuZmxhdCxcbiAgICBzcGxpdCxcbiAgICBwbHVjayxcbiAgICBleGNsdWRlLFxuICB9O1xufVxuIiwiLyoqXG4gKiBAb3ZlcnZpZXcgQSBzbWFsbCB2ZWN0b3IgYW5kIG1hdHJpeCBsaWJyYXJ5XG4gKiBAYXV0aG9yIEdvcmRvbiBMYXJyaWdhblxuICovXG5cbmNvbnN0IF92ZWNfdGltZXMgPSAoZiwgbikgPT4gQXJyYXkobikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGYoaSkpO1xuY29uc3QgX3ZlY19jaHVuayA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gYS5zbGljZShpICogbiwgaSAqIG4gKyBuKSwgTWF0aC5jZWlsKGEubGVuZ3RoIC8gbikpO1xuY29uc3QgX3ZlY19kb3QgPSAoYSwgYikgPT4gYS5yZWR1Y2UoKG4sIHYsIGkpID0+IG4gKyB2ICogYltpXSwgMCk7XG5jb25zdCBfdmVjX2lzX3ZlYzIgPSBhID0+IHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiAneCcgaW4gYSAmJiAneScgaW4gYTtcbmNvbnN0IF92ZWNfaXNfdmVjMyA9IGEgPT4gdHlwZW9mIGEgPT09ICdvYmplY3QnICYmICd4JyBpbiBhICYmICd5JyBpbiBhICYmICd6JyBpbiBhO1xuXG4vKipcbiAqIEEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZWMyXG4gKiBAcHJvcGVydHkge251bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAyZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzJ9IFt4XSBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvciwgb3IgYSB2ZWN0b3IgdG8gY29weVxuICogQHBhcmFtIHtudW1iZXJ9IFt5XSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gQSBuZXcgMmQgdmVjdG9yXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj52YXJpb3VzIHdheXMgdG8gaW5pdGlhbGlzZSBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAyKTsgLy8gKDMsIDIpXG4gKiBsZXQgYiA9IHZlYzIoNCk7ICAgIC8vICg0LCA0KVxuICogbGV0IGMgPSB2ZWMyKGEpOyAgICAvLyAoMywgMilcbiAqIGxldCBkID0gdmVjMigpOyAgICAgLy8gKDAsIDApXG4gKi9cbmNvbnN0IHZlYzIgPSAoeCwgeSkgPT4ge1xuICBpZiAoIXggJiYgIXkpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCB9O1xuICB9XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgPz8geCB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIGZyb21cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSB2ZWN0b3IgY29tcG9uZW50cyBhcyBhbiBhcnJheVxuICovXG52ZWMyLmNvbXBvbmVudHMgPSBhID0+IFthLngsIGEueV07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgbmV3IHZlY3RvclxuICovXG52ZWMyLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMyKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMikpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwKVxuICogQHJldHVybiB7dmVjMn0gQSB1bml0IHZlY3RvciAoMSwgMClcbiAqL1xudmVjMi51eCA9ICgpID0+IHZlYzIoMSwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEpXG4gKiBAcmV0dXJuIHt2ZWMyfSBBIHVuaXQgdmVjdG9yICgwLCAxKVxuICovXG52ZWMyLnV5ID0gKCkgPT4gdmVjMigwLCAxKTtcblxuLyoqXG4gKiBBZGQgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ8bnVtYmVyfSBiIFZlY3RvciBvciBzY2FsYXIgYlxuICogQHJldHVybiB7dmVjMn0gYSArIGJcbiAqL1xudmVjMi5hZGQgPSAoYSwgYikgPT4gKHsgeDogYS54ICsgKGIueCA/PyBiKSwgeTogYS55ICsgKGIueSA/PyBiKSB9KTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC0gYlxuICovXG52ZWMyLnN1YiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLSAoYi54ID8/IGIpLCB5OiBhLnkgLSAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhICogYlxuICovXG52ZWMyLm11bCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKiAoYi54ID8/IGIpLCB5OiBhLnkgKiAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGJ5IGEgc2NhbGFyLCBhbGlhcyBmb3IgdmVjMi5tdWxcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzJ9IGEgKiBiXG4gKi9cbnZlYzIuc2NhbGUgPSAoYSwgYikgPT4gdmVjMi5tdWwoYSwgYik7XG5cbi8qKlxuICogRGl2aWRlIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMnxudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMyfSBhIC8gYlxuICovXG52ZWMyLmRpdiA9IChhLCBiKSA9PiAoeyB4OiBhLnggLyAoYi54ID8/IGIpLCB5OiBhLnkgLyAoYi55ID8/IGIpIH0pO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubGVuID0gYSA9PiBNYXRoLnNxcnQoYS54ICogYS54ICsgYS55ICogYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB1c2luZyB0YXhpY2FiIGdlb21ldHJ5XG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gfGF8XG4gKi9cbnZlYzIubWFuaGF0dGFuID0gYSA9PiBNYXRoLmFicyhhLngpICsgTWF0aC5hYnMoYS55KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjMn0gXmFcbiAqL1xudmVjMi5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzIubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiB9IDogdmVjMigpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBkb3QgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIOKImSBiXG4gKi9cbnZlYzIuZG90ID0gKGEsIGIpID0+IGEueCAqIGIueCArIGEueSAqIGIueTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgciByYWRpYW5zXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIG1lYXN1cmVkIGluIHJhZGlhbnNcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgcm90YXRlZCB2ZWN0b3JcbiAqL1xudmVjMi5yb3QgPSAoYSwgcikgPT4ge1xuICBsZXQgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIHsgeDogYyAqIGEueCAtIHMgKiBhLnksIHk6IHMgKiBhLnggKyBjICogYS55IH07XG59O1xuXG4vKipcbiAqIEZhc3QgbWV0aG9kIHRvIHJvdGF0ZSBhIHZlY3RvciBieSAtOTAsIDkwIG9yIDE4MCBkZWdyZWVzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByIDEgZm9yIDkwIGRlZ3JlZXMgKGN3KSwgLTEgZm9yIC05MCBkZWdyZWVzIChjY3cpLCAyIG9yIC0yIGZvciAxODAgZGVncmVlc1xuICogQHJldHVybiB7dmVjMn0gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMyLnJvdGYgPSAoYSwgcikgPT4ge1xuICBzd2l0Y2ggKHIpIHtcbiAgICBjYXNlIDE6IHJldHVybiB2ZWMyKGEueSwgLWEueCk7XG4gICAgY2FzZSAtMTogcmV0dXJuIHZlYzIoLWEueSwgYS54KTtcbiAgICBjYXNlIDI6IGNhc2UgLTI6IHJldHVybiB2ZWMyKC1hLngsIC1hLnkpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBhO1xuICB9XG59O1xuXG4vKipcbiAqIFNjYWxhciBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjMn0gYiBWZWN0b3IgYlxuICogQHJldHVybiB7bnVtYmVyfSBhIMOXIGJcbiAqL1xudmVjMi5jcm9zcyA9IChhLCBiKSA9PiB7XG4gIHJldHVybiBhLnggKiBiLnkgLSBhLnkgKiBiLng7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZSBlcXVhbFxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVmVjdG9yIGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmVjdG9ycyBhIGFuZCBiIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbnZlYzIuZXEgPSAoYSwgYikgPT4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzIucmFkID0gYSA9PiBNYXRoLmF0YW4yKGEueSwgYS54KTtcblxuLyoqXG4gKiBDb3B5IGEgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb3B5XG4gKiBAcmV0dXJuIHt2ZWMyfSBBIGNvcHkgb2YgdmVjdG9yIGFcbiAqL1xudmVjMi5jcHkgPSBhID0+IHZlYzIoYSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgMmQgdmVjdG9yXG4gKiBAY2FsbGJhY2sgdmVjMk1hcENhbGxiYWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICogQHBhcmFtIHsneCcgfCAneSd9IGxhYmVsIFRoZSBjb21wb25lbnQgbGFiZWwgKHggb3IgeSlcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1hcHBlZCBjb21wb25lbnRcbiAqL1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBvbiBlYWNoIGNvbXBvbmVudCBvZiBhIHZlY3RvciBhbmQgYnVpbGQgYSBuZXcgdmVjdG9yIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7dmVjMn0gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMyTWFwQ2FsbGJhY2t9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjMn0gVmVjdG9yIGEgbWFwcGVkIHRocm91Z2ggZlxuICovXG52ZWMyLm1hcCA9IChhLCBmKSA9PiAoeyB4OiBmKGEueCwgJ3gnKSwgeTogZihhLnksICd5JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX1gO1xuXG4vKipcbiAqIFN3aXp6bGUgYSB2ZWN0b3Igd2l0aCBhIHN0cmluZyBvZiBjb21wb25lbnQgbGFiZWxzXG4gKlxuICogVGhlIHN0cmluZyBjYW4gY29udGFpbjpcbiAqIC0gYHhgIG9yIGB5YFxuICogLSBgdWAgb3IgYHZgIChhbGlhc2VzIGZvciBgeGAgYW5kIGB5YCwgcmVzcGVjdGl2ZWx5KVxuICogLSBgWGAsIGBZYCwgYFVgLCBgVmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLiddIFRoZSBzd2l6emxlIHN0cmluZ1xuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHN3aXp6bGVkIGNvbXBvbmVudHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnN3aXp6bGluZyBhIHZlY3RvcjwvY2FwdGlvbj5cbiAqIGxldCBhID0gdmVjMigzLCAtMik7XG4gKiB2ZWMyLnN3aXooYSwgJ3gnKTsgICAgLy8gWzNdXG4gKiB2ZWMyLnN3aXooYSwgJ3l4Jyk7ICAgLy8gWy0yLCAzXVxuICogdmVjMi5zd2l6KGEsICd4WScpOyAgIC8vIFszLCAyXVxuICogdmVjMi5zd2l6KGEsICdZeScpOyAgIC8vIFsyLCAtMl1cbiAqIHZlYzIuc3dpeihhLCAneC54Jyk7ICAvLyBbMywgLTIsIDNdXG4gKiB2ZWMyLnN3aXooYSwgJ3kwMXgnKTsgLy8gWy0yLCAwLCAxLCAzXVxuICovXG52ZWMyLnN3aXogPSAoYSwgcyA9ICcuLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogcmVzdWx0LnB1c2goYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICd5JzogY2FzZSAndic6IHJlc3VsdC5wdXNoKGEueSk7IGJyZWFrO1xuICAgICAgY2FzZSAnWCc6IGNhc2UgJ1UnOiByZXN1bHQucHVzaCgtYS54KTsgYnJlYWs7XG4gICAgICBjYXNlICdZJzogY2FzZSAnVic6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueV1baV0gPz8gMCk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmVzdWx0LnB1c2goMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9sYXIgY29vcmRpbmF0ZXMgZm9yIGEgMmQgdmVjdG9yXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBwb2xhckNvb3JkaW5hdGVzMmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByIFRoZSBtYWduaXR1ZGUgKHJhZGl1cykgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRoZXRhIFRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmVjdG9yIGludG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjdG9yIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3BvbGFyQ29vcmRpbmF0ZXMyZH0gVGhlIG1hZ25pdHVkZSBhbmQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnBvbGFyID0gYSA9PiAoeyByOiB2ZWMyLmxlbihhKSwgdGhldGE6IE1hdGguYXRhbjIoYS55LCBhLngpIH0pO1xuXG4vKipcbiAqIENvbnZlcnQgcG9sYXIgY29vcmRpbmF0ZXMgaW50byBhIHZlY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gdGhldGEgVGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzJ9IEEgdmVjdG9yIHdpdGggdGhlIGdpdmVuIGFuZ2xlIGFuZCBtYWduaXR1ZGVcbiAqL1xudmVjMi5mcm9tUG9sYXIgPSAociwgdGhldGEpID0+IHZlYzIociAqIE1hdGguY29zKHRoZXRhKSwgciAqIE1hdGguc2luKHRoZXRhKSk7XG5cbi8qKlxuICogQSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHZlYzNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHogVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyAzZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfHZlYzN8dmVjMn0gW3hdIFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciBhIHZlY3RvciB0byBjb3B5XG4gKiBAcGFyYW0ge251bWJlcn0gW3ldIFRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLCBvciB0aGUgeiBjb21wb25lbnQgaWYgeCBpcyBhIHZlYzJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbel0gVGhlIHogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IDNkIHZlY3RvclxuICogQGV4YW1wbGUgPGNhcHRpb24+dmFyaW91cyB3YXlzIHRvIGluaXRpYWxpc2UgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgMiwgMSk7ICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGIgPSB2ZWMzKDQsIDUpOyAgICAgICAgICAvLyAoNCwgNSwgMClcbiAqIGxldCBjID0gdmVjMyg2KTsgICAgICAgICAgICAgLy8gKDYsIDYsIDYpXG4gKiBsZXQgZCA9IHZlYzMoYSk7ICAgICAgICAgICAgIC8vICgzLCAyLCAxKVxuICogbGV0IGUgPSB2ZWMzKCk7ICAgICAgICAgICAgICAvLyAoMCwgMCwgMClcbiAqIGxldCBmID0gdmVjMyh2ZWMyKDEsIDIpLCAzKTsgLy8gKDEsIDIsIDMpXG4gKiBsZXQgZyA9IHZlYzModmVjMig0LCA1KSk7ICAgIC8vICg0LCA1LCAwKVxuICovXG5jb25zdCB2ZWMzID0gKHgsIHksIHopID0+IHtcbiAgaWYgKCF4ICYmICF5ICYmICF6KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCwgejogMCB9O1xuICB9XG4gIGlmIChfdmVjX2lzX3ZlYzMoeCkpIHtcbiAgICByZXR1cm4geyB4OiB4LnggfHwgMCwgeTogeC55IHx8IDAsIHo6IHgueiB8fCAwIH07XG4gIH1cbiAgaWYgKF92ZWNfaXNfdmVjMih4KSkge1xuICAgIHJldHVybiB7IHg6IHgueCB8fCAwLCB5OiB4LnkgfHwgMCwgejogeSB8fCAwIH07XG4gIH1cbiAgcmV0dXJuIHsgeDogeCwgeTogeSA/PyB4LCB6OiB6ID8/IHggfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgdmVjdG9yIGNvbXBvbmVudHMgYXMgYW4gYXJyYXlcbiAqL1xudmVjMy5jb21wb25lbnRzID0gYSA9PiBbYS54LCBhLnksIGEuel07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVjdG9yIGZyb20gYW4gYXJyYXkgb2YgY29tcG9uZW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb21wb25lbnRzIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3JcbiAqIEByZXR1cm4ge3ZlYzN9IEEgbmV3IHZlY3RvclxuICovXG52ZWMzLmZyb21Db21wb25lbnRzID0gY29tcG9uZW50cyA9PiB2ZWMzKC4uLmNvbXBvbmVudHMuc2xpY2UoMCwgMykpO1xuXG4vKipcbiAqIFJldHVybiBhIHVuaXQgdmVjdG9yICgxLCAwLCAwKVxuICogQHJldHVybiB7dmVjM30gQSB1bml0IHZlY3RvciAoMSwgMCwgMClcbiAqL1xudmVjMy51eCA9ICgpID0+IHZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pdCB2ZWN0b3IgKDAsIDEsIDApXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHVuaXQgdmVjdG9yICgwLCAxLCAwKVxuICovXG52ZWMzLnV5ID0gKCkgPT4gdmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBSZXR1cm4gYSB1bml0IHZlY3RvciAoMCwgMCwgMSlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgdW5pdCB2ZWN0b3IgKDAsIDAsIDEpXG4gKi9cbnZlYzMudXogPSAoKSA9PiB2ZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIEFkZCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM3xudW1iZXJ9IGIgVmVjdG9yIG9yIHNjYWxhciBiXG4gKiBAcmV0dXJuIHt2ZWMzfSBhICsgYlxuICovXG52ZWMzLmFkZCA9IChhLCBiKSA9PiAoeyB4OiBhLnggKyAoYi54ID8/IGIpLCB5OiBhLnkgKyAoYi55ID8/IGIpLCB6OiBhLnogKyAoYi56ID8/IGIpIH0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLSBiXG4gKi9cbnZlYzMuc3ViID0gKGEsIGIpID0+ICh7IHg6IGEueCAtIChiLnggPz8gYiksIHk6IGEueSAtIChiLnkgPz8gYiksIHo6IGEueiAtIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgKiBiXG4gKi9cbnZlYzMubXVsID0gKGEsIGIpID0+ICh7IHg6IGEueCAqIChiLnggPz8gYiksIHk6IGEueSAqIChiLnkgPz8gYiksIHo6IGEueiAqIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogU2NhbGUgYSB2ZWN0b3IgYnkgYSBzY2FsYXIsIGFsaWFzIGZvciB2ZWMzLm11bFxuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiBTY2FsYXIgYlxuICogQHJldHVybiB7dmVjM30gYSAqIGJcbiAqL1xudmVjMy5zY2FsZSA9IChhLCBiKSA9PiB2ZWMzLm11bChhLCBiKTtcblxuLyoqXG4gKiBEaXZpZGUgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfG51bWJlcn0gYiBWZWN0b3Igb3Igc2NhbGFyIGJcbiAqIEByZXR1cm4ge3ZlYzN9IGEgLyBiXG4gKi9cbnZlYzMuZGl2ID0gKGEsIGIpID0+ICh7IHg6IGEueCAvIChiLnggPz8gYiksIHk6IGEueSAvIChiLnkgPz8gYiksIHo6IGEueiAvIChiLnogPz8gYikgfSk7XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5sZW4gPSBhID0+IE1hdGguc3FydChhLnggKiBhLnggKyBhLnkgKiBhLnkgKyBhLnogKiBhLnopO1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHVzaW5nIHRheGljYWIgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSB8YXxcbiAqL1xudmVjMy5tYW5oYXR0YW4gPSBhID0+IE1hdGguYWJzKGEueCkgKyBNYXRoLmFicyhhLnkpICsgTWF0aC5hYnMoYS56KTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIG5vcm1hbGlzZVxuICogQHJldHVybiB7dmVjM30gXmFcbiAqL1xudmVjMy5ub3IgPSBhID0+IHtcbiAgbGV0IGxlbiA9IHZlYzMubGVuKGEpO1xuICByZXR1cm4gbGVuID8geyB4OiBhLnggLyBsZW4sIHk6IGEueSAvIGxlbiwgejogYS56IC8gbGVuIH0gOiB2ZWMzKCk7XG59O1xuXG4vKipcbiAqIEdldCBhIGRvdCBwcm9kdWN0IG9mIHZlY3RvcnNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGEg4oiZIGJcbiAqL1xudmVjMy5kb3QgPSAoYSwgYikgPT4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHJvdGF0aW9uIG1hdHJpeFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge21hdH0gbSBUaGUgcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90ID0gKGEsIG0pID0+IHZlYzMoXG4gIHZlYzMuZG90KHZlYzMuZnJvbUNvbXBvbmVudHMobWF0LnJvdyhtLCAxKSksIGEpLFxuICB2ZWMzLmRvdCh2ZWMzLmZyb21Db21wb25lbnRzKG1hdC5yb3cobSwgMikpLCBhKSxcbiAgdmVjMy5kb3QodmVjMy5mcm9tQ29tcG9uZW50cyhtYXQucm93KG0sIDMpKSwgYSlcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHggYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eCA9IChhLCByKSA9PiB2ZWMzKFxuICBhLngsXG4gIGEueSAqIE1hdGguY29zKHIpIC0gYS56ICogTWF0aC5zaW4ociksXG4gIGEueSAqIE1hdGguc2luKHIpICsgYS56ICogTWF0aC5jb3Mocilcbik7XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIGJ5IHIgcmFkaWFucyBhcm91bmQgdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBtZWFzdXJlZCBpbiByYWRpYW5zXG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90eSA9IChhLCByKSA9PiB2ZWMzKFxuICBhLnggKiBNYXRoLmNvcyhyKSArIGEueiAqIE1hdGguc2luKHIpLFxuICBhLnksXG4gIC1hLnggKiBNYXRoLnNpbihyKSArIGEueiAqIE1hdGguY29zKHIpXG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciBieSByIHJhZGlhbnMgYXJvdW5kIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHIgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSwgbWVhc3VyZWQgaW4gcmFkaWFuc1xuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHogPSAoYSwgcikgPT4gdmVjMyhcbiAgYS54ICogTWF0aC5jb3MocikgLSBhLnkgKiBNYXRoLnNpbihyKSxcbiAgYS54ICogTWF0aC5zaW4ocikgKyBhLnkgKiBNYXRoLmNvcyhyKSxcbiAgYS56XG4pO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBhIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxIFRoZSBxdWF0ZXJuaW9uIHRvIHJvdGF0ZSBieVxuICogQHJldHVybiB7dmVjM30gQSByb3RhdGVkIHZlY3RvclxuICovXG52ZWMzLnJvdHEgPSAodiwgcSkgPT4ge1xuICBpZiAocS5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gdmVjMygpO1xuICB9XG5cbiAgY29uc3QgZCA9IE1hdGguc3FydChxWzBdICogcVswXSArIHFbMV0gKiBxWzFdICsgcVsyXSAqIHFbMl0gKyBxWzNdICogcVszXSk7XG4gIGlmIChkID09PSAwKSB7XG4gICAgcmV0dXJuIHZlYzMoKTtcbiAgfVxuXG4gIGNvbnN0IHVxID0gW3FbMF0gLyBkLCBxWzFdIC8gZCwgcVsyXSAvIGQsIHFbM10gLyBkXTtcbiAgY29uc3QgdSA9IHZlYzMoLi4udXEuc2xpY2UoMCwgMykpO1xuICBjb25zdCBzID0gdXFbM107XG4gIHJldHVybiB2ZWMzLmFkZChcbiAgICB2ZWMzLmFkZChcbiAgICAgIHZlYzMubXVsKHUsIDIgKiB2ZWMzLmRvdCh1LCB2KSksXG4gICAgICB2ZWMzLm11bCh2LCBzICogcyAtIHZlYzMuZG90KHUsIHUpKVxuICAgICksXG4gICAgdmVjMy5tdWwodmVjMy5jcm9zcyh1LCB2KSwgMiAqIHMpXG4gICk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHZlY3RvciB1c2luZyBFdWxlciBhbmdsZXNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBlIFRoZSBFdWxlciBhbmdsZXMgdG8gcm90YXRlIGJ5XG4gKiBAcmV0dXJuIHt2ZWMzfSBBIHJvdGF0ZWQgdmVjdG9yXG4gKi9cbnZlYzMucm90YSA9IChhLCBlKSA9PiB2ZWMzLnJvdHoodmVjMy5yb3R5KHZlYzMucm90eChhLCBlLngpLCBlLnkpLCBlLnopO1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEBwYXJhbSB7dmVjM30gYiBWZWN0b3IgYlxuICogQHJldHVybiB7dmVjM30gYSDDlyBiXG4gKi9cbnZlYzMuY3Jvc3MgPSAoYSwgYikgPT4gdmVjMyhcbiAgYS55ICogYi56IC0gYS56ICogYi55LFxuICBhLnogKiBiLnggLSBhLnggKiBiLnosXG4gIGEueCAqIGIueSAtIGEueSAqIGIueFxuKTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWxcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHBhcmFtIHt2ZWMzfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZlY3RvcnMgYSBhbmQgYiBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG52ZWMzLmVxID0gKGEsIGIpID0+IGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEueiA9PT0gYi56O1xuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgb2YgYSB2ZWN0b3IgZnJvbSB0aGUgeCBheGlzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVmVjdG9yIGFcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIG9mIHZlY3RvciBhIGluIHJhZGlhbnNcbiAqL1xudmVjMy5yYWR4ID0gYSA9PiBNYXRoLmF0YW4yKGEueiwgYS55KTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHkgYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbmdsZSBvZiB2ZWN0b3IgYSBpbiByYWRpYW5zXG4gKi9cbnZlYzMucmFkeSA9IGEgPT4gTWF0aC5hdGFuMihhLngsIGEueSk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBvZiBhIHZlY3RvciBmcm9tIHRoZSB6IGF4aXNcbiAqIEBwYXJhbSB7dmVjM30gYSBWZWN0b3IgYVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW5nbGUgb2YgdmVjdG9yIGEgaW4gcmFkaWFuc1xuICovXG52ZWMzLnJhZHogPSBhID0+IE1hdGguYXRhbjIoYS55LCBhLnopO1xuXG4vKipcbiAqIENvcHkgYSB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjdG9yIHRvIGNvcHlcbiAqIEByZXR1cm4ge3ZlYzN9IEEgY29weSBvZiB2ZWN0b3IgYVxuICovXG52ZWMzLmNweSA9IGEgPT4gdmVjMyhhKTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBjb21wb25lbnQgb2YgYSAzZCB2ZWN0b3JcbiAqIEBjYWxsYmFjayB2ZWMzTWFwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgY29tcG9uZW50IHZhbHVlXG4gKiBAcGFyYW0geyd4JyB8ICd5JyB8ICd6J30gbGFiZWwgVGhlIGNvbXBvbmVudCBsYWJlbCAoeCwgeSBvciB6KVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGNvbXBvbmVudFxuICovXG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIG9uIGVhY2ggY29tcG9uZW50IG9mIGEgdmVjdG9yIGFuZCBidWlsZCBhIG5ldyB2ZWN0b3IgZnJvbSB0aGUgcmVzdWx0c1xuICogQHBhcmFtIHt2ZWMzfSBhIFZlY3RvciBhXG4gKiBAcGFyYW0ge3ZlYzNNYXBDYWxsYmFja30gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXG4gKiBAcmV0dXJuIHt2ZWMzfSBWZWN0b3IgYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbnZlYzMubWFwID0gKGEsIGYpID0+ICh7IHg6IGYoYS54LCAneCcpLCB5OiBmKGEueSwgJ3knKSwgejogZihhLnosICd6JykgfSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZlY3RvciBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlY3RvciB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3M9JywgJ10gVGhlIHNlcGFyYXRvciBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IChhLCBzID0gJywgJykgPT4gYCR7YS54fSR7c30ke2EueX0ke3N9JHthLnp9YDtcblxuLyoqXG4gKiBTd2l6emxlIGEgdmVjdG9yIHdpdGggYSBzdHJpbmcgb2YgY29tcG9uZW50IGxhYmVsc1xuICpcbiAqIFRoZSBzdHJpbmcgY2FuIGNvbnRhaW46XG4gKiAtIGB4YCwgYHlgIG9yIGB6YFxuICogLSBgdWAsIGB2YCBvciBgd2AgKGFsaWFzZXMgZm9yIGB4YCwgYHlgIGFuZCBgemAsIHJlc3BlY3RpdmVseSlcbiAqIC0gYHJgLCBgZ2Agb3IgYGJgIChhbGlhc2VzIGZvciBgeGAsIGB5YCBhbmQgYHpgLCByZXNwZWN0aXZlbHkpXG4gKiAtIGBYYCwgYFlgLCBgWmAsIGBVYCwgYFZgLCBgV2AsIGBSYCwgYEdgLCBgQmAgKG5lZ2F0ZWQgdmVyc2lvbnMgb2YgdGhlIGFib3ZlKVxuICogLSBgMGAgb3IgYDFgICh0aGVzZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZClcbiAqIC0gYC5gIHRvIHJldHVybiB0aGUgY29tcG9uZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYmUgYXQgdGhpcyBwb3NpdGlvbiAob3IgMClcbiAqXG4gKiBBbnkgb3RoZXIgY2hhcmFjdGVycyB3aWxsIGRlZmF1bHQgdG8gMFxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gc3dpenpsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzPScuLi4nXSBUaGUgc3dpenpsZSBzdHJpbmdcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBzd2l6emxlZCBjb21wb25lbnRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5zd2l6emxpbmcgYSB2ZWN0b3I8L2NhcHRpb24+XG4gKiBsZXQgYSA9IHZlYzMoMywgLTIsIDEpO1xuICogdmVjMy5zd2l6KGEsICd4Jyk7ICAgICAvLyBbM11cbiAqIHZlYzMuc3dpeihhLCAnenl4Jyk7ICAgLy8gWzEsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd4WVonKTsgICAvLyBbMywgMiwgLTFdXG4gKiB2ZWMzLnN3aXooYSwgJ1p6eCcpOyAgIC8vIFstMSwgMSwgM11cbiAqIHZlYzMuc3dpeihhLCAneC54Jyk7ICAgLy8gWzMsIC0yLCAzXVxuICogdmVjMy5zd2l6KGEsICd5MDF6eCcpOyAvLyBbLTIsIDAsIDEsIDEsIDNdXG4gKi9cbnZlYzMuc3dpeiA9IChhLCBzID0gJy4uLicpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHMuc3BsaXQoJycpLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJ3gnOiBjYXNlICd1JzogY2FzZSAncic6IHJlc3VsdC5wdXNoKGEueCk7IGJyZWFrO1xuICAgICAgY2FzZSAneSc6IGNhc2UgJ3YnOiBjYXNlICdnJzogcmVzdWx0LnB1c2goYS55KTsgYnJlYWs7XG4gICAgICBjYXNlICd6JzogY2FzZSAndyc6IGNhc2UgJ2InOiByZXN1bHQucHVzaChhLnopOyBicmVhaztcbiAgICAgIGNhc2UgJ1gnOiBjYXNlICdVJzogY2FzZSAnUic6IHJlc3VsdC5wdXNoKC1hLngpOyBicmVhaztcbiAgICAgIGNhc2UgJ1knOiBjYXNlICdWJzogY2FzZSAnRyc6IHJlc3VsdC5wdXNoKC1hLnkpOyBicmVhaztcbiAgICAgIGNhc2UgJ1onOiBjYXNlICdXJzogY2FzZSAnQic6IHJlc3VsdC5wdXNoKC1hLnopOyBicmVhaztcbiAgICAgIGNhc2UgJzAnOiByZXN1bHQucHVzaCgwKTsgYnJlYWs7XG4gICAgICBjYXNlICcxJzogcmVzdWx0LnB1c2goMSk7IGJyZWFrO1xuICAgICAgY2FzZSAnLic6IHJlc3VsdC5wdXNoKFthLngsIGEueSwgYS56XVtpXSA/PyAwKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXN1bHQucHVzaCgwKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQb2xhciBjb29yZGluYXRlcyBmb3IgYSAzZCB2ZWN0b3JcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHBvbGFyQ29vcmRpbmF0ZXMzZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHIgVGhlIG1hZ25pdHVkZSAocmFkaXVzKSBvZiB0aGUgdmVjdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGhldGEgVGhlIHRpbHQgYW5nbGUgb2YgdGhlIHZlY3RvclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBoaSBUaGUgcGFuIGFuZ2xlIG9mIHRoZSB2ZWN0b3JcbiAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2ZWN0b3IgaW50byBwb2xhciBjb29yZGluYXRlc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWN0b3IgdG8gY29udmVydFxuICogQHJldHVybiB7cG9sYXJDb29yZGluYXRlczNkfSBUaGUgbWFnbml0dWRlLCB0aWx0IGFuZCBwYW4gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnBvbGFyID0gYSA9PiB7XG4gIGxldCByID0gdmVjMy5sZW4oYSksXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoYS55IC8gciksXG4gICAgcGhpID0gTWF0aC5hdGFuMihhLnosIGEueCk7XG4gIHJldHVybiB7IHIsIHRoZXRhLCBwaGkgfTtcbn07XG5cbi8qKlxuICogQ29udmVydCBwb2xhciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gciBUaGUgbWFnbml0dWRlIChyYWRpdXMpIG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBUaGUgdGlsdCBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gcGhpIFRoZSBwYW4gb2YgdGhlIHZlY3RvclxuICogQHJldHVybiB7dmVjM30gQSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gYW5nbGUgYW5kIG1hZ25pdHVkZVxuICovXG52ZWMzLmZyb21Qb2xhciA9IChyLCB0aGV0YSwgcGhpKSA9PiB7XG4gIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICByZXR1cm4gdmVjMyhcbiAgICByICogc2luVGhldGEgKiBNYXRoLmNvcyhwaGkpLFxuICAgIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgciAqIHNpblRoZXRhICogTWF0aC5zaW4ocGhpKVxuICApO1xufTtcblxuLyoqXG4gKiBBIG1hdHJpeFxuICogQHR5cGVkZWYge09iamVjdH0gbWF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gbSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hdHJpeFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gZW50cmllcyBUaGUgbWF0cml4IHZhbHVlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdHJpeFxuICogQHBhcmFtIHtudW1iZXJ9IFttPTRdIFRoZSBudW1iZXIgb2Ygcm93c1xuICogQHBhcmFtIHtudW1iZXJ9IFtuPTRdIFRoZSBudW1iZXIgb2YgY29sdW1uc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbZW50cmllcz1bXV0gTWF0cml4IHZhbHVlcyBpbiByZWFkaW5nIG9yZGVyXG4gKiBAcmV0dXJuIHttYXR9IEEgbmV3IG1hdHJpeFxuICovXG5jb25zdCBtYXQgPSAobSA9IDQsIG4gPSA0LCBlbnRyaWVzID0gW10pID0+ICh7XG4gIG0sIG4sXG4gIGVudHJpZXM6IGVudHJpZXMuY29uY2F0KEFycmF5KG0gKiBuKS5maWxsKDApKS5zbGljZSgwLCBtICogbilcbn0pO1xuXG4vKipcbiAqIEdldCBhbiBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgc2l6ZSBvZiB0aGUgbWF0cml4XG4gKiBAcmV0dXJuIHttYXR9IEFuIGlkZW50aXR5IG1hdHJpeFxuICovXG5tYXQuaWRlbnRpdHkgPSBuID0+IG1hdChuLCBuLCBBcnJheShuICogbikuZmlsbCgwKS5tYXAoKHYsIGkpID0+ICsoTWF0aC5mbG9vcihpIC8gbikgPT09IGkgJSBuKSkpO1xuXG4vKipcbiAqIEdldCBhbiBlbnRyeSBmcm9tIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIHJvdyBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBqIFRoZSBjb2x1bW4gb2Zmc2V0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAoaSwgaikgaW4gbWF0cml4IGFcbiAqL1xubWF0LmdldCA9IChhLCBpLCBqKSA9PiBhLmVudHJpZXNbKGogLSAxKSArIChpIC0gMSkgKiBhLm5dO1xuXG4vKipcbiAqIFNldCBhbiBlbnRyeSBvZiBhIG1hdHJpeFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSByb3cgb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gaiBUaGUgY29sdW1uIG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHYgVGhlIHZhbHVlIHRvIHNldCBpbiBtYXRyaXggYVxuICovXG5tYXQuc2V0ID0gKGEsIGksIGosIHYpID0+IHsgYS5lbnRyaWVzWyhqIC0gMSkgKyAoaSAtIDEpICogYS5uXSA9IHY7IH07XG5cbi8qKlxuICogR2V0IGEgcm93IGZyb20gYSBtYXRyaXggYXMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gbSBUaGUgcm93IG9mZnNldFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUm93IG0gZnJvbSBtYXRyaXggYVxuICovXG5tYXQucm93ID0gKGEsIG0pID0+IHtcbiAgY29uc3QgcyA9IChtIC0gMSkgKiBhLm47XG4gIHJldHVybiBhLmVudHJpZXMuc2xpY2UocywgcyArIGEubik7XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbHVtbiBmcm9tIGEgbWF0cml4IGFzIGFuIGFycmF5XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENvbHVtbiBuIGZyb20gbWF0cml4IGFcbiAqL1xubWF0LmNvbCA9IChhLCBuKSA9PiBfdmVjX3RpbWVzKGkgPT4gbWF0LmdldChhLCAoaSArIDEpLCBuKSwgYS5tKTtcblxuLyoqXG4gKiBBZGQgbWF0cmljZXNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdH0gYiBNYXRyaXggYlxuICogQHJldHVybiB7bWF0fSBhICsgYlxuICovXG5tYXQuYWRkID0gKGEsIGIpID0+IGEubSA9PT0gYi5tICYmIGEubiA9PT0gYi5uICYmIG1hdC5tYXAoYSwgKHYsIGkpID0+IHYgKyBiLmVudHJpZXNbaV0pO1xuXG4vKipcbiAqIFN1YnRyYWN0IG1hdHJpY2VzXG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHttYXR9IGIgTWF0cml4IGJcbiAqIEByZXR1cm4ge21hdH0gYSAtIGJcbiAqL1xubWF0LnN1YiA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQubWFwKGEsICh2LCBpKSA9PiB2IC0gYi5lbnRyaWVzW2ldKTtcblxuLyoqXG4gKiBNdWx0aXBseSBtYXRyaWNlc1xuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaWNlcyBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsID0gKGEsIGIpID0+IHtcbiAgaWYgKGEubiAhPT0gYi5tKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBtYXQoYS5tLCBiLm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhLm07IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDw9IGIubjsgaisrKSB7XG4gICAgICBtYXQuc2V0KHJlc3VsdCwgaSwgaiwgX3ZlY19kb3QobWF0LnJvdyhhLCBpKSwgbWF0LmNvbChiLCBqKSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIG1hdHJpeCBieSBhIHZlY3RvclxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7dmVjMnx2ZWMzfG51bWJlcltdfSBiIFZlY3RvciBiXG4gKiBAcmV0dXJuIHt2ZWMyfHZlYzN8bnVtYmVyW118ZmFsc2V9IGFiIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggYW5kIHZlY3RvciBjYW5ub3QgYmUgbXVsdGlwbGllZFxuICovXG5tYXQubXVsdiA9IChhLCBiKSA9PiB7XG4gIGxldCBuLCBiYiwgcnQ7XG4gIGlmIChfdmVjX2lzX3ZlYzMoYikpIHtcbiAgICBiYiA9IHZlYzMuY29tcG9uZW50cyhiKTtcbiAgICBuID0gMztcbiAgICBydCA9IHZlYzMuZnJvbUNvbXBvbmVudHM7XG4gIH0gZWxzZSBpZiAoX3ZlY19pc192ZWMyKGIpKSB7XG4gICAgYmIgPSB2ZWMyLmNvbXBvbmVudHMoYik7XG4gICAgbiA9IDI7XG4gICAgcnQgPSB2ZWMyLmZyb21Db21wb25lbnRzO1xuICB9IGVsc2Uge1xuICAgIGJiID0gYjtcbiAgICBuID0gYi5sZW5ndGggPz8gMDtcbiAgICBydCA9IHYgPT4gdjtcbiAgfVxuICBpZiAoYS5uICE9PSBuKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYS5tOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChfdmVjX2RvdChtYXQucm93KGEsIGkpLCBiYikpO1xuICB9XG4gIHJldHVybiBydChyZXN1bHQpO1xufVxuXG4vKipcbiAqIFNjYWxlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBNYXRyaXggYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgU2NhbGFyIGJcbiAqIEByZXR1cm4ge21hdH0gYSAqIGJcbiAqL1xubWF0LnNjYWxlID0gKGEsIGIpID0+IG1hdC5tYXAoYSwgdiA9PiB2ICogYik7XG5cbi8qKlxuICogVHJhbnNwb3NlIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IHRvIHRyYW5zcG9zZVxuICogQHJldHVybiB7bWF0fSBBIHRyYW5zcG9zZWQgbWF0cml4XG4gKi9cbm1hdC50cmFucyA9IGEgPT4gbWF0KGEubiwgYS5tLCBfdmVjX3RpbWVzKGkgPT4gbWF0LmNvbChhLCAoaSArIDEpKSwgYS5uKS5mbGF0KCkpO1xuXG4vKipcbiAqIEdldCB0aGUgbWlub3Igb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgcm93IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGogVGhlIGNvbHVtbiBvZmZzZXRcbiAqIEByZXR1cm4ge21hdHxmYWxzZX0gVGhlIChpLCBqKSBtaW5vciBvZiBtYXRyaXggYSBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0Lm1pbm9yID0gKGEsIGksIGopID0+IHtcbiAgaWYgKGEubSAhPT0gYS5uKSB7IHJldHVybiBmYWxzZTsgfVxuICBjb25zdCBlbnRyaWVzID0gW107XG4gIGZvciAobGV0IGlpID0gMTsgaWkgPD0gYS5tOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpKSB7IGNvbnRpbnVlOyB9XG4gICAgZm9yIChsZXQgamogPSAxOyBqaiA8PSBhLm47IGpqKyspIHtcbiAgICAgIGlmIChqaiA9PT0gaikgeyBjb250aW51ZTsgfVxuICAgICAgZW50cmllcy5wdXNoKG1hdC5nZXQoYSwgaWksIGpqKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXQoYS5tIC0gMSwgYS5uIC0gMSwgZW50cmllcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IHxhfCBvciBmYWxzZSBpZiB0aGUgbWF0cml4IGlzIG5vdCBzcXVhcmVcbiAqL1xubWF0LmRldCA9IGEgPT4ge1xuICBpZiAoYS5tICE9PSBhLm4pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChhLm0gPT09IDEpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdO1xuICB9XG4gIGlmIChhLm0gPT09IDIpIHtcbiAgICByZXR1cm4gYS5lbnRyaWVzWzBdICogYS5lbnRyaWVzWzNdIC0gYS5lbnRyaWVzWzFdICogYS5lbnRyaWVzWzJdO1xuICB9XG4gIGxldCB0b3RhbCA9IDAsIHNpZ24gPSAxO1xuICBmb3IgKGxldCBqID0gMTsgaiA8PSBhLm47IGorKykge1xuICAgIHRvdGFsICs9IHNpZ24gKiBhLmVudHJpZXNbaiAtIDFdICogbWF0LmRldChtYXQubWlub3IoYSwgMSwgaikpO1xuICAgIHNpZ24gKj0gLTE7XG4gIH1cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpc2UgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gbm9ybWFsaXNlXG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IF5hIG9yIGZhbHNlIGlmIHRoZSBtYXRyaXggaXMgbm90IHNxdWFyZVxuICovXG5tYXQubm9yID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIHJldHVybiBtYXQubWFwKGEsIGkgPT4gaSAqIGQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFkanVnYXRlIG9mIGEgbWF0cml4XG4gKiBAcGFyYW0ge21hdH0gYSBUaGUgbWF0cml4IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBhZGp1Z2F0ZVxuICogQHJldHVybiB7bWF0fSBUaGUgYWRqdWdhdGUgb2YgYVxuICovXG5tYXQuYWRqID0gYSA9PiB7XG4gIGNvbnN0IG1pbm9ycyA9IG1hdChhLm0sIGEubik7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGEubTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPD0gYS5uOyBqKyspIHtcbiAgICAgIG1hdC5zZXQobWlub3JzLCBpLCBqLCBtYXQuZGV0KG1hdC5taW5vcihhLCBpLCBqKSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb2ZhY3RvcnMgPSBtYXQubWFwKG1pbm9ycywgKHYsIGkpID0+IHYgKiAoaSAlIDIgPyAtMSA6IDEpKTtcbiAgcmV0dXJuIG1hdC50cmFucyhjb2ZhY3RvcnMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludmVyc2Ugb2YgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gaW52ZXJ0XG4gKiBAcmV0dXJuIHttYXR8ZmFsc2V9IGFeLTEgb3IgZmFsc2UgaWYgdGhlIG1hdHJpeCBoYXMgbm8gaW52ZXJzZVxuICovXG5tYXQuaW52ID0gYSA9PiB7XG4gIGlmIChhLm0gIT09IGEubikgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29uc3QgZCA9IG1hdC5kZXQoYSk7XG4gIGlmIChkID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICByZXR1cm4gbWF0LnNjYWxlKG1hdC5hZGooYSksIDEgLyBkKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG1hdHJpY2VzIGFyZSBlcXVhbFxuICogQHBhcmFtIHttYXR9IGEgTWF0cml4IGFcbiAqIEBwYXJhbSB7bWF0fSBiIE1hdHJpeCBiXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1hdHJpY2VzIGEgYW5kIGIgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbm1hdC5lcSA9IChhLCBiKSA9PiBhLm0gPT09IGIubSAmJiBhLm4gPT09IGIubiAmJiBtYXQuc3RyKGEpID09PSBtYXQuc3RyKGIpO1xuXG4vKipcbiAqIENvcHkgYSBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybiB7bWF0fSBBIGNvcHkgb2YgbWF0cml4IGFcbiAqL1xubWF0LmNweSA9IGEgPT4gbWF0KGEubSwgYS5uLCBbLi4uYS5lbnRyaWVzXSk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgYSBtYXRyaXhcbiAqIEBjYWxsYmFjayBtYXRyaXhNYXBDYWxsYmFja1xuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBlbnRyeSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbnRyaWVzIFRoZSBhcnJheSBvZiBtYXRyaXggZW50cmllc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWFwcGVkIGVudHJ5XG4gKi9cblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gb24gZWFjaCBlbnRyeSBvZiBhIG1hdHJpeCBhbmQgYnVpbGQgYSBuZXcgbWF0cml4IGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7bWF0fSBhIE1hdHJpeCBhXG4gKiBAcGFyYW0ge21hdHJpeE1hcENhbGxiYWNrfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggZW50cnkgb2YgdGhlIG1hdHJpeFxuICogQHJldHVybiB7bWF0fSBNYXRyaXggYSBtYXBwZWQgdGhyb3VnaCBmXG4gKi9cbm1hdC5tYXAgPSAoYSwgZikgPT4gbWF0KGEubSwgYS5uLCBhLmVudHJpZXMubWFwKGYpKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbWF0cml4IGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7bWF0fSBhIFRoZSBtYXRyaXggdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IFttcz0nLCAnXSBUaGUgc2VwYXJhdG9yIHN0cmluZyBmb3IgY29sdW1uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtucz0nXFxuJ10gVGhlIHNlcGFyYXRvciBzdHJpbmcgZm9yIHJvd3NcbiAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQuc3RyID0gKGEsIG1zID0gJywgJywgbnMgPSAnXFxuJykgPT4gX3ZlY19jaHVuayhhLmVudHJpZXMsIGEubikubWFwKHIgPT4gci5qb2luKG1zKSkuam9pbihucyk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgdmVjMiwgdmVjMywgbWF0IH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IGV4cG9ydHMudmFsaWRhdGUgPSBleHBvcnRzLnY3ID0gZXhwb3J0cy52NlRvVjEgPSBleHBvcnRzLnY2ID0gZXhwb3J0cy52NSA9IGV4cG9ydHMudjQgPSBleHBvcnRzLnYzID0gZXhwb3J0cy52MVRvVjYgPSBleHBvcnRzLnYxID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnBhcnNlID0gZXhwb3J0cy5OSUwgPSBleHBvcnRzLk1BWCA9IHZvaWQgMDtcbnZhciBtYXhfanNfMSA9IHJlcXVpcmUoXCIuL21heC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1BWFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4X2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBuaWxfanNfMSA9IHJlcXVpcmUoXCIuL25pbC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5JTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmlsX2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnlfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHYxX2pzXzEgPSByZXF1aXJlKFwiLi92MS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYxXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2MV9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjFUb1Y2X2pzXzEgPSByZXF1aXJlKFwiLi92MVRvVjYuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVRvVjZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHYxVG9WNl9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjNfanNfMSA9IHJlcXVpcmUoXCIuL3YzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHYzX2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2NF9qc18xID0gcmVxdWlyZShcIi4vdjQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjRfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHY1X2pzXzEgPSByZXF1aXJlKFwiLi92NS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2NV9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdjZfanNfMSA9IHJlcXVpcmUoXCIuL3Y2LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY2X2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2NlRvVjFfanNfMSA9IHJlcXVpcmUoXCIuL3Y2VG9WMS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY2VG9WMVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjZUb1YxX2pzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciB2N19qc18xID0gcmVxdWlyZShcIi4vdjcuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2N1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjdfanNfMS5kZWZhdWx0OyB9IH0pO1xudmFyIHZhbGlkYXRlX2pzXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZV9qc18xLmRlZmF1bHQ7IH0gfSk7XG52YXIgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb25fanNfMS5kZWZhdWx0OyB9IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAnZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gICAgY29uc3Qgd29yZHMgPSB1aW50OFRvVWludDMyKGJ5dGVzKTtcbiAgICBjb25zdCBtZDVCeXRlcyA9IHdvcmRzVG9NZDUod29yZHMsIGJ5dGVzLmxlbmd0aCAqIDgpO1xuICAgIHJldHVybiB1aW50MzJUb1VpbnQ4KG1kNUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHVpbnQzMlRvVWludDgoaW5wdXQpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAqIDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogNDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gKGlucHV0W2kgPj4gMl0gPj4+ICgoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICAgIHJldHVybiAoKChpbnB1dExlbmd0aDggKyA2NCkgPj4+IDkpIDw8IDQpICsgMTQgKyAxO1xufVxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgICBjb25zdCB4cGFkID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW4pKS5maWxsKDApO1xuICAgIHhwYWQuc2V0KHgpO1xuICAgIHhwYWRbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gICAgeHBhZFt4cGFkLmxlbmd0aCAtIDFdID0gbGVuO1xuICAgIHggPSB4cGFkO1xuICAgIGxldCBhID0gMTczMjU4NDE5MztcbiAgICBsZXQgYiA9IC0yNzE3MzM4Nzk7XG4gICAgbGV0IGMgPSAtMTczMjU4NDE5NDtcbiAgICBsZXQgZCA9IDI3MTczMzg3ODtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIGNvbnN0IG9sZGEgPSBhO1xuICAgICAgICBjb25zdCBvbGRiID0gYjtcbiAgICAgICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgICAgIGNvbnN0IG9sZGQgPSBkO1xuICAgICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgICAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICAgICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICAgIH1cbiAgICByZXR1cm4gVWludDMyQXJyYXkub2YoYSwgYiwgYywgZCk7XG59XG5mdW5jdGlvbiB1aW50OFRvVWludDMyKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KCk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgoaW5wdXQubGVuZ3RoICogOCkpLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXRbaSA+PiAyXSB8PSAoaW5wdXRbaV0gJiAweGZmKSA8PCAoKGkgJSA0KSAqIDgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gICAgY29uc3QgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICAgIGNvbnN0IG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAgIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweGZmZmYpO1xufVxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICAgIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbigoYiAmIGMpIHwgKH5iICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBtZDVjbW4oKGIgJiBkKSB8IChjICYgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbWQ1O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByYW5kb21VVUlEID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQgJiYgY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xuZXhwb3J0cy5kZWZhdWx0ID0geyByYW5kb21VVUlEIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YWxpZGF0ZV9qc18xID0gcmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIik7XG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gICAgaWYgKCEoMCwgdmFsaWRhdGVfanNfMS5kZWZhdWx0KSh1dWlkKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICAgIH1cbiAgICBsZXQgdjtcbiAgICByZXR1cm4gVWludDhBcnJheS5vZigodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0LCAodiA+Pj4gMTYpICYgMHhmZiwgKHYgPj4+IDgpICYgMHhmZiwgdiAmIDB4ZmYsICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDgsIHYgJiAweGZmLCAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gOCwgdiAmIDB4ZmYsICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4LCB2ICYgMHhmZiwgKCh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCkgJiAweGZmLCAodiAvIDB4MTAwMDAwMDAwKSAmIDB4ZmYsICh2ID4+PiAyNCkgJiAweGZmLCAodiA+Pj4gMTYpICYgMHhmZiwgKHYgPj4+IDgpICYgMHhmZiwgdiAmIDB4ZmYpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmZ1bmN0aW9uIHJuZygpIHtcbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgfHwgIWNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRSYW5kb21WYWx1ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBybmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gKHggJiB5KSBeICh+eCAmIHopO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIH1cbn1cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICAgIHJldHVybiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSk7XG59XG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gICAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgICBjb25zdCBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuICAgIGNvbnN0IG5ld0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoICsgMSk7XG4gICAgbmV3Qnl0ZXMuc2V0KGJ5dGVzKTtcbiAgICBuZXdCeXRlc1tieXRlcy5sZW5ndGhdID0gMHg4MDtcbiAgICBieXRlcyA9IG5ld0J5dGVzO1xuICAgIGNvbnN0IGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgICBjb25zdCBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gICAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgICAgICAgIGFycltqXSA9XG4gICAgICAgICAgICAgICAgKGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAoYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAoYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgTVtpXSA9IGFycjtcbiAgICB9XG4gICAgTVtOIC0gMV1bMTRdID0gKChieXRlcy5sZW5ndGggLSAxKSAqIDgpIC8gTWF0aC5wb3coMiwgMzIpO1xuICAgIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgICBNW04gLSAxXVsxNV0gPSAoKGJ5dGVzLmxlbmd0aCAtIDEpICogOCkgJiAweGZmZmZmZmZmO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgICAgIGNvbnN0IFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgICAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgICAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gSFswXTtcbiAgICAgICAgbGV0IGIgPSBIWzFdO1xuICAgICAgICBsZXQgYyA9IEhbMl07XG4gICAgICAgIGxldCBkID0gSFszXTtcbiAgICAgICAgbGV0IGUgPSBIWzRdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICAgICAgICBjb25zdCBUID0gKFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW3RdKSA+Pj4gMDtcbiAgICAgICAgICAgIGUgPSBkO1xuICAgICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgIGEgPSBUO1xuICAgICAgICB9XG4gICAgICAgIEhbMF0gPSAoSFswXSArIGEpID4+PiAwO1xuICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSA+Pj4gMDtcbiAgICAgICAgSFsyXSA9IChIWzJdICsgYykgPj4+IDA7XG4gICAgICAgIEhbM10gPSAoSFszXSArIGQpID4+PiAwO1xuICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoSFswXSA+PiAyNCwgSFswXSA+PiAxNiwgSFswXSA+PiA4LCBIWzBdLCBIWzFdID4+IDI0LCBIWzFdID4+IDE2LCBIWzFdID4+IDgsIEhbMV0sIEhbMl0gPj4gMjQsIEhbMl0gPj4gMTYsIEhbMl0gPj4gOCwgSFsyXSwgSFszXSA+PiAyNCwgSFszXSA+PiAxNiwgSFszXSA+PiA4LCBIWzNdLCBIWzRdID4+IDI0LCBIWzRdID4+IDE2LCBIWzRdID4+IDgsIEhbNF0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2hhMTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bnNhZmVTdHJpbmdpZnkgPSB2b2lkIDA7XG5jb25zdCB2YWxpZGF0ZV9qc18xID0gcmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIik7XG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAgIHJldHVybiAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnRzLnVuc2FmZVN0cmluZ2lmeSA9IHVuc2FmZVN0cmluZ2lmeTtcbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTtcbiAgICBpZiAoISgwLCB2YWxpZGF0ZV9qc18xLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiB1dWlkO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5naWZ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVwZGF0ZVYxU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBybmdfanNfMSA9IHJlcXVpcmUoXCIuL3JuZy5qc1wiKTtcbmNvbnN0IHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuY29uc3QgX3N0YXRlID0ge307XG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIGxldCBieXRlcztcbiAgICBjb25zdCBpc1Y2ID0gb3B0aW9ucz8uX3Y2ID8/IGZhbHNlO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zS2V5cy5sZW5ndGggPT09IDEgJiYgb3B0aW9uc0tleXNbMF0gPT09ICdfdjYnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGJ5dGVzID0gdjFCeXRlcyhvcHRpb25zLnJhbmRvbSA/PyBvcHRpb25zLnJuZz8uKCkgPz8gKDAsIHJuZ19qc18xLmRlZmF1bHQpKCksIG9wdGlvbnMubXNlY3MsIG9wdGlvbnMubnNlY3MsIG9wdGlvbnMuY2xvY2tzZXEsIG9wdGlvbnMubm9kZSwgYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3Qgcm5kcyA9ICgwLCBybmdfanNfMS5kZWZhdWx0KSgpO1xuICAgICAgICB1cGRhdGVWMVN0YXRlKF9zdGF0ZSwgbm93LCBybmRzKTtcbiAgICAgICAgYnl0ZXMgPSB2MUJ5dGVzKHJuZHMsIF9zdGF0ZS5tc2VjcywgX3N0YXRlLm5zZWNzLCBpc1Y2ID8gdW5kZWZpbmVkIDogX3N0YXRlLmNsb2Nrc2VxLCBpc1Y2ID8gdW5kZWZpbmVkIDogX3N0YXRlLm5vZGUsIGJ1Ziwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZiA/PyAoMCwgc3RyaW5naWZ5X2pzXzEudW5zYWZlU3RyaW5naWZ5KShieXRlcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVWMVN0YXRlKHN0YXRlLCBub3csIHJuZHMpIHtcbiAgICBzdGF0ZS5tc2VjcyA/Pz0gLUluZmluaXR5O1xuICAgIHN0YXRlLm5zZWNzID8/PSAwO1xuICAgIGlmIChub3cgPT09IHN0YXRlLm1zZWNzKSB7XG4gICAgICAgIHN0YXRlLm5zZWNzKys7XG4gICAgICAgIGlmIChzdGF0ZS5uc2VjcyA+PSAxMDAwMCkge1xuICAgICAgICAgICAgc3RhdGUubm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHN0YXRlLm5zZWNzID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub3cgPiBzdGF0ZS5tc2Vjcykge1xuICAgICAgICBzdGF0ZS5uc2VjcyA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vdyA8IHN0YXRlLm1zZWNzKSB7XG4gICAgICAgIHN0YXRlLm5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9kZSkge1xuICAgICAgICBzdGF0ZS5ub2RlID0gcm5kcy5zbGljZSgxMCwgMTYpO1xuICAgICAgICBzdGF0ZS5ub2RlWzBdIHw9IDB4MDE7XG4gICAgICAgIHN0YXRlLmNsb2Nrc2VxID0gKChybmRzWzhdIDw8IDgpIHwgcm5kc1s5XSkgJiAweDNmZmY7XG4gICAgfVxuICAgIHN0YXRlLm1zZWNzID0gbm93O1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydHMudXBkYXRlVjFTdGF0ZSA9IHVwZGF0ZVYxU3RhdGU7XG5mdW5jdGlvbiB2MUJ5dGVzKHJuZHMsIG1zZWNzLCBuc2VjcywgY2xvY2tzZXEsIG5vZGUsIGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAgIGlmIChybmRzLmxlbmd0aCA8IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmFuZG9tIGJ5dGVzIGxlbmd0aCBtdXN0IGJlID49IDE2Jyk7XG4gICAgfVxuICAgIGlmICghYnVmKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDE2ID4gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVVSUQgYnl0ZSByYW5nZSAke29mZnNldH06JHtvZmZzZXQgKyAxNX0gaXMgb3V0IG9mIGJ1ZmZlciBib3VuZHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtc2VjcyA/Pz0gRGF0ZS5ub3coKTtcbiAgICBuc2VjcyA/Pz0gMDtcbiAgICBjbG9ja3NlcSA/Pz0gKChybmRzWzhdIDw8IDgpIHwgcm5kc1s5XSkgJiAweDNmZmY7XG4gICAgbm9kZSA/Pz0gcm5kcy5zbGljZSgxMCwgMTYpO1xuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuICAgIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAodGwgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9ICh0bCA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKHRsID4+PiA4KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IHRsICYgMHhmZjtcbiAgICBjb25zdCB0bWggPSAoKG1zZWNzIC8gMHgxMDAwMDAwMDApICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAodG1oID4+PiA4KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IHRtaCAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9ICgodG1oID4+PiAyNCkgJiAweGYpIHwgMHgxMDtcbiAgICBidWZbb2Zmc2V0KytdID0gKHRtaCA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKGNsb2Nrc2VxID4+PiA4KSB8IDB4ODA7XG4gICAgYnVmW29mZnNldCsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgICAgICBidWZbb2Zmc2V0KytdID0gbm9kZVtuXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHYxO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmZ1bmN0aW9uIHYxVG9WNih1dWlkKSB7XG4gICAgY29uc3QgdjFCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBwYXJzZV9qc18xLmRlZmF1bHQpKHV1aWQpIDogdXVpZDtcbiAgICBjb25zdCB2NkJ5dGVzID0gX3YxVG9WNih2MUJ5dGVzKTtcbiAgICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gKDAsIHN0cmluZ2lmeV9qc18xLnVuc2FmZVN0cmluZ2lmeSkodjZCeXRlcykgOiB2NkJ5dGVzO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdjFUb1Y2O1xuZnVuY3Rpb24gX3YxVG9WNih2MUJ5dGVzKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKCh2MUJ5dGVzWzZdICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbN10gPj4gNCkgJiAweDBmKSwgKCh2MUJ5dGVzWzddICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbNF0gJiAweGYwKSA+PiA0KSwgKCh2MUJ5dGVzWzRdICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbNV0gJiAweGYwKSA+PiA0KSwgKCh2MUJ5dGVzWzVdICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbMF0gJiAweGYwKSA+PiA0KSwgKCh2MUJ5dGVzWzBdICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbMV0gJiAweGYwKSA+PiA0KSwgKCh2MUJ5dGVzWzFdICYgMHgwZikgPDwgNCkgfCAoKHYxQnl0ZXNbMl0gJiAweGYwKSA+PiA0KSwgMHg2MCB8ICh2MUJ5dGVzWzJdICYgMHgwZiksIHYxQnl0ZXNbM10sIHYxQnl0ZXNbOF0sIHYxQnl0ZXNbOV0sIHYxQnl0ZXNbMTBdLCB2MUJ5dGVzWzExXSwgdjFCeXRlc1sxMl0sIHYxQnl0ZXNbMTNdLCB2MUJ5dGVzWzE0XSwgdjFCeXRlc1sxNV0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuY29uc3QgbWQ1X2pzXzEgPSByZXF1aXJlKFwiLi9tZDUuanNcIik7XG5jb25zdCB2MzVfanNfMSA9IHJlcXVpcmUoXCIuL3YzNS5qc1wiKTtcbnZhciB2MzVfanNfMiA9IHJlcXVpcmUoXCIuL3YzNS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkROU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdjM1X2pzXzIuRE5TOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVJMXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2MzVfanNfMi5VUkw7IH0gfSk7XG5mdW5jdGlvbiB2Myh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIHJldHVybiAoMCwgdjM1X2pzXzEuZGVmYXVsdCkoMHgzMCwgbWQ1X2pzXzEuZGVmYXVsdCwgdmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpO1xufVxudjMuRE5TID0gdjM1X2pzXzEuRE5TO1xudjMuVVJMID0gdjM1X2pzXzEuVVJMO1xuZXhwb3J0cy5kZWZhdWx0ID0gdjM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVVJMID0gZXhwb3J0cy5ETlMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gICAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLlVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZnVuY3Rpb24gdjM1KHZlcnNpb24sIGhhc2gsIHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgY29uc3QgdmFsdWVCeXRlcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzdHJpbmdUb0J5dGVzKHZhbHVlKSA6IHZhbHVlO1xuICAgIGNvbnN0IG5hbWVzcGFjZUJ5dGVzID0gdHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycgPyAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KShuYW1lc3BhY2UpIDogbmFtZXNwYWNlO1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lc3BhY2UgPSAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlPy5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH1cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlQnl0ZXMubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlQnl0ZXMpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZUJ5dGVzLCBuYW1lc3BhY2VCeXRlcy5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaChieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSAoYnl0ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgaWYgKGJ1Zikge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN0cmluZ2lmeV9qc18xLnVuc2FmZVN0cmluZ2lmeSkoYnl0ZXMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdjM1O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuYXRpdmVfanNfMSA9IHJlcXVpcmUoXCIuL25hdGl2ZS5qc1wiKTtcbmNvbnN0IHJuZ19qc18xID0gcmVxdWlyZShcIi4vcm5nLmpzXCIpO1xuY29uc3Qgc3RyaW5naWZ5X2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIik7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIGlmIChuYXRpdmVfanNfMS5kZWZhdWx0LnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmF0aXZlX2pzXzEuZGVmYXVsdC5yYW5kb21VVUlEKCk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSA/PyBvcHRpb25zLnJuZz8uKCkgPz8gKDAsIHJuZ19qc18xLmRlZmF1bHQpKCk7XG4gICAgaWYgKHJuZHMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYW5kb20gYnl0ZXMgbGVuZ3RoIG11c3QgYmUgPj0gMTYnKTtcbiAgICB9XG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBpZiAoYnVmKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxNiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVVUlEIGJ5dGUgcmFuZ2UgJHtvZmZzZXR9OiR7b2Zmc2V0ICsgMTV9IGlzIG91dCBvZiBidWZmZXIgYm91bmRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc3RyaW5naWZ5X2pzXzEudW5zYWZlU3RyaW5naWZ5KShybmRzKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuY29uc3Qgc2hhMV9qc18xID0gcmVxdWlyZShcIi4vc2hhMS5qc1wiKTtcbmNvbnN0IHYzNV9qc18xID0gcmVxdWlyZShcIi4vdjM1LmpzXCIpO1xudmFyIHYzNV9qc18yID0gcmVxdWlyZShcIi4vdjM1LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRE5TXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2MzVfanNfMi5ETlM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVUkxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHYzNV9qc18yLlVSTDsgfSB9KTtcbmZ1bmN0aW9uIHY1KHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICgwLCB2MzVfanNfMS5kZWZhdWx0KSgweDUwLCBzaGExX2pzXzEuZGVmYXVsdCwgdmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpO1xufVxudjUuRE5TID0gdjM1X2pzXzEuRE5TO1xudjUuVVJMID0gdjM1X2pzXzEuVVJMO1xuZXhwb3J0cy5kZWZhdWx0ID0gdjU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuY29uc3QgdjFfanNfMSA9IHJlcXVpcmUoXCIuL3YxLmpzXCIpO1xuY29uc3QgdjFUb1Y2X2pzXzEgPSByZXF1aXJlKFwiLi92MVRvVjYuanNcIik7XG5mdW5jdGlvbiB2NihvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIG9wdGlvbnMgPz89IHt9O1xuICAgIG9mZnNldCA/Pz0gMDtcbiAgICBsZXQgYnl0ZXMgPSAoMCwgdjFfanNfMS5kZWZhdWx0KSh7IC4uLm9wdGlvbnMsIF92NjogdHJ1ZSB9LCBuZXcgVWludDhBcnJheSgxNikpO1xuICAgIGJ5dGVzID0gKDAsIHYxVG9WNl9qc18xLmRlZmF1bHQpKGJ5dGVzKTtcbiAgICBpZiAoYnVmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzdHJpbmdpZnlfanNfMS51bnNhZmVTdHJpbmdpZnkpKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHY2O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXJzZV9qc18xID0gcmVxdWlyZShcIi4vcGFyc2UuanNcIik7XG5jb25zdCBzdHJpbmdpZnlfanNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKTtcbmZ1bmN0aW9uIHY2VG9WMSh1dWlkKSB7XG4gICAgY29uc3QgdjZCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/ICgwLCBwYXJzZV9qc18xLmRlZmF1bHQpKHV1aWQpIDogdXVpZDtcbiAgICBjb25zdCB2MUJ5dGVzID0gX3Y2VG9WMSh2NkJ5dGVzKTtcbiAgICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnID8gKDAsIHN0cmluZ2lmeV9qc18xLnVuc2FmZVN0cmluZ2lmeSkodjFCeXRlcykgOiB2MUJ5dGVzO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdjZUb1YxO1xuZnVuY3Rpb24gX3Y2VG9WMSh2NkJ5dGVzKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkub2YoKCh2NkJ5dGVzWzNdICYgMHgwZikgPDwgNCkgfCAoKHY2Qnl0ZXNbNF0gPj4gNCkgJiAweDBmKSwgKCh2NkJ5dGVzWzRdICYgMHgwZikgPDwgNCkgfCAoKHY2Qnl0ZXNbNV0gJiAweGYwKSA+PiA0KSwgKCh2NkJ5dGVzWzVdICYgMHgwZikgPDwgNCkgfCAodjZCeXRlc1s2XSAmIDB4MGYpLCB2NkJ5dGVzWzddLCAoKHY2Qnl0ZXNbMV0gJiAweDBmKSA8PCA0KSB8ICgodjZCeXRlc1syXSAmIDB4ZjApID4+IDQpLCAoKHY2Qnl0ZXNbMl0gJiAweDBmKSA8PCA0KSB8ICgodjZCeXRlc1szXSAmIDB4ZjApID4+IDQpLCAweDEwIHwgKCh2NkJ5dGVzWzBdICYgMHhmMCkgPj4gNCksICgodjZCeXRlc1swXSAmIDB4MGYpIDw8IDQpIHwgKCh2NkJ5dGVzWzFdICYgMHhmMCkgPj4gNCksIHY2Qnl0ZXNbOF0sIHY2Qnl0ZXNbOV0sIHY2Qnl0ZXNbMTBdLCB2NkJ5dGVzWzExXSwgdjZCeXRlc1sxMl0sIHY2Qnl0ZXNbMTNdLCB2NkJ5dGVzWzE0XSwgdjZCeXRlc1sxNV0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVwZGF0ZVY3U3RhdGUgPSB2b2lkIDA7XG5jb25zdCBybmdfanNfMSA9IHJlcXVpcmUoXCIuL3JuZy5qc1wiKTtcbmNvbnN0IHN0cmluZ2lmeV9qc18xID0gcmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpO1xuY29uc3QgX3N0YXRlID0ge307XG5mdW5jdGlvbiB2NyhvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIGxldCBieXRlcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBieXRlcyA9IHY3Qnl0ZXMob3B0aW9ucy5yYW5kb20gPz8gb3B0aW9ucy5ybmc/LigpID8/ICgwLCBybmdfanNfMS5kZWZhdWx0KSgpLCBvcHRpb25zLm1zZWNzLCBvcHRpb25zLnNlcSwgYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3Qgcm5kcyA9ICgwLCBybmdfanNfMS5kZWZhdWx0KSgpO1xuICAgICAgICB1cGRhdGVWN1N0YXRlKF9zdGF0ZSwgbm93LCBybmRzKTtcbiAgICAgICAgYnl0ZXMgPSB2N0J5dGVzKHJuZHMsIF9zdGF0ZS5tc2VjcywgX3N0YXRlLnNlcSwgYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmID8/ICgwLCBzdHJpbmdpZnlfanNfMS51bnNhZmVTdHJpbmdpZnkpKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVY3U3RhdGUoc3RhdGUsIG5vdywgcm5kcykge1xuICAgIHN0YXRlLm1zZWNzID8/PSAtSW5maW5pdHk7XG4gICAgc3RhdGUuc2VxID8/PSAwO1xuICAgIGlmIChub3cgPiBzdGF0ZS5tc2Vjcykge1xuICAgICAgICBzdGF0ZS5zZXEgPSAocm5kc1s2XSA8PCAyMykgfCAocm5kc1s3XSA8PCAxNikgfCAocm5kc1s4XSA8PCA4KSB8IHJuZHNbOV07XG4gICAgICAgIHN0YXRlLm1zZWNzID0gbm93O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuc2VxID0gKHN0YXRlLnNlcSArIDEpIHwgMDtcbiAgICAgICAgaWYgKHN0YXRlLnNlcSA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUubXNlY3MrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5leHBvcnRzLnVwZGF0ZVY3U3RhdGUgPSB1cGRhdGVWN1N0YXRlO1xuZnVuY3Rpb24gdjdCeXRlcyhybmRzLCBtc2Vjcywgc2VxLCBidWYsIG9mZnNldCA9IDApIHtcbiAgICBpZiAocm5kcy5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhbmRvbSBieXRlcyBsZW5ndGggbXVzdCBiZSA+PSAxNicpO1xuICAgIH1cbiAgICBpZiAoIWJ1Zikge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxNiA+IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVVUlEIGJ5dGUgcmFuZ2UgJHtvZmZzZXR9OiR7b2Zmc2V0ICsgMTV9IGlzIG91dCBvZiBidWZmZXIgYm91bmRzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbXNlY3MgPz89IERhdGUubm93KCk7XG4gICAgc2VxID8/PSAoKHJuZHNbNl0gKiAweDdmKSA8PCAyNCkgfCAocm5kc1s3XSA8PCAxNikgfCAocm5kc1s4XSA8PCA4KSB8IHJuZHNbOV07XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDAwMDAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMDAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDAwMDAwKSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9IChtc2VjcyAvIDB4MTAwMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gKG1zZWNzIC8gMHgxMDApICYgMHhmZjtcbiAgICBidWZbb2Zmc2V0KytdID0gbXNlY3MgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAweDcwIHwgKChzZXEgPj4+IDI4KSAmIDB4MGYpO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAoc2VxID4+PiAyMCkgJiAweGZmO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAweDgwIHwgKChzZXEgPj4+IDE0KSAmIDB4M2YpO1xuICAgIGJ1ZltvZmZzZXQrK10gPSAoc2VxID4+PiA2KSAmIDB4ZmY7XG4gICAgYnVmW29mZnNldCsrXSA9ICgoc2VxIDw8IDIpICYgMHhmZikgfCAocm5kc1sxMF0gJiAweDAzKTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxMV07XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTJdO1xuICAgIGJ1ZltvZmZzZXQrK10gPSBybmRzWzEzXTtcbiAgICBidWZbb2Zmc2V0KytdID0gcm5kc1sxNF07XG4gICAgYnVmW29mZnNldCsrXSA9IHJuZHNbMTVdO1xuICAgIHJldHVybiBidWY7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2NztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVnZXhfanNfMSA9IHJlcXVpcmUoXCIuL3JlZ2V4LmpzXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICAgIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgcmVnZXhfanNfMS5kZWZhdWx0LnRlc3QodXVpZCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfanNfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpO1xuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gICAgaWYgKCEoMCwgdmFsaWRhdGVfanNfMS5kZWZhdWx0KSh1dWlkKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTUpLCAxNik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJzaW9uO1xuIiwiaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgRGVidWcgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7IExvYWRpbmdTY2VuZSB9IGZyb20gJy4vTG9hZGluZ1NjZW5lJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuL2NvbmZpZy5qc29uJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xuICBwdWJsaWMgc3RhdGljIHNjcmVlbjogdmVjMjtcblxuICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIHByaXZhdGUgY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0RnJhbWVDb3VudFRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBmcmFtZVJhdGU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgZnJhbWVDb3VudDogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdmFsaWQgY29udGFpbmVyIGVsZW1lbnQgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdjYW52YXMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRhaW5lciBlbGVtZW50IG11c3QgYmUgYSBjYW52YXMnKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMgPSBjb250YWluZXIgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgICAvLyBHZXQgYSAyZCBjb250ZXh0XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKGNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhIGNvbnRleHQgZm9yIG1haW4gY2FudmFzJyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHJlc2l6ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplKCkge1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGluaXRpYWxpc2UoKSB7XG4gICAgLy8gSW5pdGlhbGlzZSBzdWJzeXN0ZW1zXG4gICAgQ29udGVudE1hbmFnZXIuaW5pdGlhbGlzZSh7XG4gICAgICBzaW11bGF0ZVNsb3dMb2FkaW5nOiBjb25zdGFudHMuU0lNVUxBVEVfU0xPV19MT0FESU5HLFxuICAgIH0pO1xuICAgIERlYnVnLmluaXRpYWxpc2UoKTtcbiAgICBJbnB1dE1hbmFnZXIuaW5pdGlhbGlzZSgpO1xuICAgIFNjZW5lTWFuYWdlci5pbml0aWFsaXNlKCk7XG5cbiAgICAvLyBTdGFydCBnYW1lIGxvb3BcbiAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aGlzLmxhc3RGcmFtZUNvdW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMubG9vcCgpO1xuXG4gICAgLy8gUHVzaCB0aGUgaW5pdGlhbCBzY2VuZVxuICAgIFNjZW5lTWFuYWdlci5wdXNoKG5ldyBMb2FkaW5nU2NlbmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGxvb3AoKSB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBNYXRoLm1pbihub3cgLSB0aGlzLmxhc3RGcmFtZVRpbWUsIGNvbnN0YW50cy5GUFNfTUlOKTtcblxuICAgIC8vIENhbGN1bGF0ZSBmcmFtZXJhdGVcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RnJhbWVDb3VudFRpbWUgPj0gMTAwMCkge1xuICAgICAgdGhpcy5sYXN0RnJhbWVDb3VudFRpbWUgPSBub3c7XG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IHRoaXMuZnJhbWVDb3VudDtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgfVxuICAgIHRoaXMuZnJhbWVDb3VudCsrO1xuICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IG5vdztcbiAgICBpZiAoY29uZmlnLnNob3dGUFMpIHtcbiAgICAgIERlYnVnLnZhbHVlKCdGUFMnLCB0aGlzLmZyYW1lUmF0ZSwgeyBhbGlnbjogJ3JpZ2h0JyB9KTtcbiAgICB9XG5cbiAgICAvLyBEbyBnYW1lIGxvb3BcbiAgICB0aGlzLnVwZGF0ZShlbGFwc2VkVGltZSk7XG4gICAgdGhpcy5kcmF3KCk7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmxvb3AuYmluZCh0aGlzKSk7XG4gIH1cblxuICB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIEdhbWUuc2NyZWVuID0gdmVjMih0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgIERlYnVnLnZhbHVlKCdzdGF0dXMnLCBDb250ZW50TWFuYWdlci5zdGF0dXMpO1xuICAgIERlYnVnLnZhbHVlKCdwcm9ncmVzcycsIENvbnRlbnRNYW5hZ2VyLnByb2dyZXNzKTtcblxuICAgIFNjZW5lTWFuYWdlci51cGRhdGUoZHQpO1xuICAgIElucHV0TWFuYWdlci51cGRhdGUoKTsgLy8gSW5wdXQgbWFuYWdlciBzaG91bGQgYmUgdXBkYXRlZCBsYXN0XG4gIH1cblxuICBkcmF3KCkge1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG5cbiAgICBTY2VuZU1hbmFnZXIuZHJhdyh0aGlzLmNvbnRleHQpO1xuICAgIERlYnVnLmRyYXcodGhpcy5jb250ZXh0KTtcbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgSW5wdXRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2lucHV0LW1hbmFnZXInO1xuaW1wb3J0IFNjZW5lTWFuYWdlciwge1xuICBTY2VuZSxcbiAgU2NlbmVUcmFuc2l0aW9uU3RhdGUsXG59IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3NjZW5lLW1hbmFnZXInO1xuaW1wb3J0IHsgdmVjMiB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3ZlYyc7XG5pbXBvcnQgR2FtZSBmcm9tICcuL0dhbWUnO1xuaW1wb3J0IExldmVsIGZyb20gJy4vTGV2ZWwnO1xuXG5leHBvcnQgY2xhc3MgR2FtZVNjZW5lIGV4dGVuZHMgU2NlbmUge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNDUkVFTl9XSURUSF9QUk9EVUNUUyA9IDEyO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBUUkFOU0lUSU9OX1RJTUU6IG51bWJlciA9IDE7XG5cbiAgcHJpdmF0ZSB0aW1lOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuICBwcml2YXRlIGxldmVsOiBMZXZlbDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNpdGlvblRpbWU6IEdhbWVTY2VuZS5UUkFOU0lUSU9OX1RJTUUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZShsZXZlbElkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEodmVjMigpKTtcblxuICAgIC8vIExvYWQgbGV2ZWxcbiAgICBjb25zdCBsZXZlbERhdGEgPSBDb250ZW50TWFuYWdlci5nZXQobGV2ZWxJZCk7XG4gICAgaWYgKCFsZXZlbERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGV2ZWwgZGF0YSBmb3IgJyR7bGV2ZWxJZH0nIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICB0aGlzLmxldmVsID0gTGV2ZWwuZnJvbURhdGEobGV2ZWxEYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlcikge1xuICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIC8vIFRFTVA6IHJlc2V0IHRoZSBnYW1lIHNjZW5lIHdoZW4gRXNjYXBlIGlzIHByZXNzZWRcbiAgICBpZiAoSW5wdXRNYW5hZ2VyLmtleVByZXNzZWQoJ0VzY2FwZScpKSB7XG4gICAgICBTY2VuZU1hbmFnZXIucG9wKCk7XG4gICAgICBTY2VuZU1hbmFnZXIucHVzaChuZXcgR2FtZVNjZW5lKCksIHRoaXMubGV2ZWwuZGF0YS5pZCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbC51cGRhdGUoZHQsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25TdGF0ZSAhPT0gU2NlbmVUcmFuc2l0aW9uU3RhdGUuTm9uZSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMudHJhbnNpdGlvbkFtb3VudDtcbiAgICB9XG5cbiAgICAvLyBCYWNrZ3JvdW5kXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2NjYyc7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBHYW1lLnNjcmVlbi54LCBHYW1lLnNjcmVlbi55KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgLy8gUmVuZGVyIGxldmVsIGluIHdvcmxkLXNwYWNlXG4gICAgdGhpcy5jYW1lcmEuZHJhdyhjb250ZXh0LCBHYW1lLnNjcmVlbik7XG4gICAgdGhpcy5sZXZlbC5kcmF3KGNvbnRleHQsIHRoaXMuY2FtZXJhKTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYSc7XG5pbXBvcnQgRGVidWcgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvZGVidWcnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCB7IGlzVmVjMiB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzL3V0aWxpdGllcyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7XG4gIEFjdG9yLFxuICBDYXJvdXNlbCxcbiAgQ29sbGFwc2UsXG4gIFByb2R1Y3QsXG4gIFNoZWxmLFxuICBTaGVsZlByb2R1Y3RzLFxufSBmcm9tICcuL2FjdG9ycyc7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgUHJvZHVjdEZhY3RvcnkgfSBmcm9tICcuL1Byb2R1Y3RGYWN0b3J5JztcbmltcG9ydCB7IFNoZWxmRmFjdG9yeSB9IGZyb20gJy4vU2hlbGZGYWN0b3J5JztcblxuZXhwb3J0IHR5cGUgTGV2ZWxEYXRhID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBncmlkOiB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgfTtcbiAgbG9ja2VkUHJvZHVjdHM/OiB7XG4gICAgc2hlbGZSZWZlcmVuY2U6IG51bWJlcjtcbiAgICBzbG90OiBudW1iZXI7XG4gIH1bXTtcbiAgYWN0b3JzOiB7XG4gICAgZ3JpZFBvc2l0aW9uOiB2ZWMyO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIH1bXTtcbiAgdGltZUxpbWl0PzogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGV2ZWxEYXRhKGRhdGE6IGFueSk6IGRhdGEgaXMgTGV2ZWxEYXRhIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgZGF0YS5pZCA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgZGF0YS5uYW1lID09PSAnc3RyaW5nJyAmJlxuICAgIChkYXRhLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEuZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnKSAmJlxuICAgIHR5cGVvZiBkYXRhLmdyaWQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGRhdGEuZ3JpZC53aWR0aCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgZGF0YS5ncmlkLmhlaWdodCA9PT0gJ251bWJlcicgJiZcbiAgICAoZGF0YS5sb2NrZWRQcm9kdWN0cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoQXJyYXkuaXNBcnJheShkYXRhLmxvY2tlZFByb2R1Y3RzKSAmJlxuICAgICAgICBkYXRhLmxvY2tlZFByb2R1Y3RzLmV2ZXJ5KFxuICAgICAgICAgIChsb2NrZWRQcm9kdWN0OiBhbnkpID0+XG4gICAgICAgICAgICB0eXBlb2YgbG9ja2VkUHJvZHVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBsb2NrZWRQcm9kdWN0LnNoZWxmUmVmZXJlbmNlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGxvY2tlZFByb2R1Y3Quc2xvdCA9PT0gJ251bWJlcidcbiAgICAgICAgKSkpICYmXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLmFjdG9ycykgJiZcbiAgICBkYXRhLmFjdG9ycy5ldmVyeShcbiAgICAgIChhY3RvcjogYW55KSA9PlxuICAgICAgICB0eXBlb2YgYWN0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGlzVmVjMihhY3Rvci5ncmlkUG9zaXRpb24pICYmXG4gICAgICAgIHR5cGVvZiBhY3Rvci50eXBlID09PSAnc3RyaW5nJ1xuICAgICkgJiZcbiAgICAoZGF0YS50aW1lTGltaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZGF0YS50aW1lTGltaXQgPT09ICdudW1iZXInKVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXZlbCB7XG4gIHB1YmxpYyBkYXRhOiBMZXZlbERhdGE7XG4gIHByaXZhdGUgYWN0b3JzOiB7XG4gICAgZ3JpZFBvc2l0aW9uOiB2ZWMyO1xuICAgIGFjdG9yOiBBY3RvcjtcbiAgfVtdID0gW107XG4gIHByaXZhdGUgZHJhZ2dpbmdQcm9kdWN0OiB7XG4gICAgc2hlbGY6IFNoZWxmO1xuICAgIHNsb3RJbmRleDogbnVtYmVyO1xuICAgIHByb2R1Y3Q6IFByb2R1Y3Q7XG4gIH0gfCBudWxsID0gbnVsbDtcblxuICBwdWJsaWMgc2hlbHZlczogU2hlbGZbXSA9IFtdO1xuICBwdWJsaWMgY29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBzdGF0czoge1xuICAgIC8qKlxuICAgICAqIFRvdGFsIHRpbWUgc3BlbnQgb24gdGhpcyBsZXZlbCwgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHRpbWU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBtYXRjaGVzIG1hZGUsIGluZGV4ZWQgYnkgcHJvZHVjdCBpZFxuICAgICAqL1xuICAgIHByb2R1Y3RNYXRjaGVzOiBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICB7XG4gICAgICAgIHByb2R1Y3Q6IFByb2R1Y3Q7XG4gICAgICAgIHRvdGFsOiBudW1iZXI7XG4gICAgICB9XG4gICAgPjtcblxuICAgIC8qKlxuICAgICAqIFRvdGFsIG51bWJlciBvZiBtYXRjaGVzIG1hZGUgYWNyb3NzIGFsbCBwcm9kdWN0c1xuICAgICAqL1xuICAgIHRvdGFsTWF0Y2hlczogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IGNvbXBsZXRlZCBzaGVsdmVzLCBpbmRleGVkIGJ5IHNoZWxmIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICogT25seSBzaGVsdmVzIHdpdGggYSByZWZlcmVuY2UgYXJlIHRyYWNrZWRcbiAgICAgKi9cbiAgICBjb21wbGV0ZWRTaGVsdmVzOiBSZWNvcmQ8XG4gICAgICBzdHJpbmcsXG4gICAgICB7XG4gICAgICAgIHNoZWxmOiBTaGVsZjtcbiAgICAgICAgY29tcGxldGVkOiBib29sZWFuO1xuICAgICAgfVxuICAgID47XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCBudW1iZXIgb2Ygc2hlbHZlcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICB0b3RhbENvbXBsZXRlZFNoZWx2ZXM6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbGwgcHJvZHVjdCBwbGFjZW1lbnRzIG1hZGUgYnkgdGhlIHBsYXllclxuICAgICAqXG4gICAgICogT25seSBzaGVsdmVzIHdpdGggYSByZWZlcmVuY2UgYXJlIHRyYWNrZWRcbiAgICAgKi9cbiAgICBwcm9kdWN0UGxhY2VtZW50czoge1xuICAgICAgc2hlbGY6IFNoZWxmO1xuICAgICAgc2xvdDogbnVtYmVyO1xuICAgICAgcHJvZHVjdDogUHJvZHVjdDtcbiAgICB9W107XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHByb2R1Y3QgcGxhY2VtZW50cywgaW5kZXhlZCBieSBzaGVsZiByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqIE9ubHkgc2hlbHZlcyB3aXRoIGEgcmVmZXJlbmNlIGFyZSB0cmFja2VkXG4gICAgICovXG4gICAgY3VycmVudFByb2R1Y3RQbGFjZW1lbnQ6IFJlY29yZDxcbiAgICAgIHN0cmluZyxcbiAgICAgIHtcbiAgICAgICAgc2hlbGY6IFNoZWxmO1xuICAgICAgICBwcm9kdWN0czogU2hlbGZQcm9kdWN0cztcbiAgICAgIH1cbiAgICA+O1xuICB9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihkYXRhOiBMZXZlbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZGF0YS5hY3RvcnMuZm9yRWFjaChhY3RvckRhdGEgPT4ge1xuICAgICAgdGhpcy5hY3RvcnMucHVzaCh7XG4gICAgICAgIGdyaWRQb3NpdGlvbjogYWN0b3JEYXRhLmdyaWRQb3NpdGlvbixcbiAgICAgICAgYWN0b3I6IHRoaXMuY3JlYXRlQWN0b3IoYWN0b3JEYXRhLnR5cGUsIGFjdG9yRGF0YSksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEFwcGx5IHByb2R1Y3QgbG9ja2luZ1xuICAgIGNvbnN0IHNoZWx2ZXNXaXRoUmVmZXJlbmNlID0gdGhpcy5zaGVsdmVzLmZpbHRlcihcbiAgICAgIHNoZWxmID0+IHNoZWxmLnJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgICBjb25zdCBzaGVsdmVzQnlSZWZlcmVuY2U6IFJlY29yZDxzdHJpbmcsIFNoZWxmPiA9XG4gICAgICBzaGVsdmVzV2l0aFJlZmVyZW5jZS5yZWR1Y2UoXG4gICAgICAgIChhY2MsIHNoZWxmKSA9PiAoe1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbc2hlbGYucmVmZXJlbmNlIV06IHNoZWxmLFxuICAgICAgICB9KSxcbiAgICAgICAge31cbiAgICAgICk7XG4gICAgaWYgKHRoaXMuZGF0YS5sb2NrZWRQcm9kdWN0cykge1xuICAgICAgdGhpcy5kYXRhLmxvY2tlZFByb2R1Y3RzLmZvckVhY2gobG9jayA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2hlbGZSZWZlcmVuY2UsIHNsb3QgfSA9IGxvY2s7XG4gICAgICAgIGlmICghc2hlbHZlc0J5UmVmZXJlbmNlW3NoZWxmUmVmZXJlbmNlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzaGVsdmVzQnlSZWZlcmVuY2Vbc2hlbGZSZWZlcmVuY2VdLmxvY2tQcm9kdWN0QXRJbmRleChzbG90KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpc2Ugc3RhdHNcbiAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIHByb2R1Y3RNYXRjaGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFByb2R1Y3RGYWN0b3J5LnByb2R1Y3RJZHMubWFwKGlkID0+IFtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm9kdWN0OiBQcm9kdWN0RmFjdG9yeS5jcmVhdGVQcm9kdWN0KHRoaXMsIGlkKSxcbiAgICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgdG90YWxNYXRjaGVzOiAwLFxuICAgICAgY29tcGxldGVkU2hlbHZlczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBzaGVsdmVzV2l0aFJlZmVyZW5jZS5tYXAoc2hlbGYgPT4gW1xuICAgICAgICAgIHNoZWxmLnJlZmVyZW5jZSxcbiAgICAgICAgICB7IHNoZWxmLCBjb21wbGV0ZWQ6IGZhbHNlIH0sXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgICAgdG90YWxDb21wbGV0ZWRTaGVsdmVzOiAwLFxuICAgICAgcHJvZHVjdFBsYWNlbWVudHM6IFtdLFxuICAgICAgY3VycmVudFByb2R1Y3RQbGFjZW1lbnQ6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhzaGVsdmVzQnlSZWZlcmVuY2UpLm1hcChzaGVsZiA9PiBbXG4gICAgICAgICAgc2hlbGYsXG4gICAgICAgICAgc2hlbGYucHJvZHVjdHMubWFwKChwcm9kdWN0LCBzbG90KSA9PiAoe1xuICAgICAgICAgICAgc2hlbGYsXG4gICAgICAgICAgICBzbG90LFxuICAgICAgICAgICAgcHJvZHVjdCxcbiAgICAgICAgICB9KSksXG4gICAgICAgIF0pXG4gICAgICApLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EYXRhKGRhdGE6IGFueSk6IExldmVsIHtcbiAgICBpZiAoIWlzTGV2ZWxEYXRhKGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGV2ZWwgZGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExldmVsKGRhdGEpO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZUFjdG9yKHR5cGU6IHN0cmluZywgZGF0YTogYW55KTogQWN0b3Ige1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc2hlbGYnOlxuICAgICAgY2FzZSAnY2xvc2luZy1zaGVsZic6XG4gICAgICBjYXNlICdzdXBwbHktc2hlbGYnOlxuICAgICAgY2FzZSAnZGlzYXBwZWFyaW5nLXNoZWxmJzpcbiAgICAgIGNhc2UgJ2RlZXAtc2hlbGYnOlxuICAgICAgY2FzZSAnZGlzcGxheS1zaGVsZic6XG4gICAgICBjYXNlICdsb2NraW5nLXNoZWxmJzpcbiAgICAgICAgcmV0dXJuIFNoZWxmRmFjdG9yeS5jcmVhdGVTaGVsZih0aGlzLCBkYXRhKTtcblxuICAgICAgY2FzZSAnY2Fyb3VzZWwnOlxuICAgICAgICByZXR1cm4gQ2Fyb3VzZWwuZnJvbURhdGEodGhpcywgZGF0YSk7XG5cbiAgICAgIGNhc2UgJ2NvbGxhcHNlJzpcbiAgICAgICAgcmV0dXJuIENvbGxhcHNlLmZyb21EYXRhKHRoaXMsIGRhdGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0b3IgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyLCBjYW1lcmE6IENhbWVyYSkge1xuICAgIGNvbnN0IHByb2R1Y3RTaXplID0gUHJvZHVjdC5jYWxjdWxhdGVTaXplKCk7XG4gICAgY29uc3QgZ3JpZFNpemVQaXhlbHMgPSB2ZWMyKFxuICAgICAgdGhpcy5kYXRhLmdyaWQud2lkdGggKiBwcm9kdWN0U2l6ZS54LFxuICAgICAgdGhpcy5kYXRhLmdyaWQuaGVpZ2h0ICogcHJvZHVjdFNpemUueVxuICAgICk7XG4gICAgY29uc3QgZ3JpZFRvcExlZnQgPSB2ZWMyLm11bChncmlkU2l6ZVBpeGVscywgLTAuNSk7XG5cbiAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKCh7IGFjdG9yLCBncmlkUG9zaXRpb24gfSkgPT4ge1xuICAgICAgYWN0b3IucG9zaXRpb24gPSB2ZWMyLmFkZChcbiAgICAgICAgZ3JpZFRvcExlZnQsXG4gICAgICAgIHZlYzIubXVsKGdyaWRQb3NpdGlvbiwgcHJvZHVjdFNpemUpXG4gICAgICApO1xuXG4gICAgICAvLyBJZiB0aGUgYWN0b3IgaGFzIGFuIG9mZnNldCwgYXBwbHkgaXQgbm93XG4gICAgICBpZiAoJ29mZnNldCcgaW4gYWN0b3IgJiYgYWN0b3Iub2Zmc2V0KSB7XG4gICAgICAgIGFjdG9yLnBvc2l0aW9uID0gdmVjMi5hZGQoXG4gICAgICAgICAgYWN0b3IucG9zaXRpb24sXG4gICAgICAgICAgdmVjMi5tdWwoYWN0b3Iub2Zmc2V0IGFzIHZlYzIsIHByb2R1Y3RTaXplKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYWN0b3IudXBkYXRlKGR0LCB0aGlzLCBjYW1lcmEpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFJbnB1dE1hbmFnZXIubW91c2VEb3duKCkgJiYgdGhpcy5kcmFnZ2luZ1Byb2R1Y3QpIHtcbiAgICAgIHRoaXMuZmluaXNoRHJhZ2dpbmdQcm9kdWN0KCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxsIHNoZWx2ZXMgYXJlIGNvbXBsZXRlZFxuICAgIGlmIChcbiAgICAgICF0aGlzLmNvbXBsZXRlZCAmJlxuICAgICAgdGhpcy5zaGVsdmVzLmV2ZXJ5KHNoZWxmID0+IHNoZWxmLmlnbm9yZSB8fCBzaGVsZi5zaGVsZklzQ29tcGxldGUoKSlcbiAgICApIHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCdBbGwgc2hlbHZlcyBjb21wbGV0ZWQhJyk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGRpc3Bvc2VkIGFjdG9ycyBhbmQgc2hlbHZlc1xuICAgIHRoaXMuYWN0b3JzID0gdGhpcy5hY3RvcnMuZmlsdGVyKCh7IGFjdG9yIH0pID0+ICFhY3Rvci5kaXNwb3NlZCk7XG4gICAgdGhpcy5zaGVsdmVzID0gdGhpcy5zaGVsdmVzLmZpbHRlcihzaGVsZiA9PiAhc2hlbGYuZGlzcG9zZWQpO1xuXG4gICAgLy8gVXBkYXRlIHN0YXRzXG4gICAgY29uc3Qgc2hlbHZlc1dpdGhSZWZlcmVuY2UgPSB0aGlzLnNoZWx2ZXMuZmlsdGVyKHNoZWxmID0+IHNoZWxmLnJlZmVyZW5jZSk7XG4gICAgdGhpcy5zdGF0cy50aW1lICs9IGR0O1xuICAgIHRoaXMuc3RhdHMuY29tcGxldGVkU2hlbHZlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHNoZWx2ZXNXaXRoUmVmZXJlbmNlLm1hcChzaGVsZiA9PiBbXG4gICAgICAgIHNoZWxmLnJlZmVyZW5jZSxcbiAgICAgICAgeyBzaGVsZiwgY29tcGxldGVkOiBzaGVsZi5zaGVsZklzQ29tcGxldGUoKSB9LFxuICAgICAgXSlcbiAgICApO1xuICAgIHRoaXMuc3RhdHMuY3VycmVudFByb2R1Y3RQbGFjZW1lbnQgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBzaGVsdmVzV2l0aFJlZmVyZW5jZS5tYXAoc2hlbGYgPT4gW1xuICAgICAgICBzaGVsZi5yZWZlcmVuY2UsXG4gICAgICAgIHtcbiAgICAgICAgICBzaGVsZixcbiAgICAgICAgICBwcm9kdWN0czogc2hlbGYucHJvZHVjdHMsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnREcmFnZ2luZ1Byb2R1Y3QoXG4gICAgc2hlbGY6IFNoZWxmLFxuICAgIHNsb3RJbmRleDogbnVtYmVyLFxuICAgIHByb2R1Y3Q6IFByb2R1Y3RcbiAgKSB7XG4gICAgdGhpcy5kcmFnZ2luZ1Byb2R1Y3QgPSB7XG4gICAgICBzaGVsZixcbiAgICAgIHNsb3RJbmRleCxcbiAgICAgIHByb2R1Y3QsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZmluaXNoRHJhZ2dpbmdQcm9kdWN0KCkge1xuICAgIGlmICghdGhpcy5kcmFnZ2luZ1Byb2R1Y3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmlzVmFsaWREcm9wUG9zaXRpb24odGhpcy5kcmFnZ2luZ1Byb2R1Y3QucHJvZHVjdCk7XG4gICAgaWYgKHJlc3VsdC52YWxpZCAmJiByZXN1bHQuc2hlbGYgJiYgcmVzdWx0LnNsb3RJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nUHJvZHVjdC5zaGVsZi5yZW1vdmVQcm9kdWN0QXRJbmRleChcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1Byb2R1Y3Quc2xvdEluZGV4XG4gICAgICApO1xuICAgICAgcmVzdWx0LnNoZWxmLmFkZFByb2R1Y3RBdEluZGV4KFxuICAgICAgICByZXN1bHQuc2xvdEluZGV4LFxuICAgICAgICB0aGlzLmRyYWdnaW5nUHJvZHVjdC5wcm9kdWN0XG4gICAgICApO1xuXG4gICAgICAvLyBVcGRhdGUgc3RhdHNcbiAgICAgIGlmIChyZXN1bHQuc2hlbGYucmVmZXJlbmNlKSB7XG4gICAgICAgIHRoaXMuc3RhdHMucHJvZHVjdFBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgc2hlbGY6IHJlc3VsdC5zaGVsZixcbiAgICAgICAgICBzbG90OiByZXN1bHQuc2xvdEluZGV4LFxuICAgICAgICAgIHByb2R1Y3Q6IHRoaXMuZHJhZ2dpbmdQcm9kdWN0LnByb2R1Y3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZHJhZ2dpbmdQcm9kdWN0LnByb2R1Y3QuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRyYWdnaW5nUHJvZHVjdCA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIGlzVmFsaWREcm9wUG9zaXRpb24ocHJvZHVjdDogUHJvZHVjdCk6IHtcbiAgICB2YWxpZDogYm9vbGVhbjtcbiAgICBzaGVsZj86IFNoZWxmO1xuICAgIHNsb3RJbmRleD86IG51bWJlcjtcbiAgfSB7XG4gICAgY29uc3QgcmVzdWx0czogKFJldHVyblR5cGU8U2hlbGZbJ2ZpbmRTaGVsZlNsb3QnXT4gJiB7XG4gICAgICBzaGVsZjogU2hlbGY7XG4gICAgfSlbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzaGVsZiBvZiB0aGlzLnNoZWx2ZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNoZWxmLmZpbmRTaGVsZlNsb3QocHJvZHVjdCk7XG4gICAgICBpZiAocmVzdWx0LnZhbGlkKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgc2hlbGYsXG4gICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRzLnNvcnQoKGEsIGIpID0+IChhLmRpc3RhbmNlID8/IDApIC0gKGIuZGlzdGFuY2UgPz8gMCkpO1xuICAgIGNvbnN0IGNsb3Nlc3RSZXN1bHQgPSByZXN1bHRzWzBdO1xuXG4gICAgaWYgKFxuICAgICAgY2xvc2VzdFJlc3VsdCAmJlxuICAgICAgY2xvc2VzdFJlc3VsdC52YWxpZCAmJlxuICAgICAgY2xvc2VzdFJlc3VsdC5zbG90SW5kZXggIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIHNoZWxmOiBjbG9zZXN0UmVzdWx0LnNoZWxmLFxuICAgICAgICBzbG90SW5kZXg6IGNsb3Nlc3RSZXN1bHQuc2xvdEluZGV4LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBpZiAoY29uc3RhbnRzLkRFQlVHKSB7XG4gICAgICBjb25zdCBwcm9kdWN0U2l6ZSA9IFByb2R1Y3QuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgY29uc3QgZ3JpZFNpemVQaXhlbHMgPSB2ZWMyKFxuICAgICAgICB0aGlzLmRhdGEuZ3JpZC53aWR0aCAqIHByb2R1Y3RTaXplLngsXG4gICAgICAgIHRoaXMuZGF0YS5ncmlkLmhlaWdodCAqIHByb2R1Y3RTaXplLnlcbiAgICAgICk7XG4gICAgICBjb25zdCBncmlkVG9wTGVmdCA9IGNhbWVyYS53b3JsZFRvU2NyZWVuKHZlYzIubXVsKGdyaWRTaXplUGl4ZWxzLCAtMC41KSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZGF0YS5ncmlkLndpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmRhdGEuZ3JpZC5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIERlYnVnLmJvcmRlcihcbiAgICAgICAgICAgIGBncmlkLSR7eH0tJHt5fS1ib3JkZXJgLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICB2ZWMyLmFkZChncmlkVG9wTGVmdCwgdmVjMi5tdWwodmVjMih4LCB5KSwgcHJvZHVjdFNpemUpKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2l6ZTogcHJvZHVjdFNpemUsXG4gICAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2UsXG4gICAgICAgICAgICAgIHNob3dWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG91cjogJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICAgICAgYm9yZGVyU3R5bGU6ICdkYXNoZWQnLFxuICAgICAgICAgICAgICBzcGFjZTogJ3NjcmVlbicsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWN0b3JzLmZvckVhY2goKHsgYWN0b3IgfSkgPT4ge1xuICAgICAgYWN0b3IuZHJhdyhjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmRyYWdnaW5nUHJvZHVjdCkge1xuICAgICAgdGhpcy5kcmFnZ2luZ1Byb2R1Y3QucHJvZHVjdC5kcmF3KGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENvbnRlbnRNYW5hZ2VyIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NvbnRlbnQtbWFuYWdlcic7XG5pbXBvcnQgU2NlbmVNYW5hZ2VyLCB7XG4gIFNjZW5lLFxuICBTY2VuZVRyYW5zaXRpb25TdGF0ZSxcbn0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2Uvc2NlbmUtbWFuYWdlcic7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBjb250ZW50IGZyb20gJy4uL2NvbnRlbnQvY29udGVudC1jb21waWxlZC5qc29uJztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgR2FtZSBmcm9tICcuL0dhbWUnO1xuaW1wb3J0IHsgR2FtZVNjZW5lIH0gZnJvbSAnLi9HYW1lU2NlbmUnO1xuaW1wb3J0IHsgUHJvZHVjdEZhY3RvcnkgfSBmcm9tICcuL1Byb2R1Y3RGYWN0b3J5JztcblxuZXhwb3J0IGNsYXNzIExvYWRpbmdTY2VuZSBleHRlbmRzIFNjZW5lIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVFJBTlNJVElPTl9USU1FOiBudW1iZXIgPSAwLjU7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPT0xET1dOX1RJTUU6IG51bWJlciA9IDIuNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgREVCVUdfQ09PTERPV05fVElNRTogbnVtYmVyID0gMC41O1xuXG4gIHByaXZhdGUgZmluaXNoZWRMb2FkaW5nQ29udGVudDogYm9vbGVhbjtcblxuICBwcml2YXRlIHByb2dyZXNzQmFyOiB7XG4gICAgcG9zaXRpb246IHZlYzI7XG4gICAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgfTtcblxuICBwcml2YXRlIGNvb2xkb3duVGltZTogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNpdGlvblRpbWU6IExvYWRpbmdTY2VuZS5UUkFOU0lUSU9OX1RJTUUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGlzZSgpIHtcbiAgICB0aGlzLmZpbmlzaGVkTG9hZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnByb2dyZXNzQmFyID0geyBwb3NpdGlvbjogdmVjMigpLCBwcm9ncmVzczogMCB9O1xuICAgIHRoaXMuY29vbGRvd25UaW1lID0gY29uc3RhbnRzLkRFQlVHXG4gICAgICA/IExvYWRpbmdTY2VuZS5ERUJVR19DT09MRE9XTl9USU1FXG4gICAgICA6IExvYWRpbmdTY2VuZS5DT09MRE9XTl9USU1FO1xuXG4gICAgQ29udGVudE1hbmFnZXIubG9hZChjb250ZW50KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBQcm9kdWN0RmFjdG9yeS5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWRMb2FkaW5nQ29udGVudCA9IHRydWU7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcjogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0YW50cy5ERUJVRyAmJiBjb25zb2xlLmxvZyhgVW5hYmxlIHRvIGxvYWQgY29udGVudDogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyKSB7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5wb3NpdGlvbiA9IHZlYzIubWFwKFxuICAgICAgdmVjMi5tdWwoR2FtZS5zY3JlZW4sIDEgLyAyKSxcbiAgICAgIE1hdGguZmxvb3JcbiAgICApO1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIucHJvZ3Jlc3MgPSBDb250ZW50TWFuYWdlci5wcm9ncmVzcztcbiAgICBpZiAodGhpcy5maW5pc2hlZExvYWRpbmdDb250ZW50KSB7XG4gICAgICB0aGlzLmNvb2xkb3duVGltZSAtPSBkdDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb29sZG93blRpbWUgPD0gMCkge1xuICAgICAgU2NlbmVNYW5hZ2VyLnBvcCgpO1xuICAgICAgU2NlbmVNYW5hZ2VyLnB1c2gobmV3IEdhbWVTY2VuZSgpLCAndGVzdC03LWNvbGxhcHNlJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvblN0YXRlICE9PSBTY2VuZVRyYW5zaXRpb25TdGF0ZS5Ob25lKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy50cmFuc2l0aW9uQW1vdW50O1xuICAgIH1cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgIHRoaXMucHJvZ3Jlc3NCYXIucG9zaXRpb24ueCxcbiAgICAgIHRoaXMucHJvZ3Jlc3NCYXIucG9zaXRpb24ueSxcbiAgICAgIHRoaXMucHJvZ3Jlc3NCYXIucHJvZ3Jlc3MgKiAxMDAsXG4gICAgICAyMFxuICAgICk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsImltcG9ydCBDb250ZW50TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jb250ZW50LW1hbmFnZXInO1xuaW1wb3J0IHsgaXNQcm9kdWN0RGF0YSwgUHJvZHVjdCwgUHJvZHVjdERhdGEgfSBmcm9tICcuL2FjdG9ycy9Qcm9kdWN0JztcbmltcG9ydCBMZXZlbCBmcm9tICcuL0xldmVsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvZHVjdHNEYXRhKGRhdGE6IGFueSk6IGRhdGEgaXMgUHJvZHVjdERhdGFbXSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLmV2ZXJ5KChkYXR1bTogYW55KSA9PiBpc1Byb2R1Y3REYXRhKGRhdHVtKSlcbiAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFByb2R1Y3RGYWN0b3J5IHtcbiAgcHJpdmF0ZSBzdGF0aWMgcHJvZHVjdERlZmluaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBQcm9kdWN0RGF0YT4gPSB7fTtcblxuICBwdWJsaWMgc3RhdGljIGdldCBwcm9kdWN0SWRzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIXRoaXMucHJvZHVjdERlZmluaXRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3QgZGVmaW5pdGlvbnMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnByb2R1Y3REZWZpbml0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGluaXRpYWxpc2UoKSB7XG4gICAgY29uc3QgcHJvZHVjdHNEYXRhID0gQ29udGVudE1hbmFnZXIuZ2V0KCdwcm9kdWN0cycpO1xuICAgIGlmICghcHJvZHVjdHNEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2R1Y3QgZGVmaW5pdGlvbnMgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGlmICghaXNQcm9kdWN0c0RhdGEocHJvZHVjdHNEYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb2R1Y3QgZGVmaW5pdGlvbnMgZGF0YScpO1xuICAgIH1cbiAgICB0aGlzLnByb2R1Y3REZWZpbml0aW9ucyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHByb2R1Y3RzRGF0YS5tYXAocHJvZHVjdCA9PiBbcHJvZHVjdC5pZCwgcHJvZHVjdF0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlUHJvZHVjdChsZXZlbDogTGV2ZWwsIGlkOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiBQcm9kdWN0IHtcbiAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHRoaXMucHJvZHVjdERlZmluaXRpb25zW2lkXTtcbiAgICBpZiAoIXByb2R1Y3REYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2R1Y3QgaWQgXCIke2lkfVwiIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvZHVjdC5mcm9tRGF0YShsZXZlbCwge1xuICAgICAgLi4ucHJvZHVjdERhdGEsXG4gICAgICAuLi4oZGF0YSA/PyB7fSksXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBMZXZlbCBmcm9tICcuL0xldmVsJztcbmltcG9ydCB7XG4gIENsb3NpbmdTaGVsZixcbiAgRGVlcFNoZWxmLFxuICBEaXNhcHBlYXJpbmdTaGVsZixcbiAgRGlzcGxheVNoZWxmLFxuICBMb2NraW5nU2hlbGYsXG4gIFNoZWxmLFxuICBTdXBwbHlTaGVsZixcbn0gZnJvbSAnLi9hY3RvcnMnO1xuXG5leHBvcnQgdHlwZSBBYnN0cmFjdFNoZWxmRGF0YTxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgdHlwZTogVDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0U2hlbGZEYXRhKFxuICBkYXRhOiBhbnksXG4gIHZhbGlkPzogc3RyaW5nW11cbik6IGRhdGEgaXMgQWJzdHJhY3RTaGVsZkRhdGEge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiBkYXRhICYmXG4gICAgdHlwZW9mIGRhdGEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAodmFsaWQgPT09IHVuZGVmaW5lZCB8fCB2YWxpZC5pbmNsdWRlcyhkYXRhLnR5cGUpKVxuICApO1xufVxuXG5leHBvcnQgY2xhc3MgU2hlbGZGYWN0b3J5IHtcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVTaGVsZjxUIGV4dGVuZHMgU2hlbGYgPSBTaGVsZj4oXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIGRhdGE6IGFueVxuICApOiBUIHtcbiAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgY2FzZSAnc2hlbGYnOlxuICAgICAgICByZXR1cm4gU2hlbGYuZnJvbURhdGEobGV2ZWwsIGRhdGEpIGFzIHVua25vd24gYXMgVDtcblxuICAgICAgY2FzZSAnY2xvc2luZy1zaGVsZic6XG4gICAgICAgIHJldHVybiBDbG9zaW5nU2hlbGYuZnJvbURhdGEobGV2ZWwsIGRhdGEpIGFzIHVua25vd24gYXMgVDtcblxuICAgICAgY2FzZSAnc3VwcGx5LXNoZWxmJzpcbiAgICAgICAgcmV0dXJuIFN1cHBseVNoZWxmLmZyb21EYXRhKGxldmVsLCBkYXRhKSBhcyB1bmtub3duIGFzIFQ7XG5cbiAgICAgIGNhc2UgJ2Rpc2FwcGVhcmluZy1zaGVsZic6XG4gICAgICAgIHJldHVybiBEaXNhcHBlYXJpbmdTaGVsZi5mcm9tRGF0YShsZXZlbCwgZGF0YSkgYXMgdW5rbm93biBhcyBUO1xuXG4gICAgICBjYXNlICdkZWVwLXNoZWxmJzpcbiAgICAgICAgcmV0dXJuIERlZXBTaGVsZi5mcm9tRGF0YShsZXZlbCwgZGF0YSkgYXMgdW5rbm93biBhcyBUO1xuXG4gICAgICBjYXNlICdkaXNwbGF5LXNoZWxmJzpcbiAgICAgICAgcmV0dXJuIERpc3BsYXlTaGVsZi5mcm9tRGF0YShsZXZlbCwgZGF0YSkgYXMgdW5rbm93biBhcyBUO1xuXG4gICAgICBjYXNlICdsb2NraW5nLXNoZWxmJzpcbiAgICAgICAgcmV0dXJuIExvY2tpbmdTaGVsZi5mcm9tRGF0YShsZXZlbCwgZGF0YSkgYXMgdW5rbm93biBhcyBUO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2hlbGYgdHlwZTogJHtkYXRhLnR5cGV9YCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gJ3V1aWQnO1xuaW1wb3J0IExldmVsIGZyb20gJy4uL0xldmVsJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFjdG9yIHtcbiAgcHVibGljIGlkOiBzdHJpbmc7XG4gIHB1YmxpYyBwb3NpdGlvbjogdmVjMiA9IHZlYzIoKTtcbiAgcHVibGljIGRpc3Bvc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBsZXZlbDogTGV2ZWwpIHtcbiAgICB0aGlzLmlkID0gdXVpZCgpO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IHVwZGF0ZShkdDogbnVtYmVyLCAuLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG5cbiAgcHVibGljIGFic3RyYWN0IGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCAuLi5hcmdzOiBhbnlbXSk6IHZvaWQ7XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYSc7XG5pbXBvcnQgeyB0aW1lcyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgQWN0b3IsIFByb2R1Y3QsIFNoZWxmIH0gZnJvbSAnLic7XG5pbXBvcnQgTGV2ZWwgZnJvbSAnLi4vTGV2ZWwnO1xuaW1wb3J0IHsgQWJzdHJhY3RTaGVsZkRhdGEsIFNoZWxmRmFjdG9yeSB9IGZyb20gJy4uL1NoZWxmRmFjdG9yeSc7XG5cbmV4cG9ydCB0eXBlIENhcm91c2VsRGF0YSA9IHtcbiAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCc7XG4gIHNwZWVkOiBudW1iZXI7XG4gIHNoZWx2ZXM6IEFic3RyYWN0U2hlbGZEYXRhW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDYXJvdXNlbERhdGEoZGF0YTogYW55KTogZGF0YSBpcyBDYXJvdXNlbERhdGEge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddLmluY2x1ZGVzKGRhdGEub3JpZW50YXRpb24pICYmXG4gICAgdHlwZW9mIGRhdGEuc3BlZWQgPT09ICdudW1iZXInICYmXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLnNoZWx2ZXMpICYmXG4gICAgZGF0YS5zaGVsdmVzLmV2ZXJ5KFxuICAgICAgKHNoZWxmOiBhbnkpID0+IHR5cGVvZiBzaGVsZiA9PT0gJ29iamVjdCcgJiYgJ3R5cGUnIGluIHNoZWxmXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBBY3RvciB7XG4gIHByaXZhdGUgdGltZTogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHB1YmxpYyBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyxcbiAgICBwdWJsaWMgc3BlZWQ6IG51bWJlcixcbiAgICBwdWJsaWMgc2hlbHZlczogU2hlbGZbXVxuICApIHtcbiAgICBzdXBlcihsZXZlbCk7XG4gICAgbGV2ZWwuc2hlbHZlcy5wdXNoKC4uLnRoaXMuc2hlbHZlcyk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EYXRhKGxldmVsOiBMZXZlbCwgZGF0YTogYW55KTogQ2Fyb3VzZWwge1xuICAgIGlmICghaXNDYXJvdXNlbERhdGEoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYXJvdXNlbCBkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IHNoZWx2ZXMgPSBkYXRhLnNoZWx2ZXMubWFwKHNoZWxmRGF0YSA9PlxuICAgICAgU2hlbGZGYWN0b3J5LmNyZWF0ZVNoZWxmKGxldmVsLCBzaGVsZkRhdGEpXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IENhcm91c2VsKGxldmVsLCBkYXRhLm9yaWVudGF0aW9uLCBkYXRhLnNwZWVkLCBzaGVsdmVzKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUG9zaXRpb24oY2FtZXJhOiBDYW1lcmEpOiBudW1iZXIge1xuICAgIGNvbnN0IHNoZWxmU2l6ZXMgPSB0aGlzLnNoZWx2ZXMubWFwKHNoZWxmID0+IHNoZWxmLmNhbGN1bGF0ZVNpemUoKSk7XG4gICAgY29uc3QgeyBsZWZ0IH0gPSBjYW1lcmEuYm91bmRzO1xuICAgIHN3aXRjaCAodGhpcy5vcmllbnRhdGlvbikge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIHJldHVybiBsZWZ0IC0gTWF0aC5tYXgoLi4uc2hlbGZTaXplcy5tYXAoc2l6ZSA9PiBzaXplLngpKTtcblxuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICByZXR1cm4gbGVmdCAtIE1hdGgubWF4KC4uLnNoZWxmU2l6ZXMubWFwKHNpemUgPT4gc2l6ZS55KSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTaXplKGNhbWVyYTogQ2FtZXJhKTogbnVtYmVyIHtcbiAgICBjb25zdCBzaGVsZlNpemVzID0gdGhpcy5zaGVsdmVzLm1hcChzaGVsZiA9PiBzaGVsZi5jYWxjdWxhdGVTaXplKCkpO1xuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGNhbWVyYS5ib3VuZHM7XG4gICAgc3dpdGNoICh0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgY29uc3QgbGFyZ2VzdFNoZWxmV2lkdGggPSBNYXRoLm1heCguLi5zaGVsZlNpemVzLm1hcChzaXplID0+IHNpemUueCkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgbGFyZ2VzdFNoZWxmV2lkdGggKyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgICBzaGVsZlNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBhY2MgKyBzaXplLngsIDApXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgY29uc3QgbGFyZ2VzdFNoZWxmSGVpZ2h0ID0gTWF0aC5tYXgoLi4uc2hlbGZTaXplcy5tYXAoc2l6ZSA9PiBzaXplLnkpKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICAgIGxhcmdlc3RTaGVsZkhlaWdodCArIChyaWdodCAtIGxlZnQpLFxuICAgICAgICAgIHNoZWxmU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IGFjYyArIHNpemUueSwgMClcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIsIGxldmVsOiBMZXZlbCwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICAvLyBQb3NpdGlvbiB0aGUgY2Fyb3VzZWxcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY2FsY3VsYXRlUG9zaXRpb24oY2FtZXJhKTtcbiAgICBzd2l0Y2ggKHRoaXMub3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gcG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2Fyb3VzZWwgc2l6ZSBhbmQgc2hlbGYgbW92ZW1lbnQgc3BlZWRcbiAgICBjb25zdCBwcm9kdWN0U2l6ZSA9IFByb2R1Y3QuY2FsY3VsYXRlU2l6ZSgpO1xuICAgIGNvbnN0IGNhcm91c2VsU2l6ZSA9IHRoaXMuY2FsY3VsYXRlU2l6ZShjYW1lcmEpO1xuICAgIGNvbnN0IHNwZWVkID0gcHJvZHVjdFNpemUueCAqIHRoaXMuc3BlZWQ7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCBzaGVsZiBvZmZzZXRzIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXJcbiAgICBjb25zdCBzaGVsZlNpemVzID0gdGhpcy5zaGVsdmVzLm1hcChzaGVsZiA9PiBzaGVsZi5jYWxjdWxhdGVTaXplKCkpO1xuICAgIGNvbnN0IHNoZWxmT2Zmc2V0cyA9ICgoKTogbnVtYmVyW10gPT4ge1xuICAgICAgc3dpdGNoICh0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgIHJldHVybiB0aW1lcyhcbiAgICAgICAgICAgIGluZGV4ID0+XG4gICAgICAgICAgICAgIHNoZWxmU2l6ZXMuc2xpY2UoMCwgaW5kZXgpLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBhY2MgKyBzaXplLngsIDApLFxuICAgICAgICAgICAgdGhpcy5zaGVsdmVzLmxlbmd0aFxuICAgICAgICAgICk7XG5cbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIHJldHVybiB0aW1lcyhcbiAgICAgICAgICAgIGluZGV4ID0+XG4gICAgICAgICAgICAgIHNoZWxmU2l6ZXMuc2xpY2UoMCwgaW5kZXgpLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBhY2MgKyBzaXplLnksIDApLFxuICAgICAgICAgICAgdGhpcy5zaGVsdmVzLmxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIFJlLXBvc2l0aW9uIGFuZCB1cGRhdGUgc2hlbHZlc1xuICAgIHRoaXMuc2hlbHZlcy5mb3JFYWNoKChzaGVsZiwgaW5kZXgpID0+IHtcbiAgICAgIC8vIENhbGN1bGF0ZSBvcHRpb25hbCBzaGVsZiBvZmZzZXRcbiAgICAgIGxldCBvZmZzZXQgPSB2ZWMyLm11bChzaGVsZi5vZmZzZXQsIHByb2R1Y3RTaXplKTtcbiAgICAgIHN3aXRjaCAodGhpcy5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICBzaGVsZi5wb3NpdGlvbi54ID1cbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueCArXG4gICAgICAgICAgICBvZmZzZXQueCArXG4gICAgICAgICAgICAoKHRoaXMudGltZSAqIHNwZWVkICsgc2hlbGZPZmZzZXRzW2luZGV4XSkgJSBjYXJvdXNlbFNpemUpO1xuICAgICAgICAgIHNoZWxmLnBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLnkgKyBvZmZzZXQueTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgc2hlbGYucG9zaXRpb24ueCA9IHRoaXMucG9zaXRpb24ueCArIG9mZnNldC54O1xuICAgICAgICAgIHNoZWxmLnBvc2l0aW9uLnkgPVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICtcbiAgICAgICAgICAgIG9mZnNldC55ICtcbiAgICAgICAgICAgICgodGhpcy50aW1lICogc3BlZWQgKyBzaGVsZk9mZnNldHNbaW5kZXhdKSAlIGNhcm91c2VsU2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaGVsZi51cGRhdGUoZHQsIGxldmVsLCBjYW1lcmEpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgdGhpcy5zaGVsdmVzLmZvckVhY2goc2hlbGYgPT4ge1xuICAgICAgc2hlbGYuZHJhdyhjb250ZXh0KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IHsgcmVjdGFuZ2xlLCBTdHlsZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyBjbGFtcCwgcmVtYXAgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS91dGlscyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBMZXZlbCBmcm9tICcuLi9MZXZlbCc7XG5pbXBvcnQgeyBQcm9kdWN0RmFjdG9yeSB9IGZyb20gJy4uL1Byb2R1Y3RGYWN0b3J5JztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuL1Byb2R1Y3QnO1xuaW1wb3J0IHsgaXNTaGVsZkRhdGEsIFNoZWxmLCBTaGVsZkRhdGEsIFNoZWxmUHJvZHVjdHMgfSBmcm9tICcuL1NoZWxmJztcblxuZXhwb3J0IHR5cGUgQ2xvc2luZ1NoZWxmRGF0YSA9IFNoZWxmRGF0YTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xvc2luZ1NoZWxmRGF0YShkYXRhOiBhbnkpOiBkYXRhIGlzIENsb3NpbmdTaGVsZkRhdGEge1xuICByZXR1cm4gaXNTaGVsZkRhdGEoZGF0YSk7XG59XG5cbi8qKlxuICogQ2xvc2luZyBzaGVsZiBjbG9zZXMgd2hlbiBhIG1hdGNoaW5nIHNldCBvZiBwcm9kdWN0cyBpcyBhZGRlZCwgYW5kIG5vIG1vcmVcbiAqIHByb2R1Y3RzIGNhbiBiZSBhZGRlZCBvciByZW1vdmVkXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG9zaW5nU2hlbGYgZXh0ZW5kcyBTaGVsZiB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENMT1NJTkdfVElNRTogbnVtYmVyID0gMC41O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDTE9TSU5HX1NUWUxFOiBQYXJ0aWFsPFN0eWxlT3B0aW9ucz4gPSB7XG4gICAgc3Ryb2tlOiBmYWxzZSxcbiAgICBmaWxsOiB0cnVlLFxuICAgIGZpbGxDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gIH07XG5cbiAgcHVibGljIGNsb3NlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGNsb3NpbmdUaW1lOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGZpbmlzaGVkQ2xvc2luZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbURhdGEobGV2ZWw6IExldmVsLCBkYXRhOiBhbnkpOiBDbG9zaW5nU2hlbGYge1xuICAgIGlmICghaXNDbG9zaW5nU2hlbGZEYXRhKGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2xvc2luZyBzaGVsZiBkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb2R1Y3RzID0gZGF0YS5wcm9kdWN0cy5tYXAocHJvZHVjdElkID0+XG4gICAgICBwcm9kdWN0SWQgIT09IG51bGwgPyBQcm9kdWN0RmFjdG9yeS5jcmVhdGVQcm9kdWN0KGxldmVsLCBwcm9kdWN0SWQpIDogbnVsbFxuICAgICkgYXMgU2hlbGZQcm9kdWN0cztcbiAgICByZXR1cm4gbmV3IENsb3NpbmdTaGVsZihcbiAgICAgIGxldmVsLFxuICAgICAgcHJvZHVjdHMsXG4gICAgICBkYXRhLm9mZnNldCB8fCB2ZWMyKCksXG4gICAgICBkYXRhLnNsb3RDb3VudCB8fCBDbG9zaW5nU2hlbGYuREVGQVVMVF9TTE9UX0NPVU5ULFxuICAgICAgZGF0YS5tYXRjaENvdW50IHx8IENsb3NpbmdTaGVsZi5ERUZBVUxUX01BVENIX0NPVU5ULFxuICAgICAgZGF0YS5pZ25vcmUgfHwgZmFsc2UsXG4gICAgICBkYXRhLnJlZmVyZW5jZSB8fCB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyLCBsZXZlbDogTGV2ZWwsIGNhbWVyYTogQ2FtZXJhKSB7XG4gICAgdGhpcy5wcm9kdWN0cy5mb3JFYWNoKChwcm9kdWN0LCBpbmRleCkgPT4ge1xuICAgICAgcHJvZHVjdD8udXBkYXRlKGR0LCBsZXZlbCwgY2FtZXJhLCB0aGlzLCBpbmRleCk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiBhIG1hdGNoIGlzIGZvdW5kLCBjbG9zZSB0aGUgc2hlbGZcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2hlY2tGb3JNYXRjaGVzKCk7XG4gICAgaWYgKG1hdGNoLmZvdW5kKSB7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNsb3NpbmcgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NpbmdUaW1lID0gY2xhbXAoXG4gICAgICAgIHRoaXMuY2xvc2luZ1RpbWUgKyBkdCxcbiAgICAgICAgMCxcbiAgICAgICAgQ2xvc2luZ1NoZWxmLkNMT1NJTkdfVElNRVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmNsb3NpbmdUaW1lID49IENsb3NpbmdTaGVsZi5DTE9TSU5HX1RJTUUpIHtcbiAgICAgICAgdGhpcy5maW5pc2hlZENsb3NpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdGF0c1xuICAgIGlmICghdGhpcy5zdGF0c1VwZGF0ZWQpIHtcbiAgICAgIGlmIChtYXRjaC5mb3VuZCkge1xuICAgICAgICBtYXRjaC5tYXRjaGVzLmZvckVhY2gocHJvZHVjdCA9PiB7XG4gICAgICAgICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgICAgICAgIGxldmVsLnN0YXRzLnByb2R1Y3RNYXRjaGVzW3Byb2R1Y3QuaWRdLnRvdGFsKys7XG4gICAgICAgICAgICBsZXZlbC5zdGF0cy50b3RhbE1hdGNoZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRzVXBkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaGVsZklzQ29tcGxldGUoKSkge1xuICAgICAgICBsZXZlbC5zdGF0cy50b3RhbENvbXBsZXRlZFNoZWx2ZXMrKztcbiAgICAgICAgdGhpcy5zdGF0c1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjYW5QaWNrVXBQcm9kdWN0QXRJbmRleChwcm9kdWN0OiBQcm9kdWN0LCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIENhbm5vdCBwaWNrIHVwIHByb2R1Y3RzIGZyb20gYSBjbG9zZWQgc2hlbGZcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNhblBpY2tVcFByb2R1Y3RBdEluZGV4KHByb2R1Y3QsIGluZGV4KTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Ecm9wUHJvZHVjdEF0SW5kZXgocHJvZHVjdDogUHJvZHVjdCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBDYW5ub3QgZHJvcCBwcm9kdWN0cyBvbiBhIGNsb3NlZCBzaGVsZlxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2FuRHJvcFByb2R1Y3RBdEluZGV4KHByb2R1Y3QsIGluZGV4KTtcbiAgfVxuXG4gIHB1YmxpYyBzaGVsZklzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgc3VwZXIuZHJhdyhjb250ZXh0KTtcblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgY29uc3QgY2xvc2luZ0Ftb3VudCA9IHRoaXMuZmluaXNoZWRDbG9zaW5nXG4gICAgICAgID8gc2l6ZS55XG4gICAgICAgIDogcmVtYXAodGhpcy5jbG9zaW5nVGltZSwgMCwgQ2xvc2luZ1NoZWxmLkNMT1NJTkdfVElNRSwgMCwgc2l6ZS55KTtcbiAgICAgIHJlY3RhbmdsZShcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdmVjMihzaXplLngsIGNsb3NpbmdBbW91bnQpLFxuICAgICAgICBDbG9zaW5nU2hlbGYuQ0xPU0lOR19TVFlMRVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhJztcbmltcG9ydCB7IEFBQkIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnRlcnNlY3Rpb24taGVscGVycy8yZCc7XG5pbXBvcnQgeyB2ZWN0b3JzQWxtb3N0RXF1YWwgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnRlcnNlY3Rpb24taGVscGVycy91dGlsaXRpZXMnO1xuaW1wb3J0IHsgY2xhbXAsIGxlcnAgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS91dGlscyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCB7IEFjdG9yLCBQcm9kdWN0LCBTaGVsZiB9IGZyb20gJy4nO1xuaW1wb3J0IExldmVsIGZyb20gJy4uL0xldmVsJztcbmltcG9ydCB7IEFic3RyYWN0U2hlbGZEYXRhLCBTaGVsZkZhY3RvcnkgfSBmcm9tICcuLi9TaGVsZkZhY3RvcnknO1xuXG5mdW5jdGlvbiBlYXNlT3V0Qm91bmNlKHg6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG4xID0gNy41NjI1O1xuICBjb25zdCBkMSA9IDIuNzU7XG4gIGlmICh4IDwgMSAvIGQxKSB7XG4gICAgcmV0dXJuIG4xICogeCAqIHg7XG4gIH0gZWxzZSBpZiAoeCA8IDIgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDEuNSAvIGQxKSAqIHggKyAwLjc1O1xuICB9IGVsc2UgaWYgKHggPCAyLjUgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuMjUgLyBkMSkgKiB4ICsgMC45Mzc1O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuNjI1IC8gZDEpICogeCArIDAuOTg0Mzc1O1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIENvbGxhcHNlRGF0YSA9IHtcbiAgZ3JpZDoge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gIH07XG4gIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuICBkaXJlY3Rpb246ICdwb3NpdGl2ZScgfCAnbmVnYXRpdmUnIHwgJ2NlbnRlcic7XG4gIGFjdG9yczogKFxuICAgIHwgQWJzdHJhY3RTaGVsZkRhdGFcbiAgICB8IChDb2xsYXBzZURhdGEgJiB7XG4gICAgICAgIHR5cGU6ICdjb2xsYXBzZSc7XG4gICAgICB9KVxuICApW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xsYXBzZURhdGEoZGF0YTogYW55KTogZGF0YSBpcyBDb2xsYXBzZURhdGEge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBkYXRhLmdyaWQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGRhdGEuZ3JpZC53aWR0aCA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgZGF0YS5ncmlkLmhlaWdodCA9PT0gJ251bWJlcicgJiZcbiAgICBbJ2hvcml6b250YWwnLCAndmVydGljYWwnXS5pbmNsdWRlcyhkYXRhLm9yaWVudGF0aW9uKSAmJlxuICAgIFsncG9zaXRpdmUnLCAnbmVnYXRpdmUnLCAnY2VudGVyJ10uaW5jbHVkZXMoZGF0YS5kaXJlY3Rpb24pICYmXG4gICAgQXJyYXkuaXNBcnJheShkYXRhLmFjdG9ycykgJiZcbiAgICBkYXRhLmFjdG9ycy5ldmVyeShcbiAgICAgIChhY3RvcjogYW55KSA9PlxuICAgICAgICB0eXBlb2YgYWN0b3IgPT09ICdvYmplY3QnICYmICgndHlwZScgaW4gYWN0b3IgfHwgaXNDb2xsYXBzZURhdGEoYWN0b3IpKVxuICAgIClcbiAgKTtcbn1cblxudHlwZSBJbnRlcm5hbEFjdG9yID0gQ29sbGFwc2UgfCBTaGVsZjtcblxuZXhwb3J0IGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQWN0b3Ige1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDT0xMQVBTRV9USU1FOiBudW1iZXIgPSAxLjU7XG5cbiAgcHJpdmF0ZSBhY3RvclN0YXRlczogTWFwPFxuICAgIEludGVybmFsQWN0b3IsXG4gICAge1xuICAgICAgdGFyZ2V0UG9zaXRpb246IHZlYzI7XG4gICAgICBvbGRQb3NpdGlvbj86IHZlYzI7XG4gICAgICBlYXNlUHJvZ3Jlc3M/OiBudW1iZXI7XG4gICAgfVxuICA+ID0gbmV3IE1hcCgpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgcHVibGljIGdyaWQ6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSxcbiAgICBwdWJsaWMgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcsXG4gICAgcHVibGljIGRpcmVjdGlvbjogJ3Bvc2l0aXZlJyB8ICduZWdhdGl2ZScgfCAnY2VudGVyJyxcbiAgICBwdWJsaWMgYWN0b3JzOiBJbnRlcm5hbEFjdG9yW11cbiAgKSB7XG4gICAgc3VwZXIobGV2ZWwpO1xuICAgIGxldmVsLnNoZWx2ZXMucHVzaChcbiAgICAgIC4uLih0aGlzLmFjdG9ycy5maWx0ZXIoYSA9PiBhIGluc3RhbmNlb2YgU2hlbGYpIGFzIFNoZWxmW10pXG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpc2UgYWN0b3Igc3RhdGVzXG4gICAgdGhpcy5hY3RvcnMuZm9yRWFjaChhY3RvciA9PiB7XG4gICAgICB0aGlzLmFjdG9yU3RhdGVzLnNldChhY3Rvciwge1xuICAgICAgICB0YXJnZXRQb3NpdGlvbjogdmVjMigpLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXNlIGFjdG9yIHBvc2l0aW9uc1xuICAgIHRoaXMuY2FsY3VsYXRlVGFyZ2V0UG9zaXRpb25zKCk7XG4gICAgdGhpcy5hY3RvcnMuZm9yRWFjaChhY3RvciA9PiB7XG4gICAgICBpZiAodGhpcy5hY3RvclN0YXRlcy5oYXMoYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5hY3RvclN0YXRlcy5nZXQoYWN0b3IpITtcbiAgICAgICAgYWN0b3IucG9zaXRpb24gPSB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCBzdGF0ZS50YXJnZXRQb3NpdGlvbik7XG4gICAgICAgIHN0YXRlLm9sZFBvc2l0aW9uID0gdmVjMi5jcHkoc3RhdGUudGFyZ2V0UG9zaXRpb24pO1xuICAgICAgICBzdGF0ZS5lYXNlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tRGF0YShsZXZlbDogTGV2ZWwsIGRhdGE6IGFueSk6IENvbGxhcHNlIHtcbiAgICBpZiAoIWlzQ29sbGFwc2VEYXRhKGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sbGFwc2UgZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBhY3RvcnMgPSBkYXRhLmFjdG9ycy5tYXAoYWN0b3JEYXRhID0+IHtcbiAgICAgIGlmIChhY3RvckRhdGEudHlwZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgICByZXR1cm4gQ29sbGFwc2UuZnJvbURhdGEobGV2ZWwsIGFjdG9yRGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU2hlbGZGYWN0b3J5LmNyZWF0ZVNoZWxmKGxldmVsLCBhY3RvckRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQ29sbGFwc2UoXG4gICAgICBsZXZlbCxcbiAgICAgIGRhdGEuZ3JpZCxcbiAgICAgIGRhdGEub3JpZW50YXRpb24sXG4gICAgICBkYXRhLmRpcmVjdGlvbixcbiAgICAgIGFjdG9yc1xuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY2FsY3VsYXRlU2l6ZSgpOiB2ZWMyIHtcbiAgICBjb25zdCBzaXplID0gdmVjMigpO1xuICAgIHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4ge1xuICAgICAgY29uc3QgYWN0b3JTaXplID0gYWN0b3IuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgc3dpdGNoICh0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICAgIHNpemUueCArPSBhY3RvclNpemUueDtcbiAgICAgICAgICBzaXplLnkgPSBNYXRoLm1heChzaXplLnksIGFjdG9yU2l6ZS55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgc2l6ZS54ID0gTWF0aC5tYXgoc2l6ZS54LCBhY3RvclNpemUueCk7XG4gICAgICAgICAgc2l6ZS55ICs9IGFjdG9yU2l6ZS55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgcHVibGljIGdldEFBQkIoKTogQUFCQiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgc2l6ZTogdGhpcy5jYWxjdWxhdGVTaXplKCksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlR3JpZFNpemUoKTogdmVjMiB7XG4gICAgcmV0dXJuIHZlYzIubXVsKFxuICAgICAgdmVjMih0aGlzLmdyaWQud2lkdGgsIHRoaXMuZ3JpZC5oZWlnaHQpLFxuICAgICAgUHJvZHVjdC5jYWxjdWxhdGVTaXplKClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTdGFydFBvc2l0aW9uKCk6IHZlYzIge1xuICAgIGNvbnN0IGdyaWRTaXplID0gdGhpcy5jYWxjdWxhdGVHcmlkU2l6ZSgpO1xuICAgIGNvbnN0IGNvbnRlbnRTaXplID0gdGhpcy5jYWxjdWxhdGVTaXplKCk7XG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHZlYzIoKTtcbiAgICBzd2l0Y2ggKHRoaXMub3JpZW50YXRpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBzd2l0Y2ggKHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSAncG9zaXRpdmUnOlxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbi54ID0gZ3JpZFNpemUueCAtIGNvbnRlbnRTaXplLng7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLnkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduZWdhdGl2ZSc6XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLnggPSAwO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbi55ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24ueCA9IChncmlkU2l6ZS54IC0gY29udGVudFNpemUueCkgLyAyO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbi55ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIHN3aXRjaCAodGhpcy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICdwb3NpdGl2ZSc6XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLnggPSAwO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbi55ID0gZ3JpZFNpemUueSAtIGNvbnRlbnRTaXplLnk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ25lZ2F0aXZlJzpcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24ueCA9IDA7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLnkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbi54ID0gMDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24ueSA9IChncmlkU2l6ZS55IC0gY29udGVudFNpemUueSkgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVUYXJnZXRQb3NpdGlvbnMoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMuY2FsY3VsYXRlU3RhcnRQb3NpdGlvbigpO1xuICAgIGxldCBjdXJyZW50ID0gdmVjMigpO1xuICAgIHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4ge1xuICAgICAgY29uc3QgYWN0b3JTaXplID0gYWN0b3IuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB2ZWMyLmFkZChzdGFydFBvc2l0aW9uLCBjdXJyZW50KTtcblxuICAgICAgaWYgKHRoaXMuYWN0b3JTdGF0ZXMuaGFzKGFjdG9yKSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuYWN0b3JTdGF0ZXMuZ2V0KGFjdG9yKSE7XG4gICAgICAgIHN0YXRlLnRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdG9yU3RhdGVzLnNldChhY3RvciwgeyB0YXJnZXRQb3NpdGlvbiB9KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5vcmllbnRhdGlvbikge1xuICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICBjdXJyZW50LnggKz0gYWN0b3JTaXplLng7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgIGN1cnJlbnQueSArPSBhY3RvclNpemUueTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlciwgbGV2ZWw6IExldmVsLCBjYW1lcmE6IENhbWVyYSkge1xuICAgIHRoaXMuY2FsY3VsYXRlVGFyZ2V0UG9zaXRpb25zKCk7XG4gICAgdGhpcy5hY3RvcnMuZm9yRWFjaChhY3RvciA9PiB7XG4gICAgICBpZiAodGhpcy5hY3RvclN0YXRlcy5oYXMoYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5hY3RvclN0YXRlcy5nZXQoYWN0b3IpITtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRlLmVhc2VQcm9ncmVzcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgc3RhdGUuZWFzZVByb2dyZXNzID49IDEgfHxcbiAgICAgICAgICB2ZWN0b3JzQWxtb3N0RXF1YWwoXG4gICAgICAgICAgICBhY3Rvci5wb3NpdGlvbixcbiAgICAgICAgICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHN0YXRlLnRhcmdldFBvc2l0aW9uKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgYWN0b3IucG9zaXRpb24gPSB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCBzdGF0ZS50YXJnZXRQb3NpdGlvbik7XG4gICAgICAgICAgc3RhdGUuZWFzZVByb2dyZXNzID0gMDtcbiAgICAgICAgICBzdGF0ZS5vbGRQb3NpdGlvbiA9IHZlYzIuY3B5KHN0YXRlLnRhcmdldFBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5lYXNlUHJvZ3Jlc3MgPSBjbGFtcChcbiAgICAgICAgICAgIChzdGF0ZS5lYXNlUHJvZ3Jlc3MgPz8gMSkgKyBkdCAvIENvbGxhcHNlLkNPTExBUFNFX1RJTUUsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZWFzZWRQb3NpdGlvbiA9IHZlYzIoXG4gICAgICAgICAgICBsZXJwKFxuICAgICAgICAgICAgICBzdGF0ZS5vbGRQb3NpdGlvbj8ueCA/PyAwLFxuICAgICAgICAgICAgICBzdGF0ZS50YXJnZXRQb3NpdGlvbi54LFxuICAgICAgICAgICAgICBlYXNlT3V0Qm91bmNlKHN0YXRlLmVhc2VQcm9ncmVzcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBsZXJwKFxuICAgICAgICAgICAgICBzdGF0ZS5vbGRQb3NpdGlvbj8ueSA/PyAwLFxuICAgICAgICAgICAgICBzdGF0ZS50YXJnZXRQb3NpdGlvbi55LFxuICAgICAgICAgICAgICBlYXNlT3V0Qm91bmNlKHN0YXRlLmVhc2VQcm9ncmVzcylcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGFjdG9yLnBvc2l0aW9uID0gdmVjMi5hZGQodGhpcy5wb3NpdGlvbiwgZWFzZWRQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdG9yLnVwZGF0ZShkdCwgbGV2ZWwsIGNhbWVyYSk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGlzIGNvbGxhcHNlIGhhcyBubyBhY3RvcnMsIGl0IGNhbiBiZSBkaXNwb3NlZFxuICAgIGlmICh0aGlzLmFjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYWN0b3JzID0gdGhpcy5hY3RvcnMuZmlsdGVyKGFjdG9yID0+ICFhY3Rvci5kaXNwb3NlZCk7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICB0aGlzLmFjdG9ycy5mb3JFYWNoKGFjdG9yID0+IHtcbiAgICAgIGFjdG9yLmRyYXcoY29udGV4dCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhJztcbmltcG9ydCB7IGlzVmVjMiB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBjbGFtcCwgbGVycCwgcGVlaywgcmVtYXAsIHVubGVycCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IExldmVsIGZyb20gJy4uL0xldmVsJztcbmltcG9ydCB7IFByb2R1Y3RGYWN0b3J5IH0gZnJvbSAnLi4vUHJvZHVjdEZhY3RvcnknO1xuaW1wb3J0IHsgUHJvZHVjdCB9IGZyb20gJy4vUHJvZHVjdCc7XG5pbXBvcnQge1xuICBpc1NoZWxmUHJvZHVjdHNEYXRhLFxuICBTaGVsZixcbiAgU2hlbGZEYXRhLFxuICBTaGVsZlByb2R1Y3RzLFxuICBTaGVsZlByb2R1Y3RzRGF0YSxcbn0gZnJvbSAnLi9TaGVsZic7XG5cbmV4cG9ydCB0eXBlIERlZXBTaGVsZkRhdGEgPSBPbWl0PFNoZWxmRGF0YSwgJ3Byb2R1Y3RzJz4gJiB7XG4gIGxheWVyczogU2hlbGZQcm9kdWN0c0RhdGFbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZXBTaGVsZkRhdGEoZGF0YTogYW55KTogZGF0YSBpcyBEZWVwU2hlbGZEYXRhIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICBBcnJheS5pc0FycmF5KGRhdGEubGF5ZXJzKSAmJlxuICAgIGRhdGEubGF5ZXJzLmV2ZXJ5KChsYXllcjogYW55KSA9PiBpc1NoZWxmUHJvZHVjdHNEYXRhKGxheWVyKSkgJiZcbiAgICAoZGF0YS5vZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBpc1ZlYzIoZGF0YS5vZmZzZXQpKSAmJlxuICAgIChkYXRhLnNsb3RDb3VudCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBkYXRhLnNsb3RDb3VudCA9PT0gJ251bWJlcicpICYmXG4gICAgKGRhdGEubWF0Y2hDb3VudCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBkYXRhLm1hdGNoQ291bnQgPT09ICdudW1iZXInKVxuICApO1xufVxuXG4vKipcbiAqIERlZXAgc2hlbGYgaGFzIG11bHRpcGxlIGxheWVycyBvZiBwcm9kdWN0c1xuICpcbiAqIEFsbCBsYXllcnMgbXVzdCBiZSBjbGVhcmVkIGZvciB0aGUgc2hlbGYgdG8gYmUgY29uc2lkZXJlZCBjb21wbGV0ZVxuICovXG5leHBvcnQgY2xhc3MgRGVlcFNoZWxmIGV4dGVuZHMgU2hlbGYge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBORVhUX0xBWUVSX1NDQUxFOiBudW1iZXIgPSAwLjk7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5FWFRfTEFZRVJfT0ZGU0VUOiB2ZWMyID0gdmVjMigwLCAtOCk7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5FWFRfTEFZRVJfQUxQSEE6IG51bWJlciA9IDAuODtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTkVYVF9MQVlFUl9PVkVSTEFZX0NPTE9SOiBzdHJpbmcgPVxuICAgICdyZ2JhKDAsIDAsIDAsIDAuNiknO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDSEFOR0lOR19MQVlFUlNfQU5JTUFUSU9OX1RJTUU6IG51bWJlciA9IDAuNTtcblxuICBwcml2YXRlIG5leHRMYXllckNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBuZXh0TGF5ZXJDb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIG5leHROZXh0TGF5ZXJDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbmV4dE5leHRMYXllckNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgY2hhbmdpbmdMYXllcnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBjaGFuZ2luZ0xheWVyc1RpbWU6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwdWJsaWMgbGF5ZXJzOiBTaGVsZlByb2R1Y3RzW10sXG4gICAgb2Zmc2V0OiB2ZWMyID0gdmVjMigpLFxuICAgIHNsb3RDb3VudDogbnVtYmVyID0gRGVlcFNoZWxmLkRFRkFVTFRfU0xPVF9DT1VOVCxcbiAgICBtYXRjaENvdW50OiBudW1iZXIgPSBEZWVwU2hlbGYuREVGQVVMVF9NQVRDSF9DT1VOVCxcbiAgICBpZ25vcmU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICByZWZlcmVuY2U/OiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBsZXZlbCxcbiAgICAgIHBlZWsobGF5ZXJzKSA/PyBuZXcgQXJyYXkoc2xvdENvdW50KS5maWxsKG51bGwpLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc2xvdENvdW50LFxuICAgICAgbWF0Y2hDb3VudCxcbiAgICAgIGlnbm9yZSxcbiAgICAgIHJlZmVyZW5jZVxuICAgICk7XG5cbiAgICAvLyBTZXR1cCBuZXh0IGxheWVyIGNhbnZhcyAodGhpcyBzaG93cyBwcm9kdWN0cyBiZWhpbmQgdGhlIHRvcCBsYXllcilcbiAgICBjb25zdCBzaXplID0gdGhpcy5jYWxjdWxhdGVTaXplKCk7XG4gICAgdGhpcy5uZXh0TGF5ZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLm5leHRMYXllckNhbnZhcy53aWR0aCA9IHNpemUueDtcbiAgICB0aGlzLm5leHRMYXllckNhbnZhcy5oZWlnaHQgPSBzaXplLnk7XG4gICAgdGhpcy5uZXh0TGF5ZXJDb250ZXh0ID0gdGhpcy5uZXh0TGF5ZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIXRoaXMubmV4dExheWVyQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGEgY29udGV4dCBmb3IgbmV4dCBsYXllciBjYW52YXMnKTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBuZXh0IG5leHQgbGF5ZXIgY2FudmFzICh0aGlzIHNob3dzIHRoZSBuZXcgbmV4dCBsYXllclxuICAgIC8vIHRyYW5zaXRpb25pbmcgaW4gZHVyaW5nIHRoZSBjaGFuZ2luZyBsYXllcnMgYW5pbWF0aW9uKVxuICAgIHRoaXMubmV4dE5leHRMYXllckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMubmV4dE5leHRMYXllckNhbnZhcy53aWR0aCA9IHNpemUueDtcbiAgICB0aGlzLm5leHROZXh0TGF5ZXJDYW52YXMuaGVpZ2h0ID0gc2l6ZS55O1xuICAgIHRoaXMubmV4dE5leHRMYXllckNvbnRleHQgPSB0aGlzLm5leHROZXh0TGF5ZXJDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIXRoaXMubmV4dE5leHRMYXllckNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhIGNvbnRleHQgZm9yIG5leHQgbmV4dCBsYXllciBjYW52YXMnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EYXRhKGxldmVsOiBMZXZlbCwgZGF0YTogYW55KTogRGVlcFNoZWxmIHtcbiAgICBpZiAoIWlzRGVlcFNoZWxmRGF0YShkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIERlZXBTaGVsZiBkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IGRhdGEubGF5ZXJzLm1hcCgobGF5ZXI6IFNoZWxmUHJvZHVjdHNEYXRhKSA9PlxuICAgICAgbGF5ZXIubWFwKHByb2R1Y3RJZCA9PlxuICAgICAgICBwcm9kdWN0SWQgPT09IG51bGxcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IFByb2R1Y3RGYWN0b3J5LmNyZWF0ZVByb2R1Y3QobGV2ZWwsIHByb2R1Y3RJZClcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBuZXcgRGVlcFNoZWxmKFxuICAgICAgbGV2ZWwsXG4gICAgICBsYXllcnMsXG4gICAgICBkYXRhLm9mZnNldCB8fCB2ZWMyKCksXG4gICAgICBkYXRhLnNsb3RDb3VudCB8fCBEZWVwU2hlbGYuREVGQVVMVF9TTE9UX0NPVU5ULFxuICAgICAgZGF0YS5tYXRjaENvdW50IHx8IERlZXBTaGVsZi5ERUZBVUxUX01BVENIX0NPVU5ULFxuICAgICAgZGF0YS5pZ25vcmUgfHwgZmFsc2UsXG4gICAgICBkYXRhLnJlZmVyZW5jZSB8fCB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyLCBsZXZlbDogTGV2ZWwsIGNhbWVyYTogQ2FtZXJhKSB7XG4gICAgc3VwZXIudXBkYXRlKGR0LCBsZXZlbCwgY2FtZXJhKTtcblxuICAgIC8vIFNldCBwb3NpdGlvbiBhbmQgc2l6ZSBmb3IgcHJvZHVjdHMgbGF5ZXJzIG90aGVyIHRoYW4gdGhlIGN1cnJlbnQgbGF5ZXJcbiAgICB0aGlzLmxheWVycy5zbGljZSgwLCAtMSkuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsYXllci5mb3JFYWNoKChwcm9kdWN0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAocHJvZHVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHByb2R1Y3Quc2l6ZSA9IFByb2R1Y3QuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgICAgIHByb2R1Y3QucG9zaXRpb25JbW1lZGlhdGUgPSB2ZWMyLmFkZChcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgICB2ZWMyLm11bCh2ZWMyKHByb2R1Y3Quc2l6ZS54LCAwKSwgaW5kZXgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZW1vdmUgcHJvZHVjdHMgdGhhdCBoYXZlIGZpbmlzaGVkIHRoZSBkaXNhcHBlYXJpbmcgYW5pbWF0aW9uXG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICAgIHRoaXMubGF5ZXJzW2xheWVySW5kZXhdID0gbGF5ZXIubWFwKHByb2R1Y3QgPT4ge1xuICAgICAgICBpZiAocHJvZHVjdCAmJiBwcm9kdWN0LmZpbmlzaGVkRGlzYXBwZWFyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgICB9KSBhcyBTaGVsZlByb2R1Y3RzO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgbGF5ZXIgaXMgZW1wdHksIHJlbW92ZSBpdCBhbmQgc3dpdGNoIHRvIHRoZSBuZXh0IGxheWVyXG4gICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IHBlZWsodGhpcy5sYXllcnMpO1xuICAgICAgaWYgKHRoaXMubGF5ZXJJc0VtcHR5KGN1cnJlbnRMYXllciEpICYmICF0aGlzLmNoYW5naW5nTGF5ZXJzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdpbmdMYXllcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYW5naW5nTGF5ZXJzVGltZSA9IERlZXBTaGVsZi5DSEFOR0lOR19MQVlFUlNfQU5JTUFUSU9OX1RJTUU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNoYW5naW5nIGxheWVycyBhbmltYXRpb25cbiAgICB0aGlzLmNoYW5naW5nTGF5ZXJzVGltZSA9IGNsYW1wKFxuICAgICAgdGhpcy5jaGFuZ2luZ0xheWVyc1RpbWUgLSBkdCxcbiAgICAgIDAsXG4gICAgICBEZWVwU2hlbGYuQ0hBTkdJTkdfTEFZRVJTX0FOSU1BVElPTl9USU1FXG4gICAgKTtcbiAgICBpZiAodGhpcy5jaGFuZ2luZ0xheWVycyAmJiB0aGlzLmNoYW5naW5nTGF5ZXJzVGltZSA8PSAwKSB7XG4gICAgICAvLyBBbHdheXMgbGVhdmUgMSBsYXllciBiZWhpbmQgKG90aGVyd2lzZSB0aGUgc2hlbGYgYmVjb21lcyB1bnVzYWJsZVxuICAgICAgLy8gYWZ0ZXIgaXQgaXMgY2xlYXJlZCB0aGUgZmlyc3QgdGltZSlcbiAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMubGF5ZXJzLnBvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9kdWN0cyA9IHBlZWsodGhpcy5sYXllcnMpID8/IG5ldyBBcnJheSh0aGlzLnNsb3RDb3VudCkuZmlsbChudWxsKTtcbiAgICAgIHRoaXMuY2hhbmdpbmdMYXllcnMgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdHNVcGRhdGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsYXllcklzRW1wdHkobGF5ZXI6IFNoZWxmUHJvZHVjdHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGF5ZXIuZXZlcnkocHJvZHVjdCA9PiBwcm9kdWN0ID09PSBudWxsKTtcbiAgfVxuXG4gIHB1YmxpYyBzaGVsZklzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzLmV2ZXJ5KGxheWVyID0+IHRoaXMubGF5ZXJJc0VtcHR5KGxheWVyKSk7XG4gIH1cblxuICBwdWJsaWMgc2hlbGZJc0NvbXBsZXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNoZWxmSXNFbXB0eSgpO1xuICB9XG5cbiAgcHVibGljIGFkZFByb2R1Y3RBdEluZGV4KGluZGV4OiBudW1iZXIsIHByb2R1Y3Q6IFByb2R1Y3QpOiBib29sZWFuIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2xvdENvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEludmFsaWQgaW5kZXhcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvZHVjdHNbaW5kZXhdICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIFNsb3QgaXMgYWxyZWFkeSBvY2N1cGllZFxuICAgIH1cbiAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIGxheWVycyB0byBhZGQgdG9cbiAgICB9XG4gICAgdGhpcy5wcm9kdWN0c1tpbmRleF0gPSBwcm9kdWN0O1xuICAgIHBlZWsodGhpcy5sYXllcnMpIVtpbmRleF0gPSBwcm9kdWN0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZVByb2R1Y3RBdEluZGV4KGluZGV4OiBudW1iZXIpOiBQcm9kdWN0IHwgbnVsbCB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNsb3RDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgaW5kZXhcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIGxheWVycyB0byByZW1vdmUgZnJvbVxuICAgIH1cbiAgICBjb25zdCBwcm9kdWN0ID0gdGhpcy5wcm9kdWN0c1tpbmRleF07XG4gICAgdGhpcy5wcm9kdWN0c1tpbmRleF0gPSBudWxsO1xuICAgIHBlZWsodGhpcy5sYXllcnMpIVtpbmRleF0gPSBudWxsO1xuICAgIHJldHVybiBwcm9kdWN0O1xuICB9XG5cbiAgcHVibGljIGxvY2tQcm9kdWN0QXRJbmRleChcbiAgICBpbmRleDogbnVtYmVyLFxuICAgIGxvY2tlZDogYm9vbGVhbiA9IHRydWVcbiAgKTogYm9vbGVhbiB8IG51bGwge1xuICAgIGNvbnN0IGxheWVyID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc2xvdENvdW50KTtcbiAgICBjb25zdCBsYXllckluZGV4ID0gaW5kZXggJSB0aGlzLnNsb3RDb3VudDtcbiAgICBpZiAoXG4gICAgICBsYXllciA8IDAgfHxcbiAgICAgIGxheWVyID49IHRoaXMubGF5ZXJzLmxlbmd0aCB8fFxuICAgICAgbGF5ZXJJbmRleCA8IDAgfHxcbiAgICAgIGxheWVySW5kZXggPj0gdGhpcy5zbG90Q291bnRcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBJbnZhbGlkIGluZGV4XG4gICAgfVxuICAgIGNvbnN0IHByb2R1Y3QgPSB0aGlzLmxheWVyc1tsYXllcl1bbGF5ZXJJbmRleF07XG4gICAgaWYgKHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBObyBwcm9kdWN0IHRvIGxvY2tcbiAgICB9XG4gICAgcHJvZHVjdC5sb2NrZWQgPSBsb2NrZWQ7XG4gICAgcmV0dXJuIHByb2R1Y3QubG9ja2VkO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuICAgIGNvbnN0IGhhbGZTaXplID0gdmVjMi5kaXYoc2l6ZSwgMik7XG5cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdHJhbnNpdGlvbmluZyBiZXR3ZWVuIGxheWVycyBhbmQgdGhlcmUncyBhbm90aGVyXG4gICAgLy8gbGF5ZXIgYmVoaW5kIHRoZSBuZXh0IG9uZSwgZHJhdyB0aGUgbmV4dCBuZXh0IGxheWVyXG4gICAgaWYgKFxuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ2FudmFzICYmXG4gICAgICB0aGlzLm5leHROZXh0TGF5ZXJDb250ZXh0ICYmXG4gICAgICB0aGlzLmxheWVycy5sZW5ndGggPiAyICYmXG4gICAgICB0aGlzLmNoYW5naW5nTGF5ZXJzXG4gICAgKSB7XG4gICAgICB0aGlzLm5leHROZXh0TGF5ZXJDYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgICB0aGlzLm5leHROZXh0TGF5ZXJDYW52YXMuaGVpZ2h0ID0gc2l6ZS55O1xuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLm5leHROZXh0TGF5ZXJDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICB0aGlzLm5leHROZXh0TGF5ZXJDb250ZXh0LnRyYW5zbGF0ZSgtdGhpcy5wb3NpdGlvbi54LCAtdGhpcy5wb3NpdGlvbi55KTtcblxuICAgICAgY29uc3QgbmV4dE5leHRMYXllckluZGV4ID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMztcbiAgICAgIHRoaXMubGF5ZXJzW25leHROZXh0TGF5ZXJJbmRleF0uZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgICAgaWYgKHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZHVjdC5kcmF3KHRoaXMubmV4dE5leHRMYXllckNvbnRleHQhKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW5kZXIgYW4gb3ZlcmxheSBmb3IgdGhlIG5leHQgbmV4dCBsYXllclxuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ29udGV4dC5maWxsU3R5bGUgPSBEZWVwU2hlbGYuTkVYVF9MQVlFUl9PVkVSTEFZX0NPTE9SO1xuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWF0b3AnO1xuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ29udGV4dC5maWxsUmVjdChcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54LFxuICAgICAgICB0aGlzLnBvc2l0aW9uLnksXG4gICAgICAgIHNpemUueCxcbiAgICAgICAgc2l6ZS55XG4gICAgICApO1xuICAgICAgdGhpcy5uZXh0TmV4dExheWVyQ29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIC8vIERyYXcgdGhlIG5leHQgbmV4dCBsYXllciBjYW52YXMgb250byB0aGUgbWFpbiBjb250ZXh0XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSByZW1hcChcbiAgICAgICAgdGhpcy5jaGFuZ2luZ0xheWVyc1RpbWUsXG4gICAgICAgIERlZXBTaGVsZi5DSEFOR0lOR19MQVlFUlNfQU5JTUFUSU9OX1RJTUUsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIERlZXBTaGVsZi5ORVhUX0xBWUVSX0FMUEhBXG4gICAgICApO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArIGhhbGZTaXplLnggKyBEZWVwU2hlbGYuTkVYVF9MQVlFUl9PRkZTRVQueCxcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgaGFsZlNpemUueSArIERlZXBTaGVsZi5ORVhUX0xBWUVSX09GRlNFVC55XG4gICAgICApO1xuICAgICAgY29udGV4dC5zY2FsZShEZWVwU2hlbGYuTkVYVF9MQVlFUl9TQ0FMRSwgRGVlcFNoZWxmLk5FWFRfTEFZRVJfU0NBTEUpO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgIHRoaXMubmV4dE5leHRMYXllckNhbnZhcyxcbiAgICAgICAgLWhhbGZTaXplLngsXG4gICAgICAgIC1oYWxmU2l6ZS55LFxuICAgICAgICBzaXplLngsXG4gICAgICAgIHNpemUueVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIC8vIERyYXcgbmV4dCBsYXllcidzIHByb2R1Y3RzXG4gICAgaWYgKFxuICAgICAgdGhpcy5uZXh0TGF5ZXJDYW52YXMgJiZcbiAgICAgIHRoaXMubmV4dExheWVyQ29udGV4dCAmJlxuICAgICAgdGhpcy5sYXllcnMubGVuZ3RoID4gMVxuICAgICkge1xuICAgICAgdGhpcy5uZXh0TGF5ZXJDYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgICB0aGlzLm5leHRMYXllckNhbnZhcy5oZWlnaHQgPSBzaXplLnk7XG4gICAgICB0aGlzLm5leHRMYXllckNvbnRleHQuc2F2ZSgpO1xuICAgICAgdGhpcy5uZXh0TGF5ZXJDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICB0aGlzLm5leHRMYXllckNvbnRleHQudHJhbnNsYXRlKC10aGlzLnBvc2l0aW9uLngsIC10aGlzLnBvc2l0aW9uLnkpO1xuXG4gICAgICBjb25zdCBuZXh0TGF5ZXJJbmRleCA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDI7XG4gICAgICB0aGlzLmxheWVyc1tuZXh0TGF5ZXJJbmRleF0uZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgICAgaWYgKHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZHVjdC5kcmF3KHRoaXMubmV4dExheWVyQ29udGV4dCEpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbmRlciBhbiBvdmVybGF5IGZvciB0aGUgbmV4dCBsYXllclxuICAgICAgdGhpcy5uZXh0TGF5ZXJDb250ZXh0LmZpbGxTdHlsZSA9IERlZXBTaGVsZi5ORVhUX0xBWUVSX09WRVJMQVlfQ09MT1I7XG4gICAgICB0aGlzLm5leHRMYXllckNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1hdG9wJztcbiAgICAgIGlmICh0aGlzLmNoYW5naW5nTGF5ZXJzKSB7XG4gICAgICAgIHRoaXMubmV4dExheWVyQ29udGV4dC5nbG9iYWxBbHBoYSA9IHVubGVycChcbiAgICAgICAgICAwLFxuICAgICAgICAgIERlZXBTaGVsZi5DSEFOR0lOR19MQVlFUlNfQU5JTUFUSU9OX1RJTUUsXG4gICAgICAgICAgdGhpcy5jaGFuZ2luZ0xheWVyc1RpbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExheWVyQ29udGV4dC5maWxsUmVjdChcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54LFxuICAgICAgICB0aGlzLnBvc2l0aW9uLnksXG4gICAgICAgIHNpemUueCxcbiAgICAgICAgc2l6ZS55XG4gICAgICApO1xuICAgICAgdGhpcy5uZXh0TGF5ZXJDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgLy8gRHJhdyB0aGUgbmV4dCBsYXllciBjYW52YXMgb250byB0aGUgbWFpbiBjb250ZXh0XG4gICAgICBsZXQgbmV4dExheWVyQWxwaGEgPSBEZWVwU2hlbGYuTkVYVF9MQVlFUl9BTFBIQTtcbiAgICAgIGxldCBuZXh0TGF5ZXJPZmZzZXQgPSB2ZWMyLmNweShEZWVwU2hlbGYuTkVYVF9MQVlFUl9PRkZTRVQpO1xuICAgICAgbGV0IG5leHRMYXllclNjYWxlID0gRGVlcFNoZWxmLk5FWFRfTEFZRVJfU0NBTEU7XG4gICAgICBpZiAodGhpcy5jaGFuZ2luZ0xheWVycykge1xuICAgICAgICBjb25zdCBpID1cbiAgICAgICAgICAxIC1cbiAgICAgICAgICB1bmxlcnAoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgRGVlcFNoZWxmLkNIQU5HSU5HX0xBWUVSU19BTklNQVRJT05fVElNRSxcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdMYXllcnNUaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgbmV4dExheWVyQWxwaGEgPSBsZXJwKERlZXBTaGVsZi5ORVhUX0xBWUVSX0FMUEhBLCAxLCBpKTtcbiAgICAgICAgbmV4dExheWVyT2Zmc2V0ID0gdmVjMihcbiAgICAgICAgICBsZXJwKERlZXBTaGVsZi5ORVhUX0xBWUVSX09GRlNFVC54LCAwLCBpKSxcbiAgICAgICAgICBsZXJwKERlZXBTaGVsZi5ORVhUX0xBWUVSX09GRlNFVC55LCAwLCBpKVxuICAgICAgICApO1xuICAgICAgICBuZXh0TGF5ZXJTY2FsZSA9IGxlcnAoRGVlcFNoZWxmLk5FWFRfTEFZRVJfU0NBTEUsIDEsIGkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbmV4dExheWVyQWxwaGE7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICsgaGFsZlNpemUueCArIG5leHRMYXllck9mZnNldC54LFxuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKyBoYWxmU2l6ZS55ICsgbmV4dExheWVyT2Zmc2V0LnlcbiAgICAgICk7XG4gICAgICBjb250ZXh0LnNjYWxlKG5leHRMYXllclNjYWxlLCBuZXh0TGF5ZXJTY2FsZSk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXJDYW52YXMsXG4gICAgICAgIC1oYWxmU2l6ZS54LFxuICAgICAgICAtaGFsZlNpemUueSxcbiAgICAgICAgc2l6ZS54LFxuICAgICAgICBzaXplLnlcbiAgICAgICk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBjdXJyZW50IGxheWVyJ3MgcHJvZHVjdHNcbiAgICBzdXBlci5kcmF3KGNvbnRleHQpO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYSc7XG5pbXBvcnQgeyBBQUJCIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvMmQnO1xuaW1wb3J0IHsgaXNWZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvdXRpbGl0aWVzJztcbmltcG9ydCB7IGNsYW1wLCByZW1hcCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IExldmVsIGZyb20gJy4uL0xldmVsJztcbmltcG9ydCB7XG4gIEFic3RyYWN0U2hlbGZEYXRhLFxuICBpc0Fic3RyYWN0U2hlbGZEYXRhLFxuICBTaGVsZkZhY3RvcnksXG59IGZyb20gJy4uL1NoZWxmRmFjdG9yeSc7XG5pbXBvcnQgeyBQcm9kdWN0IH0gZnJvbSAnLi9Qcm9kdWN0JztcbmltcG9ydCB7IFNoZWxmIH0gZnJvbSAnLi9TaGVsZic7XG5cbmV4cG9ydCB0eXBlIERpc2FwcGVhcmluZ1NoZWxmRGF0YSA9IHtcbiAgc2hlbGY6IEFic3RyYWN0U2hlbGZEYXRhPFxuICAgICdzaGVsZicgfCAnZGVlcC1zaGVsZicgfCAnZGlzcGxheS1zaGVsZicgfCAnbG9ja2luZy1zaGVsZicgfCAnc3VwcGx5LXNoZWxmJ1xuICA+O1xuICBvZmZzZXQ/OiB2ZWMyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzYXBwZWFyaW5nU2hlbGZEYXRhKFxuICBkYXRhOiBhbnlcbik6IGRhdGEgaXMgRGlzYXBwZWFyaW5nU2hlbGZEYXRhIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICBpc0Fic3RyYWN0U2hlbGZEYXRhKGRhdGEuc2hlbGYsIFtcbiAgICAgICdzaGVsZicsXG4gICAgICAnZGVlcC1zaGVsZicsXG4gICAgICAnZGlzcGxheS1zaGVsZicsXG4gICAgICAnbG9ja2luZy1zaGVsZicsXG4gICAgICAnc3VwcGx5LXNoZWxmJyxcbiAgICBdKSAmJlxuICAgIChkYXRhLm9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGlzVmVjMihkYXRhLm9mZnNldCkpXG4gICk7XG59XG5cbi8qKlxuICogRGlzYXBwZWFyaW5nIHNoZWxmIGRpc2FwcGVhcnMgd2hlbiBjb21wbGV0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIERpc2FwcGVhcmluZ1NoZWxmIGV4dGVuZHMgU2hlbGYge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBESVNBUFBFQVJJTkdfQU5JTUFUSU9OX1RJTUU6IG51bWJlciA9IDAuNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRElTQVBQRUFSSU5HX0FOSU1BVElPTl9TQ0FMRV9BTU9VTlQ6IG51bWJlciA9IDEuMTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRElTQVBQRUFSSU5HX0FOSU1BVElPTl9HUk9XX1RJTUU6IG51bWJlciA9IDAuMjtcblxuICBwcml2YXRlIGRpc2FwcGVhcmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGRpc2FwcGVhcmluZ1RpbWU6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwdWJsaWMgc2hlbGY6IFNoZWxmLFxuICAgIHB1YmxpYyBvZmZzZXQ6IHZlYzIgPSB2ZWMyKClcbiAgKSB7XG4gICAgc3VwZXIobGV2ZWwsIFtdLCBvZmZzZXQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbURhdGEobGV2ZWw6IExldmVsLCBkYXRhOiBhbnkpOiBEaXNhcHBlYXJpbmdTaGVsZiB7XG4gICAgaWYgKCFpc0Rpc2FwcGVhcmluZ1NoZWxmRGF0YShkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpc2FwcGVhcmluZyBzaGVsZiBkYXRhJyk7XG4gICAgfVxuICAgIGNvbnN0IHNoZWxmID0gU2hlbGZGYWN0b3J5LmNyZWF0ZVNoZWxmKGxldmVsLCBkYXRhLnNoZWxmKTtcbiAgICByZXR1cm4gbmV3IERpc2FwcGVhcmluZ1NoZWxmKGxldmVsLCBzaGVsZiwgZGF0YS5vZmZzZXQgfHwgdmVjMigpKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlciwgbGV2ZWw6IExldmVsLCBjYW1lcmE6IENhbWVyYSkge1xuICAgIHRoaXMuc2hlbGYucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHRoaXMuc2hlbGYudXBkYXRlKGR0LCBsZXZlbCwgY2FtZXJhKTtcblxuICAgIGlmICh0aGlzLnNoZWxmSXNDb21wbGV0ZSgpICYmICF0aGlzLmRpc2FwcGVhcmluZykge1xuICAgICAgdGhpcy5kaXNhcHBlYXJpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lID0gRGlzYXBwZWFyaW5nU2hlbGYuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9USU1FO1xuXG4gICAgICAvLyBVcGRhdGUgc3RhdHNcbiAgICAgIGxldmVsLnN0YXRzLnRvdGFsQ29tcGxldGVkU2hlbHZlcysrO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBkaXNhcHBlYXJpbmcgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuZGlzYXBwZWFyaW5nKSB7XG4gICAgICB0aGlzLmRpc2FwcGVhcmluZ1RpbWUgPSBjbGFtcChcbiAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lIC0gZHQsXG4gICAgICAgIDAsXG4gICAgICAgIERpc2FwcGVhcmluZ1NoZWxmLkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmRpc2FwcGVhcmluZ1RpbWUgPD0gMCkge1xuICAgICAgICB0aGlzLnNoZWxmLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZpbmRTaGVsZlNsb3QoX3Byb2R1Y3Q6IFByb2R1Y3QpOiB7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICB9XG5cbiAgcHVibGljIGNhblBpY2tVcFByb2R1Y3RBdEluZGV4KF9wcm9kdWN0OiBQcm9kdWN0LCBfaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Ecm9wUHJvZHVjdEF0SW5kZXgoX3Byb2R1Y3Q6IFByb2R1Y3QsIF9pbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBzaGVsZklzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2hlbGYuc2hlbGZJc0NvbXBsZXRlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QUFCQihpbmRleD86IG51bWJlcik6IEFBQkIge1xuICAgIHJldHVybiB0aGlzLnNoZWxmLmdldEFBQkIoaW5kZXgpO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgY29uc3QgaGFsZlNpemUgPSB2ZWMyLnNjYWxlKHRoaXMuY2FsY3VsYXRlU2l6ZSgpLCAwLjUpO1xuICAgIGlmICh0aGlzLmRpc2FwcGVhcmluZykge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICsgaGFsZlNpemUueCxcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgaGFsZlNpemUueVxuICAgICAgKTtcbiAgICAgIGxldCBzY2FsZTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lID49XG4gICAgICAgIERpc2FwcGVhcmluZ1NoZWxmLkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRSAtXG4gICAgICAgICAgRGlzYXBwZWFyaW5nU2hlbGYuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9HUk9XX1RJTUVcbiAgICAgICkge1xuICAgICAgICBzY2FsZSA9IHJlbWFwKFxuICAgICAgICAgIHRoaXMuZGlzYXBwZWFyaW5nVGltZSxcbiAgICAgICAgICBEaXNhcHBlYXJpbmdTaGVsZi5ESVNBUFBFQVJJTkdfQU5JTUFUSU9OX1RJTUUsXG4gICAgICAgICAgRGlzYXBwZWFyaW5nU2hlbGYuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9USU1FIC1cbiAgICAgICAgICAgIERpc2FwcGVhcmluZ1NoZWxmLkRJU0FQUEVBUklOR19BTklNQVRJT05fR1JPV19USU1FLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgRGlzYXBwZWFyaW5nU2hlbGYuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9TQ0FMRV9BTU9VTlRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlID0gcmVtYXAoXG4gICAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lLFxuICAgICAgICAgIERpc2FwcGVhcmluZ1NoZWxmLkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRSAtXG4gICAgICAgICAgICBEaXNhcHBlYXJpbmdTaGVsZi5ESVNBUFBFQVJJTkdfQU5JTUFUSU9OX0dST1dfVElNRSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIERpc2FwcGVhcmluZ1NoZWxmLkRJU0FQUEVBUklOR19BTklNQVRJT05fU0NBTEVfQU1PVU5ULFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgICAtdGhpcy5wb3NpdGlvbi54IC0gaGFsZlNpemUueCxcbiAgICAgICAgLXRoaXMucG9zaXRpb24ueSAtIGhhbGZTaXplLnlcbiAgICAgICk7XG4gICAgICB0aGlzLnNoZWxmLmRyYXcoY29udGV4dCk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaGVsZi5kcmF3KGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IHsgcmVjdGFuZ2xlLCBTdHlsZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyBjbGFtcCwgcmVtYXAgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS91dGlscyc7XG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvdmVjJztcbmltcG9ydCBMZXZlbCBmcm9tICcuLi9MZXZlbCc7XG5pbXBvcnQgeyBQcm9kdWN0RmFjdG9yeSB9IGZyb20gJy4uL1Byb2R1Y3RGYWN0b3J5JztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuL1Byb2R1Y3QnO1xuaW1wb3J0IHtcbiAgaXNTaGVsZkRhdGEsXG4gIGlzU2hlbGZQcm9kdWN0c0RhdGEsXG4gIFNoZWxmLFxuICBTaGVsZkRhdGEsXG4gIFNoZWxmUHJvZHVjdHMsXG4gIFNoZWxmUHJvZHVjdHNEYXRhLFxufSBmcm9tICcuL1NoZWxmJztcblxuZXhwb3J0IHR5cGUgRGlzcGxheVNoZWxmRGF0YSA9IFNoZWxmRGF0YSAmIHtcbiAgYWxsb3dlZDogU2hlbGZQcm9kdWN0c0RhdGE7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXNwbGF5U2hlbGZEYXRhKGRhdGE6IGFueSk6IGRhdGEgaXMgRGlzcGxheVNoZWxmRGF0YSB7XG4gIHJldHVybiBpc1NoZWxmRGF0YShkYXRhKSAmJiBpc1NoZWxmUHJvZHVjdHNEYXRhKGRhdGEuYWxsb3dlZCk7XG59XG5cbi8qKlxuICogRGlzcGxheSBzaGVsZiByZXF1aXJlcyBzcGVjaWZpYyBpdGVtcyB0byBiZSBwbGFjZWQgaW4gc3BlY2lmaWMgc2xvdHNcbiAqXG4gKiBTbG90cyBjYW4gYmUgcmVzdHJpY3RlZCB0byBvbmx5IGFsbG93IHRoZXNlIGl0ZW1zIHRvIGJlIGRyb3BwZWQgaW4gdGhlIHNsb3RzXG4gKiBvciB0byBhbGxvdyBhbnkgaXRlbSB0byBiZSBkcm9wcGVkIGluIChhbHRob3VnaCB0byBtYXJrIHRoZSBzaGVsZiBhc1xuICogY29tcGxldGUgeW91IG11c3QgZHJvcCB0aGUgY29ycmVjdCBpdGVtcyBpbiB0aGUgc2xvdHMpXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNwbGF5U2hlbGYgZXh0ZW5kcyBTaGVsZiB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTVBMRVRJTkdfVElNRTogbnVtYmVyID0gMC41O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDT01QTEVUSU5HX1NUWUxFOiBQYXJ0aWFsPFN0eWxlT3B0aW9ucz4gPSB7XG4gICAgc3Ryb2tlOiBmYWxzZSxcbiAgICBmaWxsOiB0cnVlLFxuICAgIGZpbGxDb2xvcjogJ3JnYmEoMCwgMjU1LCAwLCAwLjUpJyxcbiAgfTtcblxuICBwdWJsaWMgY29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgY29tcGxldGluZ1RpbWU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgZmluaXNoZWRDb21wbGV0aW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwdWJsaWMgYWxsb3dlZDogU2hlbGZQcm9kdWN0cyxcbiAgICBwdWJsaWMgcHJvZHVjdHM6IFNoZWxmUHJvZHVjdHMsXG4gICAgcHVibGljIG9mZnNldDogdmVjMiA9IHZlYzIoKSxcbiAgICBwdWJsaWMgc2xvdENvdW50OiBudW1iZXIgPSBTaGVsZi5ERUZBVUxUX1NMT1RfQ09VTlQsXG4gICAgcHVibGljIG1hdGNoQ291bnQ6IG51bWJlciA9IFNoZWxmLkRFRkFVTFRfTUFUQ0hfQ09VTlQsXG4gICAgcHVibGljIGlnbm9yZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyByZWZlcmVuY2U/OiBzdHJpbmcsXG4gICAgYWRkVG9MZXZlbDogYm9vbGVhbiA9IHRydWVcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBsZXZlbCxcbiAgICAgIHByb2R1Y3RzLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc2xvdENvdW50LFxuICAgICAgbWF0Y2hDb3VudCxcbiAgICAgIGlnbm9yZSxcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGFkZFRvTGV2ZWxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tRGF0YShsZXZlbDogTGV2ZWwsIGRhdGE6IGFueSk6IERpc3BsYXlTaGVsZiB7XG4gICAgaWYgKCFpc0Rpc3BsYXlTaGVsZkRhdGEoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaXNwbGF5IHNoZWxmIGRhdGEnKTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dlZCA9IGRhdGEuYWxsb3dlZC5tYXAocHJvZHVjdElkID0+XG4gICAgICBwcm9kdWN0SWQgIT09IG51bGwgPyBQcm9kdWN0RmFjdG9yeS5jcmVhdGVQcm9kdWN0KGxldmVsLCBwcm9kdWN0SWQpIDogbnVsbFxuICAgICkgYXMgU2hlbGZQcm9kdWN0cztcbiAgICBjb25zdCBwcm9kdWN0cyA9IGRhdGEucHJvZHVjdHMubWFwKHByb2R1Y3RJZCA9PlxuICAgICAgcHJvZHVjdElkICE9PSBudWxsID8gUHJvZHVjdEZhY3RvcnkuY3JlYXRlUHJvZHVjdChsZXZlbCwgcHJvZHVjdElkKSA6IG51bGxcbiAgICApIGFzIFNoZWxmUHJvZHVjdHM7XG4gICAgcmV0dXJuIG5ldyBEaXNwbGF5U2hlbGYoXG4gICAgICBsZXZlbCxcbiAgICAgIGFsbG93ZWQsXG4gICAgICBwcm9kdWN0cyxcbiAgICAgIGRhdGEub2Zmc2V0IHx8IHZlYzIoKSxcbiAgICAgIGRhdGEuc2xvdENvdW50IHx8IFNoZWxmLkRFRkFVTFRfU0xPVF9DT1VOVCxcbiAgICAgIGRhdGEubWF0Y2hDb3VudCB8fCBTaGVsZi5ERUZBVUxUX01BVENIX0NPVU5ULFxuICAgICAgZGF0YS5pZ25vcmUgfHwgZmFsc2UsXG4gICAgICBkYXRhLnJlZmVyZW5jZSB8fCB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkdDogbnVtYmVyLCBsZXZlbDogTGV2ZWwsIGNhbWVyYTogQ2FtZXJhKSB7XG4gICAgY29uc3QgcHJvZHVjdFNpemUgPSBQcm9kdWN0LmNhbGN1bGF0ZVNpemUoKTtcbiAgICB0aGlzLmFsbG93ZWQuZm9yRWFjaCgocHJvZHVjdCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwcm9kdWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByb2R1Y3QucG9zaXRpb25JbW1lZGlhdGUgPSB2ZWMyLmFkZChcbiAgICAgICAgdGhpcy5wb3NpdGlvbixcbiAgICAgICAgdmVjMi5tdWwodmVjMihwcm9kdWN0U2l6ZS54LCAwKSwgaW5kZXgpXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMucHJvZHVjdHMuZm9yRWFjaCgocHJvZHVjdCwgaW5kZXgpID0+IHtcbiAgICAgIHByb2R1Y3Q/LnVwZGF0ZShkdCwgbGV2ZWwsIGNhbWVyYSwgdGhpcywgaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgYSBtYXRjaCBpcyBmb3VuZCwgY29tcGxldGUgdGhlIHNoZWxmXG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNoZWNrRm9yTWF0Y2hlcygpO1xuICAgIGlmIChtYXRjaC5mb3VuZCkge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjb21wbGV0aW5nIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLmNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5jb21wbGV0aW5nVGltZSA9IGNsYW1wKFxuICAgICAgICB0aGlzLmNvbXBsZXRpbmdUaW1lICsgZHQsXG4gICAgICAgIDAsXG4gICAgICAgIERpc3BsYXlTaGVsZi5DT01QTEVUSU5HX1RJTUVcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5jb21wbGV0aW5nVGltZSA+PSBEaXNwbGF5U2hlbGYuQ09NUExFVElOR19USU1FKSB7XG4gICAgICAgIHRoaXMuZmluaXNoZWRDb21wbGV0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3RhdHNcbiAgICBpZiAoIXRoaXMuc3RhdHNVcGRhdGVkKSB7XG4gICAgICBpZiAobWF0Y2guZm91bmQpIHtcbiAgICAgICAgbWF0Y2gubWF0Y2hlcy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xuICAgICAgICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICAgICAgICBsZXZlbC5zdGF0cy5wcm9kdWN0TWF0Y2hlc1twcm9kdWN0LmlkXS50b3RhbCsrO1xuICAgICAgICAgICAgbGV2ZWwuc3RhdHMudG90YWxNYXRjaGVzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0c1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hlbGZJc0NvbXBsZXRlKCkpIHtcbiAgICAgICAgbGV2ZWwuc3RhdHMudG90YWxDb21wbGV0ZWRTaGVsdmVzKys7XG4gICAgICAgIHRoaXMuc3RhdHNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tGb3JNYXRjaGVzKCk6IHtcbiAgICBmb3VuZDogYm9vbGVhbjtcbiAgICBtYXRjaGVzOiBQcm9kdWN0W107XG4gIH0ge1xuICAgIGxldCBtYXRjaGVzOiBQcm9kdWN0W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgYWxsb3dlZF0gb2YgdGhpcy5hbGxvd2VkLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGFsbG93ZWQgPT09IG51bGwgJiYgdGhpcy5wcm9kdWN0c1tpbmRleF0gPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGFsbG93ZWQgIT09IG51bGwgJiZcbiAgICAgICAgdGhpcy5wcm9kdWN0c1tpbmRleF0gIT09IG51bGwgJiZcbiAgICAgICAgdGhpcy5wcm9kdWN0c1tpbmRleF0/Lm1hdGNoZXNQcm9kdWN0KGFsbG93ZWQpXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHRoaXMucHJvZHVjdHNbaW5kZXhdISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZm91bmQ6IGZhbHNlLCBtYXRjaGVzOiBbXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBmb3VuZDogdHJ1ZSwgbWF0Y2hlcyB9O1xuICB9XG5cbiAgcHVibGljIGNhblBpY2tVcFByb2R1Y3RBdEluZGV4KHByb2R1Y3Q6IFByb2R1Y3QsIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gQ2Fubm90IHBpY2sgdXAgcHJvZHVjdHMgZnJvbSBhIGNvbXBsZXRlZCBzaGVsZlxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2FuUGlja1VwUHJvZHVjdEF0SW5kZXgocHJvZHVjdCwgaW5kZXgpO1xuICB9XG5cbiAgcHVibGljIGNhbkRyb3BQcm9kdWN0QXRJbmRleChwcm9kdWN0OiBQcm9kdWN0LCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIENhbm5vdCBkcm9wIHByb2R1Y3RzIG9uIGEgY29tcGxldGVkIHNoZWxmXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5jYW5Ecm9wUHJvZHVjdEF0SW5kZXgocHJvZHVjdCwgaW5kZXgpO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21wbGV0ZWQ7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBzdXBlci5kcmF3KGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmFsbG93ZWQuZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgIGlmIChwcm9kdWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByb2R1Y3QuZHJhd091dGxpbmUoY29udGV4dCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9kdWN0cy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xuICAgICAgaWYgKHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByb2R1Y3QuZHJhZ2dpbmcpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBXZSB3aWxsIGRyYXcgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIHByb2R1Y3Qgc2VwYXJhdGVseVxuICAgICAgfVxuICAgICAgcHJvZHVjdC5kcmF3KGNvbnRleHQpO1xuICAgIH0pO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgaWYgKHRoaXMuY29tcGxldGVkKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5jYWxjdWxhdGVTaXplKCk7XG4gICAgICBjb25zdCBjb21wbGV0aW5nQW1vdW50ID0gdGhpcy5maW5pc2hlZENvbXBsZXRpbmdcbiAgICAgICAgPyBzaXplLnlcbiAgICAgICAgOiByZW1hcChcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGluZ1RpbWUsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgRGlzcGxheVNoZWxmLkNPTVBMRVRJTkdfVElNRSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBzaXplLnlcbiAgICAgICAgICApO1xuICAgICAgcmVjdGFuZ2xlKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgICB2ZWMyKHNpemUueCwgY29tcGxldGluZ0Ftb3VudCksXG4gICAgICAgIERpc3BsYXlTaGVsZi5DT01QTEVUSU5HX1NUWUxFXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IENhbWVyYSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW1lcmEnO1xuaW1wb3J0IHsgcmVjdGFuZ2xlLCBTdHlsZU9wdGlvbnMgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9jYW52YXMtaGVscGVycyc7XG5pbXBvcnQgeyBBQUJCIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvMmQnO1xuaW1wb3J0IHsgaXNWZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvdXRpbGl0aWVzJztcbmltcG9ydCB7IGNsYW1wLCByZW1hcCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IExldmVsIGZyb20gJy4uL0xldmVsJztcbmltcG9ydCB7IFByb2R1Y3RGYWN0b3J5IH0gZnJvbSAnLi4vUHJvZHVjdEZhY3RvcnknO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RTaGVsZkRhdGEsXG4gIGlzQWJzdHJhY3RTaGVsZkRhdGEsXG4gIFNoZWxmRmFjdG9yeSxcbn0gZnJvbSAnLi4vU2hlbGZGYWN0b3J5JztcbmltcG9ydCB7IFByb2R1Y3QgfSBmcm9tICcuL1Byb2R1Y3QnO1xuaW1wb3J0IHsgU2hlbGYgfSBmcm9tICcuL1NoZWxmJztcblxuZXhwb3J0IHR5cGUgTG9ja2luZ01vZGVEYXRhID1cbiAgfCB7XG4gICAgICBtb2RlOiAndG9nZ2xlLXRpbWVyJztcbiAgICAgIHRpbWU6IG51bWJlcjtcbiAgICAgIGluaXRpYWxseUxvY2tlZDogYm9vbGVhbjtcbiAgICAgIGZpbmFsQ291bnRkb3duVW5sb2NrPzogbnVtYmVyO1xuICAgIH1cbiAgfCB7XG4gICAgICBtb2RlOiAnY291bnRkb3duLXRpbWVyJztcbiAgICAgIHRpbWU6IG51bWJlcjtcbiAgICB9XG4gIHwge1xuICAgICAgbW9kZTogJ21hdGNoLXByb2R1Y3RzJztcbiAgICAgIHByb2R1Y3Q/OiBzdHJpbmc7XG4gICAgICBuOiBudW1iZXI7XG4gICAgfVxuICB8IHtcbiAgICAgIG1vZGU6ICdjb21wbGV0ZS1zaGVsdmVzJztcbiAgICAgIG46IG51bWJlcjtcbiAgICB9XG4gIHwge1xuICAgICAgbW9kZTogJ2NvbXBsZXRlLXNoZWxmJztcbiAgICAgIHNoZWxmUmVmZXJlbmNlOiBudW1iZXI7XG4gICAgfVxuICB8IHtcbiAgICAgIG1vZGU6ICdwbGFjZS1wcm9kdWN0JztcbiAgICAgIHNoZWxmUmVmZXJlbmNlOiBzdHJpbmc7XG4gICAgICBzbG90OiBudW1iZXI7XG4gICAgICBsYXRjaD86IGJvb2xlYW47XG4gICAgICBpbnZlcnRlZD86IGJvb2xlYW47XG4gICAgICBwcm9kdWN0Pzogc3RyaW5nO1xuICAgIH07XG5cbmV4cG9ydCB0eXBlIExvY2tpbmdNb2RlID0gTG9ja2luZ01vZGVEYXRhICYge1xuICBwcm9kdWN0PzogUHJvZHVjdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2tpbmdNb2RlRGF0YShkYXRhOiBhbnkpOiBkYXRhIGlzIExvY2tpbmdNb2RlRGF0YSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgIWRhdGEubW9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKGRhdGEubW9kZSkge1xuICAgIGNhc2UgJ3RvZ2dsZS10aW1lcic6XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZGF0YS50aW1lID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZGF0YS5pbml0aWFsbHlMb2NrZWQgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAoZGF0YS5maW5hbENvdW50ZG93blVubG9jayA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIGRhdGEuZmluYWxDb3VudGRvd25VbmxvY2sgPT09ICdudW1iZXInKVxuICAgICAgKTtcblxuICAgIGNhc2UgJ2NvdW50ZG93bi10aW1lcic6XG4gICAgICByZXR1cm4gdHlwZW9mIGRhdGEudGltZSA9PT0gJ251bWJlcic7XG5cbiAgICBjYXNlICdtYXRjaC1wcm9kdWN0cyc6XG4gICAgICByZXR1cm4gdHlwZW9mIGRhdGEucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRhdGEubiA9PT0gJ251bWJlcic7XG5cbiAgICBjYXNlICdjb21wbGV0ZS1zaGVsdmVzJzpcbiAgICAgIHJldHVybiB0eXBlb2YgZGF0YS5uID09PSAnbnVtYmVyJztcblxuICAgIGNhc2UgJ2NvbXBsZXRlLXNoZWxmJzpcbiAgICAgIHJldHVybiB0eXBlb2YgZGF0YS5zaGVsZkluZGV4ID09PSAnbnVtYmVyJztcblxuICAgIGNhc2UgJ3BsYWNlLXByb2R1Y3QnOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIGRhdGEuc2hlbGZJbmRleCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEuc2xvdEluZGV4ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAoZGF0YS5sYXRjaCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBkYXRhLmxhdGNoID09PSAnYm9vbGVhbicpICYmXG4gICAgICAgIChkYXRhLmludmVydGVkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEuaW52ZXJ0ZWQgPT09ICdib29sZWFuJykgJiZcbiAgICAgICAgKGRhdGEucHJvZHVjdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBkYXRhLnByb2R1Y3QgPT09ICdzdHJpbmcnKVxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIExvY2tpbmdTaGVsZkRhdGEgPSB7XG4gIHNoZWxmOiBBYnN0cmFjdFNoZWxmRGF0YTxcbiAgICB8ICdzaGVsZidcbiAgICB8ICdjbG9zaW5nLXNoZWxmJ1xuICAgIHwgJ2RlZXAtc2hlbGYnXG4gICAgfCAnZGlzYXBwZWFyaW5nLXNoZWxmJ1xuICAgIHwgJ2Rpc3BsYXktc2hlbGYnXG4gICAgfCAnc3VwcGx5LXNoZWxmJ1xuICA+O1xuICBsb2NraW5nOiBMb2NraW5nTW9kZURhdGE7XG4gIG9mZnNldD86IHZlYzI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NraW5nU2hlbGZEYXRhKGRhdGE6IGFueSk6IGRhdGEgaXMgTG9ja2luZ1NoZWxmRGF0YSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgaXNBYnN0cmFjdFNoZWxmRGF0YShkYXRhLnNoZWxmLCBbXG4gICAgICAnc2hlbGYnLFxuICAgICAgJ2Nsb3Npbmctc2hlbGYnLFxuICAgICAgJ2RlZXAtc2hlbGYnLFxuICAgICAgJ2Rpc2FwcGVhcmluZy1zaGVsZicsXG4gICAgICAnZGlzcGxheS1zaGVsZicsXG4gICAgICAnc3VwcGx5LXNoZWxmJyxcbiAgICBdKSAmJlxuICAgIGlzTG9ja2luZ01vZGVEYXRhKGRhdGEubG9ja2luZykgJiZcbiAgICAoZGF0YS5vZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBpc1ZlYzIoZGF0YS5vZmZzZXQpKVxuICApO1xufVxuXG4vKipcbiAqIExvY2tpbmcgc2hlbGYgaXMgbG9ja2VkIG9yIHVubG9ja2VkIGJhc2VkIG9uIHNvbWUgY3JpdGVyaWFcbiAqXG4gKiBMb2NrZWQgc2hlbHZlcyBjYW5ub3QgaGF2ZSBwcm9kdWN0cyBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlbVxuICovXG5leHBvcnQgY2xhc3MgTG9ja2luZ1NoZWxmIGV4dGVuZHMgU2hlbGYge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBMT0NLSU5HX1RJTUU6IG51bWJlciA9IDAuMztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTE9DS0lOR19TVFlMRTogUGFydGlhbDxTdHlsZU9wdGlvbnM+ID0ge1xuICAgIHN0cm9rZTogZmFsc2UsXG4gICAgZmlsbDogdHJ1ZSxcbiAgICBmaWxsQ29sb3I6ICdyZ2JhKDI1NSwgMTI4LCAwLCAwLjUpJyxcbiAgfTtcblxuICBwdWJsaWMgbG9ja2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgbG9ja2luZ1RpbWU6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwdWJsaWMgc2hlbGY6IFNoZWxmLFxuICAgIHB1YmxpYyBsb2NraW5nOiBMb2NraW5nTW9kZSxcbiAgICBwdWJsaWMgb2Zmc2V0OiB2ZWMyID0gdmVjMigpXG4gICkge1xuICAgIGNvbnN0IG9yaWdpbmFsU2hlbGZDYW5Ecm9wUHJvZHVjdEF0SW5kZXggPVxuICAgICAgc2hlbGYuY2FuRHJvcFByb2R1Y3RBdEluZGV4LmJpbmQoc2hlbGYpO1xuICAgIHNoZWxmLmNhbkRyb3BQcm9kdWN0QXRJbmRleCA9IChcbiAgICAgIHByb2R1Y3Q6IFByb2R1Y3QsXG4gICAgICBpbmRleDogbnVtYmVyXG4gICAgKTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU2hlbGZDYW5Ecm9wUHJvZHVjdEF0SW5kZXgocHJvZHVjdCwgaW5kZXgpO1xuICAgIH07XG4gICAgY29uc3Qgb3JpZ2luYWxTaGVsZkNhblBpY2tVcFByb2R1Y3RBdEluZGV4ID1cbiAgICAgIHNoZWxmLmNhblBpY2tVcFByb2R1Y3RBdEluZGV4LmJpbmQoc2hlbGYpO1xuICAgIHNoZWxmLmNhblBpY2tVcFByb2R1Y3RBdEluZGV4ID0gKFxuICAgICAgcHJvZHVjdDogUHJvZHVjdCxcbiAgICAgIGluZGV4OiBudW1iZXJcbiAgICApOiBib29sZWFuID0+IHtcbiAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTaGVsZkNhblBpY2tVcFByb2R1Y3RBdEluZGV4KHByb2R1Y3QsIGluZGV4KTtcbiAgICB9O1xuICAgIHN1cGVyKGxldmVsLCBbXSwgb2Zmc2V0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EYXRhKGxldmVsOiBMZXZlbCwgZGF0YTogYW55KTogTG9ja2luZ1NoZWxmIHtcbiAgICBpZiAoIWlzTG9ja2luZ1NoZWxmRGF0YShkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxvY2tpbmcgc2hlbGYgZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBzaGVsZiA9IFNoZWxmRmFjdG9yeS5jcmVhdGVTaGVsZihsZXZlbCwgZGF0YS5zaGVsZik7XG4gICAgbGV0IGxvY2tpbmc6IExvY2tpbmdNb2RlO1xuICAgIGlmICgncHJvZHVjdCcgaW4gZGF0YS5sb2NraW5nICYmIGRhdGEubG9ja2luZy5wcm9kdWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvY2tpbmcgPSB7XG4gICAgICAgIC4uLmRhdGEubG9ja2luZyxcbiAgICAgICAgcHJvZHVjdDogUHJvZHVjdEZhY3RvcnkuY3JlYXRlUHJvZHVjdChsZXZlbCwgZGF0YS5sb2NraW5nLnByb2R1Y3QpLFxuICAgICAgfSBhcyBMb2NraW5nTW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9ja2luZyA9IHsgLi4uZGF0YS5sb2NraW5nIH0gYXMgTG9ja2luZ01vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9ja2luZ1NoZWxmKGxldmVsLCBzaGVsZiwgbG9ja2luZywgZGF0YS5vZmZzZXQgfHwgdmVjMigpKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZHQ6IG51bWJlciwgbGV2ZWw6IExldmVsLCBjYW1lcmE6IENhbWVyYSkge1xuICAgIHRoaXMuc2hlbGYucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHRoaXMuc2hlbGYudXBkYXRlKGR0LCBsZXZlbCwgY2FtZXJhKTtcblxuICAgIC8vIEhhbmRsZSBsb2NraW5nIGFuZCB1bmxvY2tpbmdcbiAgICB0aGlzLmxvY2tlZCA9IHRoaXMuc2hlbGZJc0xvY2tlZChsZXZlbCk7XG5cbiAgICAvLyBIYW5kbGUgbG9ja2luZyBhbmltYXRpb25cbiAgICB0aGlzLmxvY2tpbmdUaW1lID0gY2xhbXAoXG4gICAgICB0aGlzLmxvY2tpbmdUaW1lICsgKHRoaXMubG9ja2VkID8gZHQgOiAtZHQpLFxuICAgICAgMCxcbiAgICAgIExvY2tpbmdTaGVsZi5MT0NLSU5HX1RJTUVcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzaGVsZklzTG9ja2VkKGxldmVsOiBMZXZlbCk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAodGhpcy5sb2NraW5nLm1vZGUpIHtcbiAgICAgIGNhc2UgJ3RvZ2dsZS10aW1lcic6XG4gICAgICAgIC8vIFRvZ2dsZSBiZXR3ZWVuIGxvY2tlZCBhbmQgdW5sb2NrZWQgb24gYSB0aW1lclxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5sb2NraW5nLmZpbmFsQ291bnRkb3duVW5sb2NrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBsZXZlbC5kYXRhLnRpbWVMaW1pdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgbGV2ZWwuZGF0YS50aW1lTGltaXQgLSBsZXZlbC5zdGF0cy50aW1lIDw9XG4gICAgICAgICAgICB0aGlzLmxvY2tpbmcuZmluYWxDb3VudGRvd25VbmxvY2tcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBVbmxvY2sgZHVyaW5nIHRoZSBsYXN0IG4gc2Vjb25kc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgTWF0aC5mbG9vcihcbiAgICAgICAgICAgIGxldmVsLnN0YXRzLnRpbWUgLyB0aGlzLmxvY2tpbmcudGltZSArXG4gICAgICAgICAgICAgICh0aGlzLmxvY2tpbmcuaW5pdGlhbGx5TG9ja2VkID8gMCA6IDAuNSlcbiAgICAgICAgICApICVcbiAgICAgICAgICAgIDIgPT09XG4gICAgICAgICAgMFxuICAgICAgICApO1xuXG4gICAgICBjYXNlICdjb3VudGRvd24tdGltZXInOlxuICAgICAgICAvLyBVbmxvY2sgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZSBoYXMgcGFzc2VkXG4gICAgICAgIHJldHVybiBsZXZlbC5zdGF0cy50aW1lID4gdGhpcy5sb2NraW5nLnRpbWU7XG5cbiAgICAgIGNhc2UgJ21hdGNoLXByb2R1Y3RzJzpcbiAgICAgICAgLy8gVW5sb2NrIHdoZW4gYSBjZXJ0YWluIG51bWJlciBvZiBwcm9kdWN0cyAob3B0aW9uYWxseSBhIHNwZWNpZmljIHR5cGVcbiAgICAgICAgLy8gb2YgcHJvZHVjdCkgaGF2ZSBiZWVuIG1hdGNoZWRcbiAgICAgICAgaWYgKCdwcm9kdWN0JyBpbiB0aGlzLmxvY2tpbmcgJiYgdGhpcy5sb2NraW5nLnByb2R1Y3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBPYmplY3QudmFsdWVzKGxldmVsLnN0YXRzLnByb2R1Y3RNYXRjaGVzKS5maWx0ZXIoXG4gICAgICAgICAgICAoeyBwcm9kdWN0LCB0b3RhbCB9KSA9PlxuICAgICAgICAgICAgICB0aGlzLmxvY2tpbmcucHJvZHVjdCEubWF0Y2hlc1Byb2R1Y3QocHJvZHVjdCkgJiZcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICB0b3RhbCA+PSB0aGlzLmxvY2tpbmcubiFcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxldmVsLnN0YXRzLnRvdGFsTWF0Y2hlcyA+PSB0aGlzLmxvY2tpbmcubjtcblxuICAgICAgY2FzZSAnY29tcGxldGUtc2hlbHZlcyc6XG4gICAgICAgIC8vIFVubG9jayB3aGVuIGEgY2VydGFpbiBudW1iZXIgb2Ygc2hlbHZlcyBoYXZlIGJlZW4gY29tcGxldGVkXG4gICAgICAgIHJldHVybiBsZXZlbC5zdGF0cy50b3RhbENvbXBsZXRlZFNoZWx2ZXMgPj0gdGhpcy5sb2NraW5nLm47XG5cbiAgICAgIGNhc2UgJ2NvbXBsZXRlLXNoZWxmJzpcbiAgICAgICAgLy8gVW5sb2NrIHdoZW4gYSBzcGVjaWZpYyBzaGVsZiBoYXMgYmVlbiBjb21wbGV0ZWRcbiAgICAgICAgcmV0dXJuICEhbGV2ZWwuc3RhdHMuY29tcGxldGVkU2hlbHZlc1t0aGlzLmxvY2tpbmcuc2hlbGZSZWZlcmVuY2VdXG4gICAgICAgICAgPy5jb21wbGV0ZWQ7XG5cbiAgICAgIGNhc2UgJ3BsYWNlLXByb2R1Y3QnOlxuICAgICAgICAvLyBVbmxvY2sgd2hlbiBhbnkgcHJvZHVjdCBvciBhIHNwZWNpZmljIHByb2R1Y3QgaXMgcGxhY2VkIGluIHRoZVxuICAgICAgICAvLyBzcGVjaWZpZWQgc2hlbGYgc2xvdFxuICAgICAgICBsZXQgbG9ja2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmxvY2tpbmcubGF0Y2gpIHtcbiAgICAgICAgICAvLyBJbiBsYXRjaCBtb2RlLCB3ZSBjaGVjayBpZiB0aGUgcHJvZHVjdCB3YXMgZXZlciBwbGFjZWQgaW4gdGhlIHNsb3RcbiAgICAgICAgICBsb2NrZWQgPSBsZXZlbC5zdGF0cy5wcm9kdWN0UGxhY2VtZW50cy5zb21lKFxuICAgICAgICAgICAgKHsgc2hlbGYsIHNsb3QsIHByb2R1Y3QgfSkgPT5cbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBzaGVsZi5yZWZlcmVuY2UgPT09IHRoaXMubG9ja2luZy5zaGVsZlJlZmVyZW5jZSAmJlxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIHNsb3QgPT09IHRoaXMubW9kZS5zbG90ICYmXG4gICAgICAgICAgICAgICh0aGlzLmxvY2tpbmcucHJvZHVjdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgcHJvZHVjdC5tYXRjaGVzUHJvZHVjdCh0aGlzLmxvY2tpbmcucHJvZHVjdCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbiBub24tbGF0Y2ggbW9kZSwgd2UgY2hlY2sgaWYgdGhlIHByb2R1Y3QgaXMgY3VycmVudGx5IGluIHRoZSBzbG90XG4gICAgICAgICAgbG9ja2VkID0gT2JqZWN0LnZhbHVlcyhsZXZlbC5zdGF0cy5jdXJyZW50UHJvZHVjdFBsYWNlbWVudCkuc29tZShcbiAgICAgICAgICAgICh7IHNoZWxmLCBwcm9kdWN0cyB9KSA9PlxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgIHNoZWxmLnJlZmVyZW5jZSA9PT0gdGhpcy5sb2NraW5nLnNoZWxmUmVmZXJlbmNlICYmXG4gICAgICAgICAgICAgIHByb2R1Y3RzLnNvbWUoXG4gICAgICAgICAgICAgICAgKHByb2R1Y3QsIGluZGV4KSA9PlxuICAgICAgICAgICAgICAgICAgcHJvZHVjdCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgaW5kZXggPT09IHRoaXMubW9kZS5zbG90ICYmXG4gICAgICAgICAgICAgICAgICAodGhpcy5sb2NraW5nLnByb2R1Y3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0Lm1hdGNoZXNQcm9kdWN0KHRoaXMubG9ja2luZy5wcm9kdWN0KSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja2luZy5pbnZlcnRlZCA/ICFsb2NrZWQgOiBsb2NrZWQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZpbmRTaGVsZlNsb3QoX3Byb2R1Y3Q6IFByb2R1Y3QpOiB7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG4gIH0ge1xuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICB9XG5cbiAgcHVibGljIGNhblBpY2tVcFByb2R1Y3RBdEluZGV4KF9wcm9kdWN0OiBQcm9kdWN0LCBfaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Ecm9wUHJvZHVjdEF0SW5kZXgoX3Byb2R1Y3Q6IFByb2R1Y3QsIF9pbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBzaGVsZklzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2hlbGYuc2hlbGZJc0NvbXBsZXRlKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QUFCQihpbmRleD86IG51bWJlcik6IEFBQkIge1xuICAgIHJldHVybiB0aGlzLnNoZWxmLmdldEFBQkIoaW5kZXgpO1xuICB9XG5cbiAgcHVibGljIGRyYXcoY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gICAgdGhpcy5zaGVsZi5kcmF3KGNvbnRleHQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcbiAgICBjb25zdCBsb2NrZWRBbW91bnQgPSByZW1hcChcbiAgICAgIHRoaXMubG9ja2luZ1RpbWUsXG4gICAgICAwLFxuICAgICAgTG9ja2luZ1NoZWxmLkxPQ0tJTkdfVElNRSxcbiAgICAgIDAsXG4gICAgICBzaXplLnlcbiAgICApO1xuICAgIHJlY3RhbmdsZShcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aGlzLnBvc2l0aW9uLFxuICAgICAgdmVjMihzaXplLngsIGxvY2tlZEFtb3VudCksXG4gICAgICBMb2NraW5nU2hlbGYuTE9DS0lOR19TVFlMRVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FtZXJhJztcbmltcG9ydCB7IHJlY3RhbmdsZSwgU3R5bGVPcHRpb25zIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvY2FudmFzLWhlbHBlcnMnO1xuaW1wb3J0IElucHV0TWFuYWdlciBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS9pbnB1dC1tYW5hZ2VyJztcbmltcG9ydCB7IEFBQkIsIHBvaW50SW5BQUJCIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvMmQnO1xuaW1wb3J0IHsgdmVjdG9yc0FsbW9zdEVxdWFsIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvdXRpbGl0aWVzJztcbmltcG9ydCB7IGNsYW1wLCByZW1hcCB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgQWN0b3IsIFNoZWxmIH0gZnJvbSAnLic7XG5pbXBvcnQgR2FtZSBmcm9tICcuLi9HYW1lJztcbmltcG9ydCB7IEdhbWVTY2VuZSB9IGZyb20gJy4uL0dhbWVTY2VuZSc7XG5pbXBvcnQgTGV2ZWwgZnJvbSAnLi4vTGV2ZWwnO1xuXG5leHBvcnQgdHlwZSBQcm9kdWN0RGF0YSA9IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBpbWFnZTogc3RyaW5nO1xuICBtYXRjaGVzOiBzdHJpbmdbXTtcbiAgcG9pbnRzPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvZHVjdERhdGEoZGF0YTogYW55KTogZGF0YSBpcyBQcm9kdWN0RGF0YSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGRhdGEuaWQgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGRhdGEubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgZGF0YS5pbWFnZSA9PT0gJ3N0cmluZycgJiZcbiAgICBBcnJheS5pc0FycmF5KGRhdGEubWF0Y2hlcykgJiZcbiAgICBkYXRhLm1hdGNoZXMuZXZlcnkoKG1hdGNoOiBhbnkpID0+IHR5cGVvZiBtYXRjaCA9PT0gJ3N0cmluZycpICYmXG4gICAgKGRhdGEucG9pbnRzID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEucG9pbnRzID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFByb2R1Y3QgZXh0ZW5kcyBBY3RvciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9QT0lOVFM6IG51bWJlciA9IDE7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEFTUEVDVF9SQVRJTzogbnVtYmVyID0gMS41O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVFlMRTogUGFydGlhbDxTdHlsZU9wdGlvbnM+ID0ge1xuICAgIGZpbGw6IHRydWUsXG4gICAgc3Ryb2tlOiBmYWxzZSxcbiAgfTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgT1VUTElORV9TVFlMRTogUGFydGlhbDxTdHlsZU9wdGlvbnM+ID0ge1xuICAgIGZpbGw6IGZhbHNlLFxuICAgIHN0cm9rZTogdHJ1ZSxcbiAgICBzdHJva2VDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsXG4gICAgbGluZVN0eWxlOiAnZG90dGVkJyxcbiAgfTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQkFDS0dST1VORF9DT0xPUjogc3RyaW5nID0gJ3doaXRlJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQkFDS0dST1VORF9IT1ZFUl9DT0xPUjogc3RyaW5nID0gJ2dyZWVuJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTU9WRV9FQVNFX0FNT1VOVDogbnVtYmVyID0gMC4zNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTU9WRV9DT09MRE9XTl9USU1FOiBudW1iZXIgPSAwLjc1O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBEUkFHX1JPVEFUSU9OX0FNT1VOVDogbnVtYmVyID0gMC4wMjtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUk9UQVRJT05fRUFTRV9BTU9VTlQ6IG51bWJlciA9IDAuMzU7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1BWF9ST1RBVElPTjogbnVtYmVyID0gTWF0aC5QSSAvIDQ7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IExBTkRJTkdfQU5JTUFUSU9OX1RJTUU6IG51bWJlciA9IDAuNDtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTEFORElOR19BTklNQVRJT05fU1RBUlRfUkFOR0U6IG51bWJlciA9IDU7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IExBTkRJTkdfQU5JTUFUSU9OX1hfU0NBTEVfQU1PVU5UOiBudW1iZXIgPSAwLjI7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IExBTkRJTkdfQU5JTUFUSU9OX1lfU0NBTEVfQU1PVU5UOiBudW1iZXIgPSAtMC4zO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBESVNBUFBFQVJJTkdfQU5JTUFUSU9OX1RJTUU6IG51bWJlciA9IDAuNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRElTQVBQRUFSSU5HX0FOSU1BVElPTl9TQ0FMRV9BTU9VTlQ6IG51bWJlciA9IDEuMjtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRElTQVBQRUFSSU5HX0FOSU1BVElPTl9HUk9XX1RJTUU6IG51bWJlciA9IDAuMjtcblxuICBwdWJsaWMgc2l6ZTogdmVjMiA9IHZlYzIoKTtcblxuICBwdWJsaWMgaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGZpbmlzaGVkTW92aW5nOiBib29sZWFuID0gdHJ1ZTtcblxuICBwdWJsaWMgZHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBkcmFnT2Zmc2V0OiB2ZWMyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSB0YXJnZXRQb3NpdGlvbjogdmVjMiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGFjdHVhbFBvc2l0aW9uOiB2ZWMyID0gdmVjMigpO1xuICBwcml2YXRlIG1vdmVUaW1lOiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgdGFyZ2V0Um90YXRpb246IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGFjdHVhbFJvdGF0aW9uOiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyB2ZWxvY2l0eTogdmVjMiA9IHZlYzIoKTtcbiAgcHJpdmF0ZSBwcmV2aW91c1Bvc2l0aW9uOiB2ZWMyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBsYW5kaW5nVGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBwcmV2aW91c1NoZWxmQW5kU2xvdDoge1xuICAgIHNoZWxmOiBTaGVsZjtcbiAgICBzbG90SW5kZXg6IG51bWJlcjtcbiAgfSB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyBkaXNhcHBlYXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHN0YXJ0ZWREaXNhcHBlYXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGZpbmlzaGVkRGlzYXBwZWFyaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZGlzYXBwZWFyaW5nVGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBkaXNhcHBlYXJpbmdEZWxheTogbnVtYmVyID0gMDtcblxuICBwdWJsaWMgbG9ja2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBwdWJsaWMgaWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyBpbWFnZTogc3RyaW5nLFxuICAgIHB1YmxpYyBtYXRjaGVzOiBzdHJpbmdbXSxcbiAgICBwdWJsaWMgcG9pbnRzOiBudW1iZXIgPSBQcm9kdWN0LkRFRkFVTFRfUE9JTlRTXG4gICkge1xuICAgIHN1cGVyKGxldmVsKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbURhdGEobGV2ZWw6IExldmVsLCBkYXRhOiBhbnkpOiBQcm9kdWN0IHtcbiAgICBpZiAoIWlzUHJvZHVjdERhdGEoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9kdWN0IGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9kdWN0KFxuICAgICAgbGV2ZWwsXG4gICAgICBkYXRhLmlkLFxuICAgICAgZGF0YS5uYW1lLFxuICAgICAgZGF0YS5pbWFnZSxcbiAgICAgIGRhdGEubWF0Y2hlcyxcbiAgICAgIGRhdGEucG9pbnRzXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY2FsY3VsYXRlU2l6ZSgpOiB2ZWMyIHtcbiAgICBjb25zdCBzaXplID0gdmVjMigpO1xuICAgIHNpemUueCA9IEdhbWUuc2NyZWVuLnggLyBHYW1lU2NlbmUuU0NSRUVOX1dJRFRIX1BST0RVQ1RTO1xuICAgIHNpemUueSA9IHNpemUueCAqIFByb2R1Y3QuQVNQRUNUX1JBVElPO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgcHVibGljIHNldCBwb3NpdGlvbkltbWVkaWF0ZSh2YWx1ZTogdmVjMikge1xuICAgIHRoaXMuYWN0dWFsUG9zaXRpb24gPSB2ZWMyLmNweSh2YWx1ZSk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZmluaXNoZWRNb3ZpbmcgPSB0cnVlO1xuICAgIHRoaXMubGFuZGluZ1RpbWUgPSAwO1xuICAgIHRoaXMucHJldmlvdXNTaGVsZkFuZFNsb3QgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShcbiAgICBkdDogbnVtYmVyLFxuICAgIGxldmVsOiBMZXZlbCxcbiAgICBjYW1lcmE6IENhbWVyYSxcbiAgICBzaGVsZjogU2hlbGYsXG4gICAgc2xvdEluZGV4OiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5zaXplID0gUHJvZHVjdC5jYWxjdWxhdGVTaXplKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbW91c2UgcG9zaXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBtb3VzZVdvcmxkUG9zaXRpb24gPSBjYW1lcmEuc2NyZWVuVG9Xb3JsZChJbnB1dE1hbmFnZXIubW91c2VQb3NpdGlvbik7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHByZXZpb3VzIHBvc2l0aW9uIGZvciB2ZWxvY2l0eSBjYWxjdWxhdGlvblxuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IHZlYzIuY3B5KHRoaXMuYWN0dWFsUG9zaXRpb24pO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBwcmV2aW91cyBzaGVsZiBhbmQgc2xvdCBmb3IgbGFuZGluZyBjaGVja3NcbiAgICBpZiAodGhpcy5wcmV2aW91c1NoZWxmQW5kU2xvdCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5wcmV2aW91c1NoZWxmQW5kU2xvdCA9IHsgc2hlbGYsIHNsb3RJbmRleCB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoZSBwcm9kdWN0XG4gICAgY29uc3QgaW50ZXJzZWN0cyA9IHBvaW50SW5BQUJCKFxuICAgICAgbW91c2VXb3JsZFBvc2l0aW9uLFxuICAgICAgdGhpcy5nZXRBQUJCKClcbiAgICApLmludGVyc2VjdHM7XG4gICAgdGhpcy5ob3ZlcmVkID0gaW50ZXJzZWN0cyB8fCB0aGlzLmRyYWdnaW5nO1xuXG4gICAgLy8gU3RhcnQgZHJhZ2dpbmcgd2hlbiB0aGUgbW91c2UgYnV0dG9uIGlzIHByZXNzZWRcbiAgICBpZiAoXG4gICAgICBJbnB1dE1hbmFnZXIubW91c2VQcmVzc2VkKCkgJiZcbiAgICAgIGludGVyc2VjdHMgJiZcbiAgICAgIHNoZWxmLmNhblBpY2tVcFByb2R1Y3RBdEluZGV4KHRoaXMsIHNsb3RJbmRleCkgJiZcbiAgICAgICF0aGlzLmxvY2tlZFxuICAgICkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmZpbmlzaGVkTW92aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmRyYWdPZmZzZXQgPSB2ZWMyLnN1Yihtb3VzZVdvcmxkUG9zaXRpb24sIHRoaXMuYWN0dWFsUG9zaXRpb24pO1xuICAgICAgbGV2ZWwuc3RhcnREcmFnZ2luZ1Byb2R1Y3Qoc2hlbGYsIHNsb3RJbmRleCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGRyYWdnaW5nXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcgJiYgSW5wdXRNYW5hZ2VyLm1vdXNlRG93bigpKSB7XG4gICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdmVjMi5zdWIoXG4gICAgICAgIG1vdXNlV29ybGRQb3NpdGlvbixcbiAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID8/IHZlYzIoKVxuICAgICAgKTtcbiAgICAgIHRoaXMubW92ZVRpbWUgPSBQcm9kdWN0Lk1PVkVfQ09PTERPV05fVElNRTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbW92ZW1lbnQgY29vbGRvd25cbiAgICB0aGlzLm1vdmVUaW1lID0gY2xhbXAodGhpcy5tb3ZlVGltZSAtIGR0LCAwLCBQcm9kdWN0Lk1PVkVfQ09PTERPV05fVElNRSk7XG5cbiAgICAvLyBJZiBub3QgZHJhZ2dpbmcsIHNuYXAgcG9zaXRpb24gdG8gc2hlbGYgc2xvdFxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHZlYzIuYWRkKFxuICAgICAgICBzaGVsZi5wb3NpdGlvbixcbiAgICAgICAgdmVjMi5tdWwodmVjMih0aGlzLnNpemUueCwgMCksIHNsb3RJbmRleClcbiAgICAgICk7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGZpbmlzaGVkIHRoZSBtb3ZlIGNvb2xkb3duLCBzbmFwIHRvIHRhcmdldCBwb3NpdGlvblxuICAgICAgaWYgKHRoaXMubW92ZVRpbWUgPT09IDApIHtcbiAgICAgICAgdGhpcy5maW5pc2hlZE1vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWN0dWFsUG9zaXRpb24gPSB2ZWMyLmNweSh0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UndmUgYWxtb3N0IGZpbmlzaGVkIGxhbmRpbmcgb24gYSBuZXcgc2hlbGYgYW5kL29yIHNsb3QsIHN0YXJ0IHRoZVxuICAgICAgLy8gbGFuZGluZyBjb29sZG93blxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnByZXZpb3VzU2hlbGZBbmRTbG90ICYmXG4gICAgICAgICh0aGlzLnByZXZpb3VzU2hlbGZBbmRTbG90LnNoZWxmICE9PSBzaGVsZiB8fFxuICAgICAgICAgIHRoaXMucHJldmlvdXNTaGVsZkFuZFNsb3Quc2xvdEluZGV4ICE9PSBzbG90SW5kZXgpICYmXG4gICAgICAgIHZlYzIubGVuKHZlYzIuc3ViKHRoaXMuYWN0dWFsUG9zaXRpb24sIHRoaXMudGFyZ2V0UG9zaXRpb24pKSA8XG4gICAgICAgICAgUHJvZHVjdC5MQU5ESU5HX0FOSU1BVElPTl9TVEFSVF9SQU5HRVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMubGFuZGluZ1RpbWUgPSBQcm9kdWN0LkxBTkRJTkdfQU5JTUFUSU9OX1RJTUU7XG4gICAgICAgIHRoaXMucHJldmlvdXNTaGVsZkFuZFNsb3QgPSB7IHNoZWxmLCBzbG90SW5kZXggfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbGFuZGluZyBhbmltYXRpb25cbiAgICB0aGlzLmxhbmRpbmdUaW1lID0gY2xhbXAoXG4gICAgICB0aGlzLmxhbmRpbmdUaW1lIC0gZHQsXG4gICAgICAwLFxuICAgICAgUHJvZHVjdC5MQU5ESU5HX0FOSU1BVElPTl9USU1FXG4gICAgKTtcblxuICAgIC8vIEhhbmRsZSBkaXNhcHBlYXJpbmcgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuZGlzYXBwZWFyaW5nKSB7XG4gICAgICB0aGlzLmRpc2FwcGVhcmluZ0RlbGF5ID0gY2xhbXAodGhpcy5kaXNhcHBlYXJpbmdEZWxheSAtIGR0LCAwLCBJbmZpbml0eSk7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZERpc2FwcGVhcmluZyAmJiB0aGlzLmRpc2FwcGVhcmluZ0RlbGF5IDw9IDApIHtcbiAgICAgICAgdGhpcy5zdGFydGVkRGlzYXBwZWFyaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWREaXNhcHBlYXJpbmcpIHtcbiAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lID0gY2xhbXAoXG4gICAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lIC0gZHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBQcm9kdWN0LkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGlzYXBwZWFyaW5nVGltZSA8PSAwKSB7XG4gICAgICAgIHRoaXMuZmluaXNoZWREaXNhcHBlYXJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVhc2UgbW92ZW1lbnQgdG93YXJkcyB0YXJnZXQgcG9zaXRpb25cbiAgICBpZiAodGhpcy50YXJnZXRQb3NpdGlvbikge1xuICAgICAgaWYgKHZlY3RvcnNBbG1vc3RFcXVhbCh0aGlzLmFjdHVhbFBvc2l0aW9uLCB0aGlzLnRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgICB0aGlzLmFjdHVhbFBvc2l0aW9uID0gdmVjMi5jcHkodGhpcy50YXJnZXRQb3NpdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMuZmluaXNoZWRNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHZlYzIuc3ViKHRoaXMudGFyZ2V0UG9zaXRpb24sIHRoaXMuYWN0dWFsUG9zaXRpb24pO1xuICAgICAgICB0aGlzLmFjdHVhbFBvc2l0aW9uID0gdmVjMi5hZGQoXG4gICAgICAgICAgdGhpcy5hY3R1YWxQb3NpdGlvbixcbiAgICAgICAgICB2ZWMyLm11bChkZWx0YSwgUHJvZHVjdC5NT1ZFX0VBU0VfQU1PVU5UKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB2ZWxvY2l0eSBiYXNlZCBvbiBwb3NpdGlvbiBjaGFuZ2VcbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVjMi5zdWIoXG4gICAgICB0aGlzLmFjdHVhbFBvc2l0aW9uLFxuICAgICAgdGhpcy5wcmV2aW91c1Bvc2l0aW9uID8/IHZlYzIoKVxuICAgICk7XG5cbiAgICAvLyBSb3RhdGUgYmFzZWQgb24gaG9yaXpvbnRhbCB2ZWxvY2l0eSBhbmQgZWFzZSByb3RhdGlvblxuICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8ICF0aGlzLmZpbmlzaGVkTW92aW5nKSB7XG4gICAgICB0aGlzLnRhcmdldFJvdGF0aW9uID0gdGhpcy52ZWxvY2l0eS54ICogUHJvZHVjdC5EUkFHX1JPVEFUSU9OX0FNT1VOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRSb3RhdGlvbiA9IDA7XG4gICAgfVxuICAgIHRoaXMuYWN0dWFsUm90YXRpb24gPSBjbGFtcChcbiAgICAgIHRoaXMuYWN0dWFsUm90YXRpb24gK1xuICAgICAgICAodGhpcy50YXJnZXRSb3RhdGlvbiAtIHRoaXMuYWN0dWFsUm90YXRpb24pICpcbiAgICAgICAgICBQcm9kdWN0LlJPVEFUSU9OX0VBU0VfQU1PVU5ULFxuICAgICAgLVByb2R1Y3QuTUFYX1JPVEFUSU9OLFxuICAgICAgUHJvZHVjdC5NQVhfUk9UQVRJT05cbiAgICApO1xuICB9XG5cbiAgcHVibGljIGRpc2FwcGVhcihkZWxheTogbnVtYmVyID0gMCkge1xuICAgIGlmICh0aGlzLmRpc2FwcGVhcmluZykge1xuICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IGRpc2FwcGVhcmluZ1xuICAgIH1cbiAgICB0aGlzLmRpc2FwcGVhcmluZyA9IHRydWU7XG4gICAgdGhpcy5zdGFydGVkRGlzYXBwZWFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5maW5pc2hlZERpc2FwcGVhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGlzYXBwZWFyaW5nVGltZSA9IFByb2R1Y3QuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9USU1FO1xuICAgIHRoaXMuZGlzYXBwZWFyaW5nRGVsYXkgPSBkZWxheTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBQUJCKCk6IEFBQkIge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5hY3R1YWxQb3NpdGlvbixcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG1hdGNoZXNQcm9kdWN0KG90aGVyOiBQcm9kdWN0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcy5pbmNsdWRlcyhvdGhlci5pZCk7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IHZlYzIuZGl2KHRoaXMuc2l6ZSwgMik7XG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgIHRoaXMuYWN0dWFsUG9zaXRpb24ueCArIGhhbGZTaXplLngsXG4gICAgICB0aGlzLmFjdHVhbFBvc2l0aW9uLnkgKyBoYWxmU2l6ZS55XG4gICAgKTtcbiAgICBjb250ZXh0LnJvdGF0ZSh0aGlzLmFjdHVhbFJvdGF0aW9uKTtcblxuICAgIC8vIExhbmRpbmcgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMubGFuZGluZ1RpbWUgPiAwKSB7XG4gICAgICBsZXQgc2l6ZSA9IHZlYzIuY3B5KHRoaXMuc2l6ZSk7XG4gICAgICBzaXplLnggPVxuICAgICAgICAxICtcbiAgICAgICAgTWF0aC5zaW4oXG4gICAgICAgICAgcmVtYXAodGhpcy5sYW5kaW5nVGltZSwgMCwgUHJvZHVjdC5MQU5ESU5HX0FOSU1BVElPTl9USU1FLCAwLCBNYXRoLlBJKVxuICAgICAgICApICpcbiAgICAgICAgICBQcm9kdWN0LkxBTkRJTkdfQU5JTUFUSU9OX1hfU0NBTEVfQU1PVU5UO1xuICAgICAgc2l6ZS55ID1cbiAgICAgICAgMSArXG4gICAgICAgIE1hdGguc2luKFxuICAgICAgICAgIHJlbWFwKHRoaXMubGFuZGluZ1RpbWUsIDAsIFByb2R1Y3QuTEFORElOR19BTklNQVRJT05fVElNRSwgMCwgTWF0aC5QSSlcbiAgICAgICAgKSAqXG4gICAgICAgICAgUHJvZHVjdC5MQU5ESU5HX0FOSU1BVElPTl9ZX1NDQUxFX0FNT1VOVDtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKDAsICh0aGlzLnNpemUueSAqICgxIC0gc2l6ZS55KSkgLyAyKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoc2l6ZS54LCBzaXplLnkpO1xuICAgIH1cblxuICAgIC8vIERpc2FwcGVhcmluZyBhbmltYXRpb25cbiAgICBpZiAodGhpcy5kaXNhcHBlYXJpbmcgJiYgdGhpcy5zdGFydGVkRGlzYXBwZWFyaW5nKSB7XG4gICAgICBsZXQgc2NhbGU7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuZGlzYXBwZWFyaW5nVGltZSA+PVxuICAgICAgICBQcm9kdWN0LkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRSAtXG4gICAgICAgICAgUHJvZHVjdC5ESVNBUFBFQVJJTkdfQU5JTUFUSU9OX0dST1dfVElNRVxuICAgICAgKSB7XG4gICAgICAgIHNjYWxlID0gcmVtYXAoXG4gICAgICAgICAgdGhpcy5kaXNhcHBlYXJpbmdUaW1lLFxuICAgICAgICAgIFByb2R1Y3QuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9USU1FLFxuICAgICAgICAgIFByb2R1Y3QuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9USU1FIC1cbiAgICAgICAgICAgIFByb2R1Y3QuRElTQVBQRUFSSU5HX0FOSU1BVElPTl9HUk9XX1RJTUUsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBQcm9kdWN0LkRJU0FQUEVBUklOR19BTklNQVRJT05fU0NBTEVfQU1PVU5UXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IHJlbWFwKFxuICAgICAgICAgIHRoaXMuZGlzYXBwZWFyaW5nVGltZSxcbiAgICAgICAgICBQcm9kdWN0LkRJU0FQUEVBUklOR19BTklNQVRJT05fVElNRSAtXG4gICAgICAgICAgICBQcm9kdWN0LkRJU0FQUEVBUklOR19BTklNQVRJT05fR1JPV19USU1FLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgUHJvZHVjdC5ESVNBUFBFQVJJTkdfQU5JTUFUSU9OX1NDQUxFX0FNT1VOVCxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgfVxuXG4gICAgcmVjdGFuZ2xlKGNvbnRleHQsIHZlYzIubXVsKGhhbGZTaXplLCAtMC41KSwgdmVjMi5zY2FsZSh0aGlzLnNpemUsIDAuNSksIHtcbiAgICAgIC4uLlByb2R1Y3QuU1RZTEUsXG4gICAgICBmaWxsQ29sb3I6ICF0aGlzLmZpbmlzaGVkTW92aW5nXG4gICAgICAgID8gJ3llbGxvdydcbiAgICAgICAgOiB0aGlzLmhvdmVyZWRcbiAgICAgICAgPyBQcm9kdWN0LkJBQ0tHUk9VTkRfSE9WRVJfQ09MT1JcbiAgICAgICAgOiBQcm9kdWN0LkJBQ0tHUk9VTkRfQ09MT1IsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5uYW1lKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICBjb250ZXh0LmZvbnQgPSAnMTZweCBBcmlhbCc7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy5uYW1lLCAwLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICBjb250ZXh0LmZvbnQgPSAnYm9sZCAxNnB4IEFyaWFsJztcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY29udGV4dC5maWxsVGV4dCgnTE9DS0VEJywgMCwgMjApO1xuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG5cbiAgcHVibGljIGRyYXdPdXRsaW5lKGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHNpemUgPSBQcm9kdWN0LmNhbGN1bGF0ZVNpemUoKTtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IHZlYzIuZGl2KHNpemUsIDIpO1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC50cmFuc2xhdGUodGhpcy5hY3R1YWxQb3NpdGlvbi54LCB0aGlzLmFjdHVhbFBvc2l0aW9uLnkpO1xuXG4gICAgcmVjdGFuZ2xlKGNvbnRleHQsIHZlYzIoKSwgc2l6ZSwgUHJvZHVjdC5PVVRMSU5FX1NUWUxFKTtcblxuICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gUHJvZHVjdC5PVVRMSU5FX1NUWUxFLnN0cm9rZUNvbG9yIGFzIHN0cmluZztcbiAgICAgIGNvbnRleHQuZm9udCA9ICcxNnB4IEFyaWFsJztcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLm5hbWUsIGhhbGZTaXplLngsIGhhbGZTaXplLnkpO1xuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYSc7XG5pbXBvcnQgeyByZWN0YW5nbGUsIFN0eWxlT3B0aW9ucyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbnZhcy1oZWxwZXJzJztcbmltcG9ydCB7XG4gIEFBQkIsXG4gIGFhYmJzT3ZlcmxhcCxcbiAgZGlzdGFuY2UsXG59IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzLzJkJztcbmltcG9ydCB7IGlzVmVjMiB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2ludGVyc2VjdGlvbi1oZWxwZXJzL3V0aWxpdGllcyc7XG5pbXBvcnQgeyB0aW1lcyB9IGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL3V0aWxzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgQWN0b3IsIFByb2R1Y3QgfSBmcm9tICcuJztcbmltcG9ydCBMZXZlbCBmcm9tICcuLi9MZXZlbCc7XG5pbXBvcnQgeyBQcm9kdWN0RmFjdG9yeSB9IGZyb20gJy4uL1Byb2R1Y3RGYWN0b3J5JztcblxuZXhwb3J0IHR5cGUgU2hlbGZEYXRhID0ge1xuICBwcm9kdWN0czogU2hlbGZQcm9kdWN0c0RhdGE7XG4gIG9mZnNldD86IHZlYzI7XG4gIHNsb3RDb3VudD86IG51bWJlcjtcbiAgbWF0Y2hDb3VudD86IG51bWJlcjtcbiAgaWdub3JlPzogYm9vbGVhbjtcbiAgcmVmZXJlbmNlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hlbGZEYXRhKFxuICBkYXRhOiBhbnlcbik6IGRhdGEgaXMgU2hlbGZEYXRhICYgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgaXNTaGVsZlByb2R1Y3RzRGF0YShkYXRhLnByb2R1Y3RzKSAmJlxuICAgIChkYXRhLm9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGlzVmVjMihkYXRhLm9mZnNldCkpICYmXG4gICAgKGRhdGEuc2xvdENvdW50ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEuc2xvdENvdW50ID09PSAnbnVtYmVyJykgJiZcbiAgICAoZGF0YS5tYXRjaENvdW50ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEubWF0Y2hDb3VudCA9PT0gJ251bWJlcicpICYmXG4gICAgKGRhdGEuaWdub3JlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEuaWdub3JlID09PSAnYm9vbGVhbicpICYmXG4gICAgKGRhdGEucmVmZXJlbmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGRhdGEucmVmZXJlbmNlID09PSAnc3RyaW5nJylcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgU2hlbGZQcm9kdWN0c0RhdGEgPSAoc3RyaW5nIHwgbnVsbClbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hlbGZQcm9kdWN0c0RhdGEoZGF0YTogYW55KTogZGF0YSBpcyBTaGVsZlByb2R1Y3RzRGF0YSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShkYXRhKSAmJlxuICAgIGRhdGEuZXZlcnkocHJvZHVjdCA9PiB0eXBlb2YgcHJvZHVjdCA9PT0gJ3N0cmluZycgfHwgcHJvZHVjdCA9PT0gbnVsbClcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgU2hlbGZQcm9kdWN0cyA9IChQcm9kdWN0IHwgbnVsbClbXTtcblxuLyoqXG4gKiBTaGVsZiBjb250YWlucyBzb21lIG51bWJlciBvZiBwcm9kdWN0c1xuICpcbiAqIFByb2R1Y3RzIGNhbiBiZSBkcmFnZ2VkIHRvIGFuZCBmcm9tIHRoZSBzaGVsZlxuICpcbiAqIFdoZW4gc29tZSBudW1iZXIgb2YgbWF0Y2hpbmcgcHJvZHVjdHMgYXJlIG9uIHRoZSBzaGVsZiwgdGhleSBkaXNhcHBlYXJcbiAqXG4gKiBJZiB0aGUgc2hlbGYgaXMgZW1wdHksIGl0IGlzIGNvbnNpZGVyZWQgY29tcGxldGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNoZWxmIGV4dGVuZHMgQWN0b3Ige1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfU0xPVF9DT1VOVDogbnVtYmVyID0gMztcbiAgcHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBERUZBVUxUX01BVENIX0NPVU5UOiBudW1iZXIgPSAzO1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERJU0FQUEVBUl9ERUxBWTogbnVtYmVyID0gMC4yO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVFlMRTogUGFydGlhbDxTdHlsZU9wdGlvbnM+ID0ge1xuICAgIHN0cm9rZUNvbG9yOiAnd2hpdGUnLFxuICAgIGxpbmVXaWR0aDogNCxcbiAgICBzdHJva2U6IHRydWUsXG4gICAgZmlsbDogZmFsc2UsXG4gIH07XG5cbiAgcHJvdGVjdGVkIHN0YXRzVXBkYXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgcHVibGljIHByb2R1Y3RzOiBTaGVsZlByb2R1Y3RzLFxuICAgIHB1YmxpYyBvZmZzZXQ6IHZlYzIgPSB2ZWMyKCksXG4gICAgcHVibGljIHNsb3RDb3VudDogbnVtYmVyID0gU2hlbGYuREVGQVVMVF9TTE9UX0NPVU5ULFxuICAgIHB1YmxpYyBtYXRjaENvdW50OiBudW1iZXIgPSBTaGVsZi5ERUZBVUxUX01BVENIX0NPVU5ULFxuICAgIHB1YmxpYyBpZ25vcmU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgcmVmZXJlbmNlPzogc3RyaW5nLFxuICAgIGFkZFRvTGV2ZWw6IGJvb2xlYW4gPSB0cnVlXG4gICkge1xuICAgIHN1cGVyKGxldmVsKTtcbiAgICBpZiAoYWRkVG9MZXZlbCkge1xuICAgICAgbGV2ZWwuc2hlbHZlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbURhdGEobGV2ZWw6IExldmVsLCBkYXRhOiBhbnkpOiBTaGVsZiB7XG4gICAgaWYgKCFpc1NoZWxmRGF0YShkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNoZWxmIGRhdGEnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvZHVjdHMgPSBkYXRhLnByb2R1Y3RzLm1hcChwcm9kdWN0SWQgPT5cbiAgICAgIHByb2R1Y3RJZCAhPT0gbnVsbCA/IFByb2R1Y3RGYWN0b3J5LmNyZWF0ZVByb2R1Y3QobGV2ZWwsIHByb2R1Y3RJZCkgOiBudWxsXG4gICAgKSBhcyBTaGVsZlByb2R1Y3RzO1xuICAgIHJldHVybiBuZXcgU2hlbGYoXG4gICAgICBsZXZlbCxcbiAgICAgIHByb2R1Y3RzLFxuICAgICAgZGF0YS5vZmZzZXQgfHwgdmVjMigpLFxuICAgICAgZGF0YS5zbG90Q291bnQgfHwgU2hlbGYuREVGQVVMVF9TTE9UX0NPVU5ULFxuICAgICAgZGF0YS5tYXRjaENvdW50IHx8IFNoZWxmLkRFRkFVTFRfTUFUQ0hfQ09VTlQsXG4gICAgICBkYXRhLmlnbm9yZSB8fCBmYWxzZSxcbiAgICAgIGRhdGEucmVmZXJlbmNlIHx8IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY2FsY3VsYXRlU2l6ZSgpOiB2ZWMyIHtcbiAgICBjb25zdCBwcm9kdWN0U2l6ZSA9IFByb2R1Y3QuY2FsY3VsYXRlU2l6ZSgpO1xuICAgIGNvbnN0IHNpemUgPSB2ZWMyKCk7XG4gICAgc2l6ZS54ID0gcHJvZHVjdFNpemUueCAqIHRoaXMuc2xvdENvdW50O1xuICAgIHNpemUueSA9IHByb2R1Y3RTaXplLnk7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIsIGxldmVsOiBMZXZlbCwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICB0aGlzLnByb2R1Y3RzLmZvckVhY2goKHByb2R1Y3QsIGluZGV4KSA9PiB7XG4gICAgICBwcm9kdWN0Py51cGRhdGUoZHQsIGxldmVsLCBjYW1lcmEsIHRoaXMsIGluZGV4KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBwcm9kdWN0cyB0aGF0IGhhdmUgZmluaXNoZWQgdGhlIGRpc2FwcGVhcmluZyBhbmltYXRpb25cbiAgICB0aGlzLnByb2R1Y3RzID0gdGhpcy5wcm9kdWN0cy5tYXAocHJvZHVjdCA9PiB7XG4gICAgICBpZiAocHJvZHVjdCAmJiBwcm9kdWN0LmZpbmlzaGVkRGlzYXBwZWFyaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgfSkgYXMgU2hlbGZQcm9kdWN0cztcblxuICAgIC8vIElmIGEgbWF0Y2ggaXMgZm91bmQsIHJlbW92ZSB0aGUgbWF0Y2hpbmcgcHJvZHVjdHNcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2hlY2tGb3JNYXRjaGVzKCk7XG4gICAgaWYgKG1hdGNoLmZvdW5kKSB7XG4gICAgICBtYXRjaC5tYXRjaGVzLmZvckVhY2goKHByb2R1Y3QsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICAgICAgcHJvZHVjdC5kaXNhcHBlYXIoaW5kZXggKiBTaGVsZi5ESVNBUFBFQVJfREVMQVkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3RhdHNcbiAgICBpZiAoIXRoaXMuc3RhdHNVcGRhdGVkKSB7XG4gICAgICBpZiAobWF0Y2guZm91bmQpIHtcbiAgICAgICAgbWF0Y2gubWF0Y2hlcy5mb3JFYWNoKHByb2R1Y3QgPT4ge1xuICAgICAgICAgIGlmIChwcm9kdWN0KSB7XG4gICAgICAgICAgICBsZXZlbC5zdGF0cy5wcm9kdWN0TWF0Y2hlc1twcm9kdWN0LmlkXS50b3RhbCsrO1xuICAgICAgICAgICAgbGV2ZWwuc3RhdHMudG90YWxNYXRjaGVzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0c1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2hlbGZJc0NvbXBsZXRlKCkpIHtcbiAgICAgICAgbGV2ZWwuc3RhdHMudG90YWxDb21wbGV0ZWRTaGVsdmVzKys7XG4gICAgICAgIHRoaXMuc3RhdHNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZmluZFNoZWxmU2xvdChwcm9kdWN0OiBQcm9kdWN0KToge1xuICAgIHZhbGlkOiBib29sZWFuO1xuICAgIHNsb3RJbmRleD86IG51bWJlcjtcbiAgICBwcm9kdWN0PzogUHJvZHVjdCB8IG51bGw7XG4gICAgZGlzdGFuY2U/OiBudW1iZXI7XG4gIH0ge1xuICAgIGNvbnN0IGFhYmIgPSBwcm9kdWN0LmdldEFBQkIoKTtcbiAgICBjb25zdCBzaGVsZlNsb3RzOiB7IGluZGV4OiBudW1iZXI7IGFhYmI6IEFBQkI7IGRpc3RhbmNlOiBudW1iZXIgfVtdID0gdGltZXMoXG4gICAgICBpbmRleCA9PiAoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgYWFiYjogdGhpcy5nZXRBQUJCKGluZGV4KSxcbiAgICAgIH0pLFxuICAgICAgdGhpcy5zbG90Q291bnRcbiAgICApXG4gICAgICAuZmlsdGVyKHNsb3QgPT4gdGhpcy5jYW5Ecm9wUHJvZHVjdEF0SW5kZXgocHJvZHVjdCwgc2xvdC5pbmRleCkpXG4gICAgICAuZmlsdGVyKHNsb3QgPT4gYWFiYnNPdmVybGFwKGFhYmIsIHNsb3QuYWFiYikuaW50ZXJzZWN0cylcbiAgICAgIC5tYXAoc2xvdCA9PiAoe1xuICAgICAgICAuLi5zbG90LFxuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UoXG4gICAgICAgICAgdmVjMi5hZGQoc2xvdC5hYWJiLnBvc2l0aW9uLCB2ZWMyLmRpdihzbG90LmFhYmIuc2l6ZSwgMikpLFxuICAgICAgICAgIHZlYzIuYWRkKGFhYmIucG9zaXRpb24sIHZlYzIuZGl2KGFhYmIuc2l6ZSwgMikpXG4gICAgICAgICksXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZSk7XG4gICAgY29uc3QgY2xvc2VzdFNsb3QgPSBzaGVsZlNsb3RzWzBdO1xuXG4gICAgaWYgKGNsb3Nlc3RTbG90KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgc2xvdEluZGV4OiBjbG9zZXN0U2xvdC5pbmRleCxcbiAgICAgICAgcHJvZHVjdDogdGhpcy5wcm9kdWN0c1tjbG9zZXN0U2xvdC5pbmRleF0sXG4gICAgICAgIGRpc3RhbmNlOiBjbG9zZXN0U2xvdC5kaXN0YW5jZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gIH1cblxuICBwdWJsaWMgY2FuUGlja1VwUHJvZHVjdEF0SW5kZXgoX3Byb2R1Y3Q6IFByb2R1Y3QsIGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2xvdENvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEludmFsaWQgaW5kZXhcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvZHVjdHNbaW5kZXhdID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIHByb2R1Y3QgaW4gdGhlIHNwZWNpZmllZCBzbG90XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGNhbkRyb3BQcm9kdWN0QXRJbmRleChfcHJvZHVjdDogUHJvZHVjdCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zbG90Q291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBpbmRleFxuICAgIH1cbiAgICBpZiAodGhpcy5wcm9kdWN0c1tpbmRleF0gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gU2xvdCBpcyBhbHJlYWR5IG9jY3VwaWVkXG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wcm9kdWN0cy5ldmVyeShwcm9kdWN0ID0+IHByb2R1Y3QgPT09IG51bGwpO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zaGVsZklzRW1wdHkoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0Zvck1hdGNoZXMoKToge1xuICAgIGZvdW5kOiBib29sZWFuO1xuICAgIG1hdGNoZXM6IFByb2R1Y3RbXTtcbiAgfSB7XG4gICAgY29uc3QgdmFsaWRQcm9kdWN0cyA9IHRoaXMucHJvZHVjdHMuZmlsdGVyKFxuICAgICAgcHJvZHVjdCA9PiBwcm9kdWN0ICE9PSBudWxsICYmICFwcm9kdWN0LmRpc2FwcGVhcmluZ1xuICAgICkgYXMgUHJvZHVjdFtdO1xuICAgIGNvbnN0IGFsbE1hdGNoZXMgPSB0aGlzLmZpbmRNYXRjaGluZ0dyb3Vwcyh2YWxpZFByb2R1Y3RzKTtcblxuICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBmaXJzdCBtYXRjaGluZyBncm91cCBmb3VuZFxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogYWxsTWF0Y2hlcy5sZW5ndGggPiAwLFxuICAgICAgbWF0Y2hlczogYWxsTWF0Y2hlc1swXSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kTWF0Y2hpbmdHcm91cHMocHJvZHVjdHM6IFByb2R1Y3RbXSk6IFByb2R1Y3RbXVtdIHtcbiAgICBjb25zdCBtYXRjaGVzOiBQcm9kdWN0W11bXSA9IFtdO1xuXG4gICAgLy8gVHJ5IGVhY2ggcHJvZHVjdCBhcyBhIHN0YXJ0aW5nIHBvaW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9kdWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRQcm9kdWN0ID0gcHJvZHVjdHNbaV07XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuZ3Jvd01hdGNoaW5nR3JvdXAoW3N0YXJ0UHJvZHVjdF0sIHByb2R1Y3RzKTtcblxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+PSB0aGlzLm1hdGNoQ291bnQpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGdyb3VwLnNsaWNlKDAsIHRoaXMubWF0Y2hDb3VudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIHByaXZhdGUgZ3Jvd01hdGNoaW5nR3JvdXAoXG4gICAgY3VycmVudEdyb3VwOiBQcm9kdWN0W10sXG4gICAgYXZhaWxhYmxlUHJvZHVjdHM6IFByb2R1Y3RbXVxuICApOiBQcm9kdWN0W10ge1xuICAgIC8vIElmIHdlIGhhdmUgZW5vdWdoIG1hdGNoZXMsIHN0b3AgcmVjdXJzaW5nXG4gICAgaWYgKGN1cnJlbnRHcm91cC5sZW5ndGggPj0gdGhpcy5tYXRjaENvdW50KSB7XG4gICAgICByZXR1cm4gY3VycmVudEdyb3VwO1xuICAgIH1cblxuICAgIC8vIEZpbmQgYWxsIHByb2R1Y3RzIHRoYXQgbWF0Y2ggd2l0aCBldmVyeSBwcm9kdWN0IGluIHRoZSBjdXJyZW50IGdyb3VwXG4gICAgY29uc3QgbWF0Y2hpbmdQcm9kdWN0cyA9IGF2YWlsYWJsZVByb2R1Y3RzLmZpbHRlcihcbiAgICAgIHByb2R1Y3QgPT5cbiAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBwcm9kdWN0cyBhbHJlYWR5IGluIHRoZSBncm91cFxuICAgICAgICAhY3VycmVudEdyb3VwLmluY2x1ZGVzKHByb2R1Y3QpICYmXG4gICAgICAgIC8vIFByb2R1Y3QgbXVzdCBtYXRjaCB3aXRoIGFsbCBwcm9kdWN0cyBpbiB0aGUgY3VycmVudCBncm91cFxuICAgICAgICBjdXJyZW50R3JvdXAuZXZlcnkoZ3JvdXBQcm9kdWN0ID0+IHByb2R1Y3QubWF0Y2hlc1Byb2R1Y3QoZ3JvdXBQcm9kdWN0KSlcbiAgICApO1xuXG4gICAgLy8gSWYgbm8gbWF0Y2hpbmcgcHJvZHVjdHMgYXJlIGZvdW5kLCBzdG9wIHJlY3Vyc2luZ1xuICAgIGlmIChtYXRjaGluZ1Byb2R1Y3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRHcm91cDtcbiAgICB9XG5cbiAgICAvLyBUYWtlIHRoZSBmaXJzdCBtYXRjaGluZyBwcm9kdWN0IGFuZCBhZGQgaXQgdG8gdGhlIGdyb3VwXG4gICAgcmV0dXJuIHRoaXMuZ3Jvd01hdGNoaW5nR3JvdXAoXG4gICAgICBbLi4uY3VycmVudEdyb3VwLCBtYXRjaGluZ1Byb2R1Y3RzWzBdXSxcbiAgICAgIGF2YWlsYWJsZVByb2R1Y3RzXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBQUJCKGluZGV4PzogbnVtYmVyKTogQUFCQiB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICBzaXplOiB0aGlzLmNhbGN1bGF0ZVNpemUoKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByb2R1Y3RTaXplID0gUHJvZHVjdC5jYWxjdWxhdGVTaXplKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLCB2ZWMyKHByb2R1Y3RTaXplLnggKiBpbmRleCwgMCkpLFxuICAgICAgc2l6ZTogcHJvZHVjdFNpemUsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRQcm9kdWN0QXRJbmRleChpbmRleDogbnVtYmVyLCBwcm9kdWN0OiBQcm9kdWN0KTogYm9vbGVhbiB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNsb3RDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbnZhbGlkIGluZGV4XG4gICAgfVxuICAgIGlmICh0aGlzLnByb2R1Y3RzW2luZGV4XSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTbG90IGlzIGFscmVhZHkgb2NjdXBpZWRcbiAgICB9XG4gICAgdGhpcy5wcm9kdWN0c1tpbmRleF0gPSBwcm9kdWN0O1xuICAgIHRoaXMuc3RhdHNVcGRhdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlUHJvZHVjdEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IFByb2R1Y3QgfCBudWxsIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2xvdENvdW50KSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gSW52YWxpZCBpbmRleFxuICAgIH1cbiAgICBjb25zdCBwcm9kdWN0ID0gdGhpcy5wcm9kdWN0c1tpbmRleF07XG4gICAgdGhpcy5wcm9kdWN0c1tpbmRleF0gPSBudWxsO1xuICAgIHRoaXMuc3RhdHNVcGRhdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHByb2R1Y3Q7XG4gIH1cblxuICBwdWJsaWMgbG9ja1Byb2R1Y3RBdEluZGV4KFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgbG9ja2VkOiBib29sZWFuID0gdHJ1ZVxuICApOiBib29sZWFuIHwgbnVsbCB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNsb3RDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgaW5kZXhcbiAgICB9XG4gICAgY29uc3QgcHJvZHVjdCA9IHRoaXMucHJvZHVjdHNbaW5kZXhdO1xuICAgIGlmIChwcm9kdWN0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gTm8gcHJvZHVjdCB0byBsb2NrXG4gICAgfVxuICAgIHByb2R1Y3QubG9ja2VkID0gbG9ja2VkO1xuICAgIHJldHVybiBwcm9kdWN0LmxvY2tlZDtcbiAgfVxuXG4gIHB1YmxpYyBkcmF3KGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZHJhd1Byb2R1Y3RzOiBib29sZWFuID0gdHJ1ZSkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIHJlY3RhbmdsZShjb250ZXh0LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmNhbGN1bGF0ZVNpemUoKSwgU2hlbGYuU1RZTEUpO1xuICAgIGlmIChkcmF3UHJvZHVjdHMpIHtcbiAgICAgIHRoaXMucHJvZHVjdHMuZm9yRWFjaChwcm9kdWN0ID0+IHtcbiAgICAgICAgaWYgKHByb2R1Y3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2R1Y3QuZHJhZ2dpbmcpIHtcbiAgICAgICAgICByZXR1cm47IC8vIFdlIHdpbGwgZHJhdyB0aGUgY3VycmVudGx5IGRyYWdnZWQgcHJvZHVjdCBzZXBhcmF0ZWx5XG4gICAgICAgIH1cbiAgICAgICAgcHJvZHVjdC5kcmF3KGNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgQ2FtZXJhIGZyb20gJ0BiYXNlbWVudHVuaXZlcnNlL2NhbWVyYSc7XG5pbXBvcnQgeyBBQUJCIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvMmQnO1xuaW1wb3J0IHsgaXNWZWMyIH0gZnJvbSAnQGJhc2VtZW50dW5pdmVyc2UvaW50ZXJzZWN0aW9uLWhlbHBlcnMvdXRpbGl0aWVzJztcbmltcG9ydCB7IHZlYzIgfSBmcm9tICdAYmFzZW1lbnR1bml2ZXJzZS92ZWMnO1xuaW1wb3J0IHsgUHJvZHVjdCwgU2hlbGYgfSBmcm9tICcuJztcbmltcG9ydCBMZXZlbCBmcm9tICcuLi9MZXZlbCc7XG5pbXBvcnQge1xuICBBYnN0cmFjdFNoZWxmRGF0YSxcbiAgaXNBYnN0cmFjdFNoZWxmRGF0YSxcbiAgU2hlbGZGYWN0b3J5LFxufSBmcm9tICcuLi9TaGVsZkZhY3RvcnknO1xuXG5leHBvcnQgdHlwZSBTdXBwbHlTaGVsZkRhdGEgPSB7XG4gIHNoZWxmOiBBYnN0cmFjdFNoZWxmRGF0YTxcbiAgICAnc2hlbGYnIHwgJ2RlZXAtc2hlbGYnIHwgJ2Rpc2FwcGVhcmluZy1zaGVsZicgfCAnbG9ja2luZy1zaGVsZidcbiAgPjtcbiAgb2Zmc2V0PzogdmVjMjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBseVNoZWxmRGF0YShkYXRhOiBhbnkpOiBkYXRhIGlzIFN1cHBseVNoZWxmRGF0YSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgaXNBYnN0cmFjdFNoZWxmRGF0YShkYXRhLnNoZWxmLCBbXG4gICAgICAnc2hlbGYnLFxuICAgICAgJ2RlZXAtc2hlbGYnLFxuICAgICAgJ2Rpc2FwcGVhcmluZy1zaGVsZicsXG4gICAgICAnbG9ja2luZy1zaGVsZicsXG4gICAgXSkgJiZcbiAgICAoZGF0YS5vZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBpc1ZlYzIoZGF0YS5vZmZzZXQpKVxuICApO1xufVxuXG4vKipcbiAqIFN1cHBseSBzaGVsZiBjYW4gb25seSBoYXZlIHByb2R1Y3RzIHJlbW92ZWQgZnJvbSBpdFxuICovXG5leHBvcnQgY2xhc3MgU3VwcGx5U2hlbGYgZXh0ZW5kcyBTaGVsZiB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgcHVibGljIHNoZWxmOiBTaGVsZixcbiAgICBwdWJsaWMgb2Zmc2V0OiB2ZWMyID0gdmVjMigpXG4gICkge1xuICAgIHNoZWxmLmNhbkRyb3BQcm9kdWN0QXRJbmRleCA9IChcbiAgICAgIF9wcm9kdWN0OiBQcm9kdWN0LFxuICAgICAgX2luZGV4OiBudW1iZXJcbiAgICApOiBib29sZWFuID0+IGZhbHNlO1xuICAgIHN1cGVyKGxldmVsLCBbXSwgb2Zmc2V0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21EYXRhKGxldmVsOiBMZXZlbCwgZGF0YTogYW55KTogU3VwcGx5U2hlbGYge1xuICAgIGlmICghaXNTdXBwbHlTaGVsZkRhdGEoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdXBwbHkgc2hlbGYgZGF0YScpO1xuICAgIH1cbiAgICBjb25zdCBzaGVsZiA9IFNoZWxmRmFjdG9yeS5jcmVhdGVTaGVsZihsZXZlbCwgZGF0YS5zaGVsZik7XG4gICAgcmV0dXJuIG5ldyBTdXBwbHlTaGVsZihsZXZlbCwgc2hlbGYsIGRhdGEub2Zmc2V0IHx8IHZlYzIoKSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGR0OiBudW1iZXIsIGxldmVsOiBMZXZlbCwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICB0aGlzLnNoZWxmLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICB0aGlzLnNoZWxmLnVwZGF0ZShkdCwgbGV2ZWwsIGNhbWVyYSk7XG4gIH1cblxuICBwdWJsaWMgZmluZFNoZWxmU2xvdChfcHJvZHVjdDogUHJvZHVjdCk6IHtcbiAgICB2YWxpZDogYm9vbGVhbjtcbiAgfSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gIH1cblxuICBwdWJsaWMgY2FuUGlja1VwUHJvZHVjdEF0SW5kZXgoX3Byb2R1Y3Q6IFByb2R1Y3QsIF9pbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGNhbkRyb3BQcm9kdWN0QXRJbmRleChfcHJvZHVjdDogUHJvZHVjdCwgX2luZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgc2hlbGZJc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNoZWxmSXNDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zaGVsZi5zaGVsZklzQ29tcGxldGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBQUJCKGluZGV4PzogbnVtYmVyKTogQUFCQiB7XG4gICAgcmV0dXJuIHRoaXMuc2hlbGYuZ2V0QUFCQihpbmRleCk7XG4gIH1cblxuICBwdWJsaWMgZHJhdyhjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICB0aGlzLnNoZWxmLmRyYXcoY29udGV4dCk7XG4gIH1cbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vQWN0b3InO1xuZXhwb3J0ICogZnJvbSAnLi9DYXJvdXNlbCc7XG5leHBvcnQgKiBmcm9tICcuL0Nsb3NpbmdTaGVsZic7XG5leHBvcnQgKiBmcm9tICcuL0NvbGxhcHNlJztcbmV4cG9ydCAqIGZyb20gJy4vRGVlcFNoZWxmJztcbmV4cG9ydCAqIGZyb20gJy4vRGlzYXBwZWFyaW5nU2hlbGYnO1xuZXhwb3J0ICogZnJvbSAnLi9EaXNwbGF5U2hlbGYnO1xuZXhwb3J0ICogZnJvbSAnLi9Mb2NraW5nU2hlbGYnO1xuZXhwb3J0ICogZnJvbSAnLi9Qcm9kdWN0JztcbmV4cG9ydCAqIGZyb20gJy4vU2hlbGYnO1xuZXhwb3J0ICogZnJvbSAnLi9TdXBwbHlTaGVsZic7XG4iLCJleHBvcnQgY29uc3QgREVCVUcgPSB0cnVlO1xuZXhwb3J0IGNvbnN0IFNJTVVMQVRFX1NMT1dfTE9BRElORyA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IEZQU19NSU4gPSAxIC8gMzA7XG4iLCJpbXBvcnQgR2FtZSBmcm9tICcuL0dhbWUnO1xuXG53aW5kb3cub25sb2FkID0gKCkgPT4ge1xuICBjb25zdCBnYW1lID0gbmV3IEdhbWUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2dhbWUnKSk7XG4gIGdhbWUuaW5pdGlhbGlzZSgpO1xufTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==